<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>南寒</title>
  
  <subtitle>这一切都是命运石之门的选择！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yehengchao.cn/"/>
  <updated>2018-07-02T01:05:55.963Z</updated>
  <id>http://yehengchao.cn/</id>
  
  <author>
    <name>Ico</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring高级话题</title>
    <link href="http://yehengchao.cn/2018/06/30/Spring%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/"/>
    <id>http://yehengchao.cn/2018/06/30/Spring高级话题/</id>
    <published>2018-06-30T02:16:29.000Z</published>
    <updated>2018-07-02T01:05:55.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要记录Spring容器中的Bean如何实现Aware接口来对事件进行发布管理，Spring容器通过一个基于线程池的任务执行器来进行异步任务的并发，条件注解的使用，组合注解声明，Enable*注解的原理以及如何进行测试。</p></blockquote><a id="more"></a><h4 id="Spring-Aware"><a href="#Spring-Aware" class="headerlink" title="Spring Aware"></a>Spring Aware</h4><p>​    Spring的依赖注入最大亮点就是所有的Bean 对Spring 容器的存在是没有意识的。即可以将现在的容器换成别的容器，比如 Goole Guice，这时Bean之间的耦合度很低。</p><p>​    但是实际项目中不可避免的用到Spring 容器本身的功能资源，这时Bean必须意识到Spring 容器的存在，才能调用Spring所提供的资源，这就是Spring Aware。使用了Spring Aware 的话Bean将会和Spring 架构之间耦合。</p><p>Spring 提供的Aware接口如图所示：</p><table><thead><tr><th>接口</th><th>功能</th></tr></thead><tbody><tr><td>BeanNameAware</td><td>获得容器中Bean的名称</td></tr><tr><td>BeanFactoryAware</td><td>获得当前 bean factory，这样可以调用容器服务。</td></tr><tr><td>ApplicationContextAware*</td><td>当前 application context，这样可以调用容器服务。</td></tr><tr><td>MessageSourceAware</td><td>获得message source，这样可以获得文本信息。</td></tr><tr><td>ApplicationEventPublisherAware</td><td>应用事件发布器，可以发布事件。</td></tr><tr><td>ResourceLoaderAware</td><td>获得资源加载器，可以获得外部资源文件</td></tr></tbody></table><p>​    Spring Aware 的目的是为了让Bean获得Spring 容器的服务。因为ApplicationContext接口集成了MessageSource接口、ApplicationEventPublisher接口和ResourceLoader接口，所以Bean 只要继承ApplicationContext就可以获得Spring容器的所有服务，但原则上还是用到什么接口就实现什么接口。</p><blockquote><p>示例，Spring Aware演示的Bean</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ResourceLoaderAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ResourceLoader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwareService</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;   <span class="comment">//实现BeanNameAware和ResourceLoaderAware两个接口，获得Bean名称和资源加载的服务。</span></span><br><span class="line">    <span class="keyword">private</span> String beanName;</span><br><span class="line">    <span class="keyword">private</span> ResourceLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//这里还有下面的注解刚开始出了点小问题，实现接口方法用@Override出现 "@Override is not allowed when implementing interface method" ,[解决办法及原因](https://stackoverflow.com/questions/15402615/override-is-not-allowed-when-implementing-interface-method)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span></span>&#123;    <span class="comment">//重写setResource方法。</span></span><br><span class="line">        <span class="keyword">this</span>.loader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span></span>&#123;   <span class="comment">//重写setBeanName方法。</span></span><br><span class="line">        <span class="keyword">this</span>.beanName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outputResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean的名称为："</span> + beanName);</span><br><span class="line">        Resource resource = loader.getResource(<span class="string">"classpath:aware/test.txt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"ResourceLoader加载的文件内容为："</span> + IOUtils.toString(resource.getInputStream()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"aware"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwareConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AwareConfig.class);</span><br><span class="line"></span><br><span class="line">        AwareService awareService = context.getBean(AwareService.class);</span><br><span class="line"></span><br><span class="line">        awareService.outputResult();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Bean的名称为：awareService</span><br><span class="line">ResourceLoader加载的文件内容为：<span class="keyword">this</span> is a test file</span><br></pre></td></tr></table></figure><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>​    Spring 通过任务执行器(TaskExecutor) 来实现多线程和并发编程。使用TaskExecutorConfig 可实现一个基于线程池的TaskExecutor。实际开发中的任务一般是非阻碍的，即异步的，所以需要在配置类中使用@EnableAsync开启对异步任务的支持，并通过在实际执行的Bean方法中使用@Async注解来生命这是一个异步任务。</p><blockquote><p>通过一个示例来进行说明，首先写配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> taskexecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.AsyncConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableAsync;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"taskexecutor"</span>)</span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskExecutorConfig</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;    <span class="comment">//配置类实现AsyncConfigurer接口对异常线程池更加细粒度的控制，创建线程自己的线程池。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span></span>&#123; <span class="comment">//重写getAsyncExecutor方法并返回一个ThreadPoolTaskExecutor，这样就获得了一个基于线程池TaskExecutor</span></span><br><span class="line">        ThreadPoolTaskExecutor taskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        taskExecutor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line">        taskExecutor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        taskExecutor.setQueueCapacity(<span class="number">25</span>);</span><br><span class="line">        taskExecutor.initialize();</span><br><span class="line">        <span class="keyword">return</span> taskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后是任务执行类，就是上面所说的Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> taskexecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span>  <span class="comment">//通过该注解表明该方法是个异步方法，如果注解在类级别上，则表明该类所有的方法都是异步方法，这里的方法自动被注入使用ThreadPoolTaskExecutor作为TaskExecutor。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executorAsyncTask</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行异步任务： "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>  <span class="comment">//同上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executorAsyncTaskPlus</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行异步任务+1： "</span> + (i+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> taskexecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(TaskExecutorConfig.class);</span><br><span class="line"></span><br><span class="line">        AsyncTaskService asyncTaskService = context.getBean(AsyncTaskService.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            asyncTaskService.executorAsyncTask(i);</span><br><span class="line">            asyncTaskService.executorAsyncTaskPlus(i);</span><br><span class="line">        &#125;</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下所示：</span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">1</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">3</span></span><br><span class="line">执行异步任务： <span class="number">3</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">4</span></span><br><span class="line">执行异步任务： <span class="number">4</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">5</span></span><br><span class="line">执行异步任务： <span class="number">5</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">6</span></span><br><span class="line">执行异步任务： <span class="number">6</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">7</span></span><br><span class="line">执行异步任务： <span class="number">7</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">8</span></span><br><span class="line">执行异步任务： <span class="number">8</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">9</span></span><br><span class="line">执行异步任务： <span class="number">9</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">10</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">2</span></span><br><span class="line">执行异步任务： <span class="number">2</span></span><br><span class="line">执行异步任务： <span class="number">0</span></span><br><span class="line">执行异步任务： <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看出运行结果是并发执行而不是顺序执行的。</p><h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><p>​    从Spring3.1开始，计划任务在Spring中的实现变得非常简单，首先通过在配置类添加注解@EnableScheduling 来开启对计划任务的支持，然后在要执行计划任务的方法上注解@Scheduled，声明这是一个计划任务。通过该注解Spring支持多种类型的计划任务，包含cron、fixDelay、fixRate等。</p><blockquote><p>首先实现计划任务实现类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> taskscheduler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledTaskService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">5000</span>)    <span class="comment">//通过@Scheduled声明该方法是计划任务，使用fixedRate设定每隔固定时间5秒执行一次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportCurrentTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"每隔五秒执行一次 "</span> + dateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0 50 19 ? * *"</span>)   <span class="comment">//使用cron属性可以按照指定的时间执行。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fixTimeExecution</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在指定时间 "</span> + dateFormat.format(<span class="keyword">new</span> Date()) + <span class="string">"执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后实现配置类，主要是开启对计划任务的支持：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> taskscheduler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"taskscheduler"</span>)</span><br><span class="line"><span class="meta">@EnableScheduling</span>   <span class="comment">//使用此注解开启对计划任务的支持。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskSchedulerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> taskscheduler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(TaskSchedulerConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行效果如下图所示：</span><br><span class="line">每隔五秒执行一次 <span class="number">19</span>:<span class="number">49</span>:<span class="number">46</span></span><br><span class="line">每隔五秒执行一次 <span class="number">19</span>:<span class="number">49</span>:<span class="number">51</span></span><br><span class="line">每隔五秒执行一次 <span class="number">19</span>:<span class="number">49</span>:<span class="number">56</span></span><br><span class="line">在指定时间 <span class="number">19</span>:<span class="number">50</span>:<span class="number">00</span>执行</span><br><span class="line">每隔五秒执行一次 <span class="number">19</span>:<span class="number">50</span>:<span class="number">01</span></span><br><span class="line">每隔五秒执行一次 <span class="number">19</span>:<span class="number">50</span>:<span class="number">06</span></span><br></pre></td></tr></table></figure><h4 id="条件注解-Conditional"><a href="#条件注解-Conditional" class="headerlink" title="条件注解@Conditional"></a>条件注解@Conditional</h4><p>​    Spring 4提供了一个基于条件的Bean的创建，即使用@Conditional注解，该注解根据满足某一个特定条件创建一个特定的Bean。如当一个jar包在一个类路径下的时候，自动配置一个或多个Bean；或者只有某个Bean被创建才会创建另外一个Bean。</p><p>​    下面演示一个以不同操作系统为条件，通过实现Condition接口，并重写matches方法来构造判断条件。</p><blockquote><p>首先实现Windows条件的判定：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> conditional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Condition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.getEnvironment().getProperty(<span class="string">"os.name"</span>).contains(<span class="string">"Windows"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Linux条件判定：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> conditional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Condition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.getEnvironment().getProperty(<span class="string">"os.name"</span>).contains(<span class="string">"Linux"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义Service接口：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> conditional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Windows下要创建的Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> conditional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsListService</span> <span class="keyword">implements</span> <span class="title">ListService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"dir"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> conditional;</span><br></pre></td></tr></table></figure><blockquote><p>Linux下要创建的Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> conditional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxListService</span> <span class="keyword">implements</span> <span class="title">ListService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ls"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> conditional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Conditional;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional</span>(WindowsCondition.class)    <span class="comment">//通过@Conditional注解，符合Windows条件则实例化WindowsListService。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListService <span class="title">WindowsListService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowsListService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional</span>(LinuxCondition.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListService <span class="title">LinuxListService</span><span class="params">()</span></span>&#123;  <span class="comment">//同上，实例化LinuxListService。</span></span><br><span class="line">        <span class="keyword">return</span> LinuxListService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> conditional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ConditionConfig.class);</span><br><span class="line"></span><br><span class="line">        ListService listService = context.getBean(ListService.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getEnvironment().getProperty(<span class="string">"os.name"</span>) + <span class="string">"系统下的列表命令为："</span> + listService.showList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在Windows下的运行结果：</span><br><span class="line">Windows <span class="number">10</span>系统下的列表命令为：dir</span><br><span class="line"></span><br><span class="line">打包为jar包，Linux下的运行结果：</span><br><span class="line">INFO: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@<span class="number">7</span>cd84586: startup date [Sun Jul <span class="number">01</span> <span class="number">21</span>:<span class="number">06</span>:<span class="number">31</span> CST <span class="number">2018</span>]; root of context hierarchy</span><br><span class="line">Linux系统下的列表命令为：ls</span><br></pre></td></tr></table></figure><h4 id="组合注解与元注解"><a href="#组合注解与元注解" class="headerlink" title="组合注解与元注解"></a>组合注解与元注解</h4><p>​    从Spring 2开始，为了响应jdk 1.5推出的注解功能，Spring开始大量加入注解来代替xml配置。之前所涉及到的基本上都是元注解，元注解其实就是可以注解到别的注解上的注解，被注解的注解则称为组合注解，组合注解具备注解其上的元注解的功能。下面通过一个自定义的注解实现将@Configuration和@ComponentScan两个注解的组合。</p><blockquote><p>首先实现示例组合注解：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//组合@Configuration元注解</span></span><br><span class="line"><span class="meta">@ComponentScan</span>  <span class="comment">//组合@ComponentScan元注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WiselyConfigration &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;    <span class="comment">//覆盖value参数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>演示服务Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outputResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"从组合注解获得bean"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>加上组合注解的配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"><span class="meta">@WiselyConfigration</span>(<span class="string">"annotation"</span>)   <span class="comment">//使用自定义的组合注解，代替@Configuration和@ComponentScan。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(DemoConfig.class);</span><br><span class="line"></span><br><span class="line">        DemoService demoService = context.getBean(DemoService.class);</span><br><span class="line"></span><br><span class="line">        demoService.outputResult();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下：</span><br><span class="line">从组合注解获得bean</span><br></pre></td></tr></table></figure><h4 id="Enable-注解的工作原理"><a href="#Enable-注解的工作原理" class="headerlink" title="@Enable*注解的工作原理"></a>@Enable*注解的工作原理</h4><p>​    所有的@Enable*注解中都有一个@Import注解，是用来导入配置类的。具体说明可以看<a href="https://www.jianshu.com/p/3da069bd865c" target="_blank" rel="noopener">这里</a>。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>​    Spring 通过Spring TestContext Framework对集成测试提供顶级支持，它不依赖特定的测试框架，既可使用Junit、也可使用TestNG。</p><p>​    基于Maven构建的项目结构默认有关于测试的目录：src/test/java(测试代码)、src/test/resources(测试资源)，区别于src/main/java(项目源码)、src/main/resources(项目资源)。</p><p>​    Spring提供了一个SpringJUnit4ClassRunner类，接下来对该类提供的部分功能进行演示。</p><blockquote><p>首先添加Spring测试的依赖包到Maven：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单元测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4)Spring test --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>业务代码，在 src/main/java目录下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fortest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestBean</span><span class="params">(String content)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置类，在 src/main/java目录下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fortest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">devTestBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"from development profile"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"prod"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">prodTestBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"from production profile"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试类，在src/test/java目录下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fortest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ActiveProfiles;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class) <span class="comment">//SpringJUnit4ClassRunner在JUnit环境下提供Spring TestContext Framework的功能。</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;TestConfig.class&#125;) <span class="comment">//加载配置</span></span><br><span class="line"><span class="meta">@ActiveProfiles</span>(<span class="string">"prod"</span>) <span class="comment">//声明活动的profile</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBeanIntegrationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">//使用@Autowired注解注入Bean。</span></span><br><span class="line">    <span class="keyword">private</span> TestBean testBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>   <span class="comment">//测试代码，使用JUnit的Assert来校验结果是否和预期一样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">proBeanShouldInject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String expected = <span class="string">"from production profile"</span>;</span><br><span class="line">        String actual = testBean.getContent();</span><br><span class="line">        Assert.assertEquals(expected, actual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果如下图所示：</p><p><img src="3.7_1.png" alt="Alt text"></p><p>接下来将@ActiveProfiles(“prod”)改为@ActiveProfiles(“dev”)，效果如下所示：</p><p><img src="3.7_2.png" alt="Alt text"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;主要记录Spring容器中的Bean如何实现Aware接口来对事件进行发布管理，Spring容器通过一个基于线程池的任务执行器来进行异步任务的并发，条件注解的使用，组合注解声明，Enable*注解的原理以及如何进行测试。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Springboot" scheme="http://yehengchao.cn/categories/Springboot/"/>
    
    
      <category term="Springboot" scheme="http://yehengchao.cn/tags/Springboot/"/>
    
      <category term="SpringAware" scheme="http://yehengchao.cn/tags/SpringAware/"/>
    
      <category term="多线程" scheme="http://yehengchao.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Spring常用配置</title>
    <link href="http://yehengchao.cn/2018/06/26/Spring%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://yehengchao.cn/2018/06/26/Spring常用配置/</id>
    <published>2018-06-26T02:29:40.000Z</published>
    <updated>2018-07-02T01:01:19.287Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录Spring中Bean的配置、EL和资源调用、Bean的声明周期、Profile、事件。</p></blockquote><a id="more"></a><h4 id="Bean的Scope"><a href="#Bean的Scope" class="headerlink" title="Bean的Scope"></a>Bean的Scope</h4><p>​    Scope描述的是Spring容器如何新建Bean实例的，通过 @Scope 注解来实现，有以下几种：</p><ul><li>Singleton：一个Spring容器中只有一个Bean的实例，此为Spring的默认配置，全容器共享一个实例。</li><li>Prototype：每次调用都新建一个Bean的实例。</li><li>Request：Web项目中，给每个http request 新建一个Bean实例。</li><li>Session：Web项目中，给每个http session新建一个Bean实例。</li><li>GlobalSession：这个只在portal应用中有用，给每个global http session新建一个Bean实例。</li></ul><p>singleton 和 prototype 实例：</p><blockquote><p>Singleton的Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span> <span class="comment">//默认为Singleton，相当于Scope("singleton")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSingletonService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Prototype的Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>) <span class="comment">//声明Scope为Prototype</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPrototypeService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"scope"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopeConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ScopeConfig.class);</span><br><span class="line">        DemoSingletonService s1 = context.getBean(DemoSingletonService.class);</span><br><span class="line">        DemoSingletonService s2 = context.getBean(DemoSingletonService.class);</span><br><span class="line"></span><br><span class="line">        DemoPrototypeService p1 = context.getBean(DemoPrototypeService.class);</span><br><span class="line">        DemoPrototypeService p2 = context.getBean(DemoPrototypeService.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"s1与s2是否相等： "</span> + s1.equals(s2));</span><br><span class="line">        System.out.println(<span class="string">"p1与p2是否相等： "</span> + p1.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果为：</span><br><span class="line">s1与s2是否相等： <span class="keyword">true</span></span><br><span class="line">p1与p2是否相等： <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h4 id="Spring-EL和资源调用"><a href="#Spring-EL和资源调用" class="headerlink" title="Spring EL和资源调用"></a>Spring EL和资源调用</h4><p>​    Spring EL-Spring 表达式语言支持在xml和注解中使用，类似于JSP的EL表达式，其中涉及调用各种资源包括普通文件、网址、配置文件、系统环境变量等。Spring主要在注解@Value 的参数中使用表达式。本文涉及到的有以下几种情况：</p><ul><li>注入普通字符</li><li>注入操作系统属性</li><li>注入表达式运算结果</li><li>注入其他Bean 的属性</li><li>注入文件内容</li><li>注入网址内容</li><li>注入属性文件</li></ul><p>示例：</p><blockquote><p>增加commons-io 可简化文件相关操作：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在包内添加test.txt文件，内容随意~</p><blockquote><p>在包内添加test.properties资源文件，内容如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">book.author=yyyy</span><br><span class="line">book.name=xxxx</span><br></pre></td></tr></table></figure><blockquote><p>编辑被注入的Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> el;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"其他类的属性"</span>)    <span class="comment">//表示注入普通的字符串</span></span><br><span class="line">    <span class="keyword">private</span> String another;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAnother</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> another;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnother</span><span class="params">(String another)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.another = another;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编写演示配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> el;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.PropertySourcesPlaceholderConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"el"</span>)</span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:el/test.properties"</span>) <span class="comment">//注入配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"I Love You!"</span>)   <span class="comment">//注入普通字符串</span></span><br><span class="line">    <span class="keyword">private</span> String normal;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;systemProperties.os.name&#125;"</span>)    <span class="comment">//注入操作系统属性</span></span><br><span class="line">    <span class="keyword">private</span> String osName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123; T(java.lang.Math).random() * 100.0 &#125;"</span>)   <span class="comment">//注入表达式结果</span></span><br><span class="line">    <span class="keyword">private</span> String randomNumber;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;demoService.another&#125;"</span>) <span class="comment">//注入其他Bean属性</span></span><br><span class="line">    <span class="keyword">private</span> String fromAnother;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"classpath:el/test.txt"</span>) <span class="comment">//注入文件资源</span></span><br><span class="line">    <span class="keyword">private</span> Resource testFile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"http://www.baidu.com"</span>)  <span class="comment">//注入网址资源</span></span><br><span class="line">    <span class="keyword">private</span> Resource testUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;book.name&#125;"</span>)  <span class="comment">//注入配置文件</span></span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertySourcesPlaceholderConfigurer <span class="title">propertyConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outputResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(normal);</span><br><span class="line">            System.out.println(osName);</span><br><span class="line">            System.out.println(randomNumber);</span><br><span class="line">            System.out.println(fromAnother);</span><br><span class="line"></span><br><span class="line">            System.out.println(IOUtils.toString(testFile.getInputStream()));</span><br><span class="line">            System.out.println(IOUtils.toString(testUrl.getInputStream()));</span><br><span class="line">            System.out.println(bookName);</span><br><span class="line">            System.out.println(environment.getProperty(<span class="string">"book.author"</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编写运行类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> el;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ElConfig.class);</span><br><span class="line"></span><br><span class="line">        ElConfig resourceService = context.getBean(ElConfig.class);</span><br><span class="line"></span><br><span class="line">        resourceService.outputResource();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出信息：</span><br><span class="line">I Love You!</span><br><span class="line">Windows <span class="number">10</span></span><br><span class="line"><span class="number">9.515003283753941</span></span><br><span class="line">其他类的属性</span><br><span class="line">文本测试</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">六月 <span class="number">26</span>, <span class="number">2018</span> <span class="number">5</span>:<span class="number">04</span>:<span class="number">41</span> 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose</span><br><span class="line">信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@<span class="number">531</span>d72ca: startup date [Tue Jun <span class="number">26</span> <span class="number">17</span>:<span class="number">04</span>:<span class="number">41</span> CST <span class="number">2018</span>]; root of context hierarchy</span><br><span class="line">&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-<span class="number">8</span>&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http:<span class="comment">//s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class="bg s_ipt_wr"&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus&gt;&lt;/span&gt;&lt;span class="bg s_btn_wr"&gt;&lt;input type=submit id=su value=百度一下 class="bg s_btn"&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;新闻&lt;/a&gt; &lt;a href=http://www.hao123.com name=tj_trhao123 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;地图&lt;/a&gt; &lt;a href=http://v.baidu.com name=tj_trvideo class=mnav&gt;视频&lt;/a&gt; &lt;a href=http://tieba.baidu.com name=tj_trtieba class=mnav&gt;贴吧&lt;/a&gt; &lt;noscript&gt; &lt;a href=http://www.baidu.com/bdorz/login.gif?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb&gt;登录&lt;/a&gt; &lt;/noscript&gt; &lt;script&gt;document.write('&lt;a href="http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u='+ encodeURIComponent(window.location.href+ (window.location.search === "" ? "?" : "&amp;")+ "bdorz_come=1")+ '" name="tj_login" class="lb"&gt;登录&lt;/a&gt;');&lt;/script&gt; &lt;a href=//www.baidu.com/more/ name=tj_briicon class=bri style="display: block;"&gt;更多产品&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=ftCon&gt; &lt;div id=ftConw&gt; &lt;p id=lh&gt; &lt;a href=http://home.baidu.com&gt;关于百度&lt;/a&gt; &lt;a href=http://ir.baidu.com&gt;About Baidu&lt;/a&gt; &lt;/p&gt; &lt;p id=cp&gt;&amp;copy;2017&amp;nbsp;Baidu&amp;nbsp;&lt;a href=http://www.baidu.com/duty/&gt;使用百度前必读&lt;/a&gt;&amp;nbsp; &lt;a href=http://jianyi.baidu.com/ class=cp-feedback&gt;意见反馈&lt;/a&gt;&amp;nbsp;京ICP证030173号&amp;nbsp; &lt;img src=//www.baidu.com/img/gs.gif&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;</span></span><br><span class="line"></span><br><span class="line">xxxx</span><br><span class="line">yyyy</span><br></pre></td></tr></table></figure><h4 id="Bean-的初始化和销毁"><a href="#Bean-的初始化和销毁" class="headerlink" title="Bean 的初始化和销毁"></a>Bean 的初始化和销毁</h4><p>​    在实际开发中，经常会遇到在Bean使用之前和使用之后做些必要的操作，Spring对Bean的生命周期的操作提供了支持，在Java配置和注解配置下提供两种方式：</p><ul><li>Java配置方式：使用@Bean 的initMethod 和destroyMethod (相当于xml配置的init-method 和 destroy-method)。</li><li>注解方式：利用JSR-250的@PostConstruct 和@PreDestroy。</li></ul><blockquote><p>首先在maven配置文件中增加JSR250的支持</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.annotion<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsr250-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用@Bean 形式的Bean如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> prepost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanWayService</span> </span>&#123;   <span class="comment">//此类不预先声明为Bean，在配置类中手动创建成为Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@Bean-init-method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanWayService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"初始化构造函数-BeanWayService"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@Bean-destroy-method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用JSR250形式的Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> prepost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSR250WayService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span>  <span class="comment">//在构造函数执行完之后执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jsr250-init-method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JSR250WayService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"初始化构造函数-JSR250WayService"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span> <span class="comment">//在Bean销毁之前执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jsr250-destroy-method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> prepost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"prepost"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrePostConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>, destroyMethod = <span class="string">"destroy"</span>)   <span class="comment">//initMethod和destroyMethod指定BeanWayService类的init和destroy方法在构造函数之后，Bean销毁之前执行</span></span><br><span class="line">    <span class="function">BeanWayService <span class="title">beanWayService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanWayService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//这里因为在JSR250WayService类中的方法已经指定了，所以不用上述那样</span></span><br><span class="line">    <span class="function">JSR250WayService <span class="title">jsr250WayService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JSR250WayService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> prepost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(PrePostConfig.class);</span><br><span class="line"></span><br><span class="line">        BeanWayService beanWayService = context.getBean(BeanWayService.class);</span><br><span class="line">        JSR250WayService jsr250WayService = context.getBean(JSR250WayService.class);</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果如下：</span><br><span class="line">初始化构造函数-BeanWayService</span><br><span class="line"><span class="meta">@Bean</span>-init-method</span><br><span class="line">初始化构造函数-JSR250WayService</span><br><span class="line">jsr250-init-method</span><br><span class="line">jsr250-destroy-method</span><br><span class="line"><span class="meta">@Bean</span>-destroy-method</span><br></pre></td></tr></table></figure><h4 id="Profile使用"><a href="#Profile使用" class="headerlink" title="Profile使用"></a>Profile使用</h4><p>Profile为在不同的环境下使用不同的配置提供了支持：</p><ul><li>通过设定Environment 的ActiveProfiles 来设定当前context 需要使用的环境配置。在开发中使用@Profile 注解类或者方法，达到在不同情况下选择实例化不同的Bean。</li><li>通过设定jvm的spring.profile.active参数来设置配置环境。</li><li>Web项目设置在Servlet 的context parameter中。（也就是上下文参数）</li></ul><blockquote><p>下面进行简单的代码演示，示例Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> profile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoBean</span><span class="params">(String content)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Profile 配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> profile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"dev"</span>) <span class="comment">//Profile为dev时实例化devDemoBean。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoBean <span class="title">devDemoBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoBean(<span class="string">"from development profile"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"prod"</span>) <span class="comment">//Profile为prod时实例化为proDemoBean。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoBean <span class="title">prodDemoBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoBean(<span class="string">"from production profile"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Main类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> profile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">        context.getEnvironment().setActiveProfiles(<span class="string">"prod"</span>); <span class="comment">//将活动的Profile设置为prod。</span></span><br><span class="line">        context.register(ProfileConfig.class);  <span class="comment">//后置注册Bean配置类，不然会报Bean未定义的错误。</span></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        DemoBean demoBean = context.getBean(DemoBean.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(demoBean.getContent());</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果为：</span><br><span class="line">六月 <span class="number">29</span>, <span class="number">2018</span> <span class="number">9</span>:<span class="number">17</span>:<span class="number">42</span> 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh</span><br><span class="line">信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@<span class="number">67424e82</span>: startup date [Fri Jun <span class="number">29</span> <span class="number">21</span>:<span class="number">17</span>:<span class="number">42</span> CST <span class="number">2018</span>]; root of context hierarchy</span><br><span class="line">from production profile</span><br><span class="line">六月 <span class="number">29</span>, <span class="number">2018</span> <span class="number">9</span>:<span class="number">17</span>:<span class="number">42</span> 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose</span><br><span class="line">信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@<span class="number">67424e82</span>: startup date [Fri Jun <span class="number">29</span> <span class="number">21</span>:<span class="number">17</span>:<span class="number">42</span> CST <span class="number">2018</span>]; root of context hierarchy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果将 <span class="string">"pro"</span> 改为 <span class="string">"dev"</span> ：</span><br><span class="line">六月 <span class="number">29</span>, <span class="number">2018</span> <span class="number">9</span>:<span class="number">18</span>:<span class="number">37</span> 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh</span><br><span class="line">信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@<span class="number">67424e82</span>: startup date [Fri Jun <span class="number">29</span> <span class="number">21</span>:<span class="number">18</span>:<span class="number">37</span> CST <span class="number">2018</span>]; root of context hierarchy</span><br><span class="line">from development profile</span><br><span class="line">六月 <span class="number">29</span>, <span class="number">2018</span> <span class="number">9</span>:<span class="number">18</span>:<span class="number">37</span> 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose</span><br><span class="line">信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@<span class="number">67424e82</span>: startup date [Fri Jun <span class="number">29</span> <span class="number">21</span>:<span class="number">18</span>:<span class="number">37</span> CST <span class="number">2018</span>]; root of context hierarchy</span><br></pre></td></tr></table></figure><h4 id="事件-Application"><a href="#事件-Application" class="headerlink" title="事件(Application)"></a>事件(Application)</h4><p>​    Spring 的事件(Application Event) 为Bean 和 Bean 之间的消息通信提供了支持。当一个Bean 处理完一个任务之后，希望另一个Bean知道并能做出相应的处理，这时我们就能让另一个Bean 监听当前Bean 所发送的事件。(讲到这里，相当了Servlet中也有类似的事件监听，或许是差不多的东西)</p><p>Spring 实现事件监听流程：</p><ol><li>自定义事件，继承ApplicationEvent。</li><li>定义事件监听器，实现ApplicationListener。</li><li>使用容器发布事件。</li></ol><blockquote><p>首先，自定义事件，为了让消息更加可视化，传入参数msg：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoEvent</span><span class="params">(Object source, String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第二步，实现事件监听器：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">DemoEvent</span>&gt; </span>&#123;   <span class="comment">//实现ApplicationListener 接口，并且指定监听的事件类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(DemoEvent event)</span> </span>&#123;   <span class="comment">//使用onApplicationEvent 方法对消息进行接受处理。</span></span><br><span class="line">        String msg = event.getMsg();</span><br><span class="line">        System.out.println(<span class="string">"我(bean-DemoListener)接收到了bean-demoPublisher发布的消息："</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>事件发布类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPublisher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext context; <span class="comment">//注入ApplicationContext用来发布事件。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> DemoEvent(<span class="keyword">this</span>, msg)); <span class="comment">//使用publishEvent方法来发布事件。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"event"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行函数：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(EventConfig.class);</span><br><span class="line"></span><br><span class="line">        DemoPublisher demoPublisher = context.getBean(DemoPublisher.class);</span><br><span class="line"></span><br><span class="line">        demoPublisher.publish(<span class="string">"hello application event"</span>);</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下所示：</span><br><span class="line">六月 <span class="number">29</span>, <span class="number">2018</span> <span class="number">9</span>:<span class="number">56</span>:<span class="number">20</span> 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh</span><br><span class="line">信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@<span class="number">67424e82</span>: startup date [Fri Jun <span class="number">29</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">20</span> CST <span class="number">2018</span>]; root of context hierarchy</span><br><span class="line">我(bean-DemoListener)接收到了bean-demoPublisher发布的消息：hello application event</span><br><span class="line">六月 <span class="number">29</span>, <span class="number">2018</span> <span class="number">9</span>:<span class="number">56</span>:<span class="number">20</span> 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose</span><br><span class="line">信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@<span class="number">67424e82</span>: startup date [Fri Jun <span class="number">29</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">20</span> CST <span class="number">2018</span>]; root of context hierarchy</span><br></pre></td></tr></table></figure><p>可以看出，DemoListener成功监听到了DemoPublisher发布的事件。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录Spring中Bean的配置、EL和资源调用、Bean的声明周期、Profile、事件。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Springboot" scheme="http://yehengchao.cn/categories/Springboot/"/>
    
    
      <category term="Bean" scheme="http://yehengchao.cn/tags/Bean/"/>
    
      <category term="Spring" scheme="http://yehengchao.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring基础</title>
    <link href="http://yehengchao.cn/2018/06/25/Spring%E5%9F%BA%E7%A1%80/"/>
    <id>http://yehengchao.cn/2018/06/25/Spring基础/</id>
    <published>2018-06-25T05:40:28.000Z</published>
    <updated>2018-07-02T01:08:06.343Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Spring基础，主要涉及maven的介绍使用，控制反转和依赖注入以及关于(AOP)面向切面编程。</p></blockquote><a id="more"></a><h4 id="Spring配置方式"><a href="#Spring配置方式" class="headerlink" title="Spring配置方式"></a>Spring配置方式</h4><ol><li>xml配置</li><li>注解配置</li><li>Java配置</li></ol><h4 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h4><p>​    maven是一个软件项目管理工具。基于项目管理对象模型的概念，可用来管理项目的依赖、编译、文档等信息。</p><p>​    在maven中管理依赖时只需要在配置文件pom.xml中按下面的形式添加就好了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    添加完成以后maven就会通过互联网在maven中心库下载相关的依赖包到.m2目录下，也是你的本地maven库，如果中心库没有你需要的jar包，需要自己使用maven命令导入到本地maven库。</p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>​    在Spring的概念下，控制翻转和依赖注入是等同的概念，控制翻转是通过依赖注入实现的。依赖注入指容器负责创建对象和维护对象间的依赖关系，而不是通过对象本身负责自己的创建和解决自己的依赖。</p><p>​    依赖注入的目的是为了解耦，使用“组合”的概念降低类之间的耦合度。Spring IoC容器负责创建Bean，并且通过容器将功能类Bean注入到需要的Bean中。Spring 提供使用xml、注解、Java配置、groovy配置实现Bean的创建和注入。</p><p>声明Bean的注解有：</p><ul><li>@Component 组件，没有明确的角色</li><li>@Service 在业务逻辑层(service层)使用</li><li>@Respository 在数据访问层(dao层）使用</li><li>@Controller 在展现层(MVC - SpringMVC)使用</li></ul><p>注入Bean的注解：</p><ul><li>@Autowired：Spring提供的注解</li><li>@Inject：JSR-330提供的注解</li><li>@Resource：JSR-250提供的注解</li></ul><p>注入Bean的注解可以用在set方法上或者属性上。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>​    Java配置是现在推荐的方式，主要通过@Configuration 和@Bean 来实现</p><ul><li>@Configuration 声明当前类是一个配置类，相当于一个Spring配置的xml文件。</li><li>@Bean 注解在方法上，声明当前方法的返回值为一个Bean。</li></ul><p>遵循的基本原则是：全局配置使用Java配置(如数据库相关配置、maven相关配置)，业务Bean的配置使用注解配置。</p><h4 id="AOP：面向切面编程"><a href="#AOP：面向切面编程" class="headerlink" title="AOP：面向切面编程"></a>AOP：面向切面编程</h4><p>​    Spring的AOP 存在的目的就是为了解耦。可以让一组类共享相同的行为。Spring 支持AspectJ 的注解式切面编程。</p><ul><li>使用@Aspect 声明是一个切面。</li><li>使用@After 、@Before 、@Around 定义建言(advice)，可直接将拦截规则(切点)作为参数。</li><li>其中@After 、@Before 、@Around 参数的拦截规则作为切点(PointCut)，为了使切点复用，可使用@PointCut专门定义拦截规则，然后在@After 、@Before 、@Around 的参数中调用。</li><li>其中符合条件的每一个被拦截处为连接点(JoinPoint)。</li></ul><p>下面给出一个AOP的 demo：</p><p>​    首先在pom.xml中添加相关的依赖，相应信息可以在maven仓库中查询。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- aspectj支持 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjrt --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>编写拦截规则的注解：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)<span class="comment">//说明该注解的作用目标是方法</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="comment">//运行时有效</span></span><br><span class="line"><span class="meta">@Documented</span><span class="comment">//定义为Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Action &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编写使用注解的被拦截器：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="meta">@Service</span><span class="comment">//定义为Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoAnnotationService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Action</span>(name=<span class="string">"注解式拦截的add操作"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编写使用方法规则被拦截器：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMethodService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编写切面：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//该注解声明一个切面</span></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//定义为Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(aop.Action)"</span>)<span class="comment">//声明一个切点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotationPointCut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"annotationPointCut()"</span>)<span class="comment">//声明一个建言，并使用@Pointcut定义的切点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        Action action = method.getAnnotation(Action.class);</span><br><span class="line">        System.out.println(<span class="string">"注解式拦截 "</span> + action.name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* aop.DemoMethodService.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        System.out.println(<span class="string">"方法式拦截 "</span> + method.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"aop"</span>)</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span><span class="comment">//开启Spring对AspectJ的支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AopConfig.class);</span><br><span class="line">        DemoAnnotationService demoAnnotationService = context.getBean(DemoAnnotationService.class);</span><br><span class="line">        DemoMethodService demoMethodService = context.getBean(DemoMethodService.class);</span><br><span class="line"></span><br><span class="line">        demoAnnotationService.add();</span><br><span class="line">        demoMethodService.add();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line">注解式拦截 注解式拦截的add操作</span><br><span class="line">方法式拦截 add</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Spring基础，主要涉及maven的介绍使用，控制反转和依赖注入以及关于(AOP)面向切面编程。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Springboot" scheme="http://yehengchao.cn/categories/Springboot/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows内存</title>
    <link href="http://yehengchao.cn/2018/06/20/Windows%E5%86%85%E5%AD%98%E7%90%86%E8%A7%A3/"/>
    <id>http://yehengchao.cn/2018/06/20/Windows内存理解/</id>
    <published>2018-06-20T01:53:38.000Z</published>
    <updated>2018-07-02T01:08:17.923Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Windows中内存是如何分配的。</p></blockquote><a id="more"></a><p><strong>分配的是虚拟地址空间，不是虚拟空间；</strong><br>为什么分配这么大？这是windows给出的承诺，向应用程序承诺，在物理内存足够大的情况下，我能够提供给你这么大的地址空间（注意这里的用词是地址空间，意思是有允许其内存寻址最多到8T这个数字）<br>当然，虚拟内存空间地址是一回事，实际空间是另一回事。<br>之前说了，虚拟空间地址只是承诺<strong>能够寻址</strong>，并非真的分配了空间；当应用程序真的申请了地址空间内能访问的内存时，windows才会开始把被访问的<strong>内存页</strong>映射到物理内存中。（没错，人家就是打了个空头支票，实际情况是你用一页我分配一页）<br>所以总结如下：<br><strong>所谓的8T（0x200000000）有什么用：</strong>允许应用程序访问0x0-0x200000000的任意地址，当然访问0x200000001就会报错，因为超出地址空间了（所以虚拟地址空间越大越好，这样编译器布局内存自由度更大）<br><strong>64位系统为例，物理内存16G，应用程序用了10G，会发生什么：</strong>也就是说我允许应用程序用8T内存，但他只用了10G，那没问题，因为可以映射到16G物理内存中；<br><strong>64位系统为例，物理内存16G，应用程序用了17G，会发生什么：</strong>唔，物理内存有点不够用，但是可以把一些内存页存到硬盘上（虚拟内存），所以问题也不大，但是进程切换可能引起内存页在硬盘上的读写，所以电脑会有点卡<br><strong>64位系统为例，物理内存16G，应用程序申请了8T，会发生什么：</strong>没错，应用程序的确被允许使用8T内存，但是此时系统提供不了这么多，空头支票暴露，你的系统奔溃了</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Windows中内存是如何分配的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="内存" scheme="http://yehengchao.cn/categories/%E5%86%85%E5%AD%98/"/>
    
    
      <category term="Windows" scheme="http://yehengchao.cn/tags/Windows/"/>
    
      <category term="内存管理" scheme="http://yehengchao.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类加载机制</title>
    <link href="http://yehengchao.cn/2018/06/20/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yehengchao.cn/2018/06/20/虚拟机类加载机制/</id>
    <published>2018-06-20T01:53:25.000Z</published>
    <updated>2018-07-02T01:08:49.603Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录下Java中类加载的时机，类在加载过程经历的阶段。&lt;未完待续&gt;</p></blockquote><a id="more"></a><h4 id="7-2-类加载的时机"><a href="#7-2-类加载的时机" class="headerlink" title="7.2 类加载的时机"></a>7.2 类加载的时机</h4><pre><code>类从被加载到虚拟机内存开始，到卸载出内存，其整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析部分统称为连接。</code></pre><p>​    加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，什么时候开始加载并没有进行强制约束，可以交给虚拟机的具体实现来自由把握。</p><p>​    对于初始阶段，虚拟机规范严格规定了有且只有5种情况必须对类立即进行初始化：</p><ol><li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类时，发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>虚拟机启动时，用户需指定一个要执行的主类（包含main()方法的那个类），虚拟机会初始化这个类。</li><li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ol><p>​       接口加载过程与类加载过程与类加载过程稍微有一些不同，接口也有初始化的过程，接口中不能使用static{}语句块，但编译器仍然会为接口生成“<clinit>()”类构造器，用于初始化接口中所定义的成员变量。接口与类真正有所求区别的是前面讲述的5种“有且只有”需要初始化场景中的第3种：当初始化一个类时，发现其父类还没有进行过初始化，则需要先触发其父类的初始化。但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</clinit></p><h4 id="7-3-类加载的过程"><a href="#7-3-类加载的过程" class="headerlink" title="7.3 类加载的过程"></a>7.3 类加载的过程</h4><h5 id="7-3-1-加载"><a href="#7-3-1-加载" class="headerlink" title="7.3.1 加载"></a>7.3.1 加载</h5><p>加载阶段虚拟机需要完成3件事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 通过一个类的全限定名来获取定义此类的二进制字节流。</span><br><span class="line">2. 将字节流所代表的静态存储结构转化为方法区的运行时数据结构。</span><br><span class="line">3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</span><br></pre></td></tr></table></figure><p>​       这三点要求并不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的，例如：通过全限定名来获取此类的二进制流，没有规定要从Class文件中获取，所以就有多种花样：</p><p>​    从ZIP包中读取，最终成为日后JAR、EAR、WAR格式的基础。</p><p>​    从网络中获取，这种场景最典型的应用就是Applet。</p><p>​    运行时计算生成，这种场景使用最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是使用了ProxyGenerator.generateProxyClass来为特定接口生成形式为“*＄Proxy”的代理类的二进制字节流。</p><p>​    由其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。</p><p>​    从数据库中读取，这种场景相对少见些。例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库来完成程序代码在集群中的分发。</p><p>​    对于数组类而言，情况有所不同，数组类本身不通过类加载器创建，由Java虚拟机直接创建。但数组类与类加载器仍由紧密的联系，因为数组类的元素类型最终是要靠类加载器去创建，一个数组（C）创建过程如下：</p><p>​    数组组件类型是引用型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识。</p><p>​    如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与引导类加载器关联。</p><p>​    数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。</p><p>​    加载阶段完成后，虚拟机外部的二进制字节流按照虚拟机所需格式存储在方法区中，数据存储格式由虚拟机自行定义。然后在内存实例化一个java.lang.Class类的对象（没有明确在Java堆中，对于HotSpot而言，Class虽然是对象，但是存放在方法区中），这个对象作为程序访问方法区中的这些类型数据的外部接口。加载阶段和连接阶段的部分内容是交叉进行的。</p><h5 id="7-3-2-验证"><a href="#7-3-2-验证" class="headerlink" title="7.3.2 验证"></a>7.3.2 验证</h5><p>​    JVM通过检查输入的字节流是否符合Class文件格式的约束，验证阶段大致上会完成4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><ol><li><p>文件格式验证</p><p>​    验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理：</p><p>是否以魔数0xCAFEBABE开头。</p><p>主、次版本号是否在当前虚拟机处理范围之内。</p><p>常量池的常量中是否有不被支持的常量类型（检查tag标志）</p><p>指向常量的索引值是否有指向不存在的常量或不符合类型常量</p><p>……………………</p></li></ol><p>​       第一阶段的验证远不止如此，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。该验证基于二进制字节流进行，通过该验证后字节流才进入内存的方法区中进行存储，所以后面的验证都是基于方法区的存储结构进行的，不会直接操作字节流。</p><ol><li><p>元数据验证</p><p>​    第二阶段是对字节码描述的信息进行语义分析以确保描述的信息符合Java语言规范的要求：</p><p>这个类是否有父类（除了Object外所有类都要有父类）</p><p>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</p><p>如果不是抽象类是否实现了父类或接口中要求实现的所有方法</p><p>类中字段、方法是否与父类产生矛盾</p><p>………………………………..</p></li></ol><p>​       第二阶段目的主要是对类的元数据信息进行语义分析验证，保证不存在不符合Java语言规范的元数据信息。</p><ol><li><p>字节码验证</p><p>​    第三阶段是最复杂的阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。该阶段对类的方法体进行校验分析，保证被校验类方法在运行时不会做出危害虚拟机安全的事件：</p><p>保证任意时刻操作数栈数据类型与指令代码序列能配合工作。</p><p>保证跳转指令不会跳转到方法体以外的字节码指令上。</p><p>保证方法体中类型转换是有效的 子类可赋值给父类 反之不行。</p><p>………………………………………..</p></li></ol><p>​       若一个类方法的字节码未通过字节码验证，肯定是有问题的；但如果一个方法通过字节码验证，也不能说明其一定是安全的。这里涉及著名的“Halting Problem”（停机问题）：通俗讲就是通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。</p><p>​    JDK1.6之后Javac编译器和JVM进行了优化，给方法体Code属性的属性表里增加了一项“StackMapTable“属性，描述了方法体所有基本块（Basic Block，按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，在字节码验证期间就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。</p><ol><li><p>符号引用验证</p><p>​    最后阶段校验发生在虚拟机将符号引用转化为直接引用，这个转化将在连接的第三阶段——解析阶段中发生。可看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验：</p><p>符号引用中通过字符串描述的全限定名是否能找到对应的类。</p><p>指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</p><p>符号引用中的类、字段、方法访问性是否可以被当前类访问。</p><p>…………………………………………..</p></li></ol><p>符号验证目的是确保解析动作正常执行。</p><h5 id="7-3-3-准备"><a href="#7-3-3-准备" class="headerlink" title="7.3.3 准备"></a>7.3.3 准备</h5><p>​    该阶段是正式为类变量分配内存并设置类变量初始值的阶段，类变量所使用的内存都将在方法区中进行分配。该阶段有两个概念：首先，进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象初始化的时候随着对象一起分配在Java堆中。其次这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量定义为：public static int value = 123；那变量在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法中，所以把value赋值为123的动作将在初始化阶段才会执行。</clinit></p><p><img src="C:\Users\yehen\AppData\Local\Temp\1526473361124.png" alt="1526473361124"></p><p>​    上述提到的只是“通俗情况”下初始值是零值，还有一些“特殊情况”下：如果类字段的字段属性表中存在ConstantValue属性所指定的值，假设上述变量定义为：public static final int value = 123；编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据这个设置将value赋值为123.</p><p><img src="C:\Users\yehen\AppData\Local\Temp\1526474197627.png" alt="1526474197627"></p><p>可以看到字节码中多了ConstantValue属性并且有一个初始值为123</p><h5 id="7-3-4-解析"><a href="#7-3-4-解析" class="headerlink" title="7.3.4 解析"></a>7.3.4 解析</h5>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录下Java中类加载的时机，类在加载过程经历的阶段。&amp;lt;未完待续&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://yehengchao.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://yehengchao.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>类文件结构</title>
    <link href="http://yehengchao.cn/2018/06/20/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://yehengchao.cn/2018/06/20/类文件结构/</id>
    <published>2018-06-20T01:53:13.000Z</published>
    <updated>2018-07-02T01:08:41.683Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>分析一波Class类文件的结构，此处所使用的二进制文件查看用的classpy。</p></blockquote><a id="more"></a><h4 id="6-3-Class类文件的结构"><a href="#6-3-Class类文件的结构" class="headerlink" title="6.3 Class类文件的结构"></a>6.3 Class类文件的结构</h4><h5 id="6-3-1-魔数与Class文件的版本"><a href="#6-3-1-魔数与Class文件的版本" class="headerlink" title="6.3.1 魔数与Class文件的版本"></a>6.3.1 魔数与Class文件的版本</h5><p>​    Class文件是一组以8位（1个字节）为基础单位的二进制流，中间没有分隔符。每个Class文件的头4个字节成为魔数，它唯一作用就是确定这个文件是否为一个能被虚拟机接受的Class文件（其实好多文件类型都是使用魔数来识别的）。使用魔数而不是扩展名来进行识别主要是考虑安全性，因为文件扩展名是可以随意改动的。<img src="file:///E:/study/jvm/1524634239368.png?lastModify=1524634247" alt="img"></p><p>​    紧接着魔数的四个字节存储的是Class文件的版本号（如图所示）：第5个和第6个字节是次版本号（Minor Version），第7个和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的（图中0X0034转化为十进制为52，说明这个文件可以被JDK1.8或以上的本地虚拟机执行的Class文件），JDK1.1之后的每个JDK大版本发布主版本号向上加1，高版本JDK向下兼容以前版本的Class文件，但不能运行以后版本的class文件，即使文件格式并未发生任何变化。</p><h5 id="6-3-2-常量池"><a href="#6-3-2-常量池" class="headerlink" title="6.3.2 常量池"></a>6.3.2 常量池</h5><p>​    理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时还是在Class文件中第一次出现的表类型数据项目。</p><p>​    常量池中主要存放两大类常量：字面量和符号引用。</p><p>​    字面量：比较接近Java语言层面的常量概念，如文本串、申明为final的常量值等。</p><p>​    符号引用：编译原理层面，包含三类，即类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。Java在编译的时候不会像C/C++那样有一个“连接”的过程，而是在虚拟机加载Class文件的时候进行动态连接。Class文件不保存方法字段的最终内存信息，所以这些方法、字段的符号引用不经过运行期转换的话无法得到真正的内存入口地址，无法被虚拟机使用。当虚拟机运行时，需从常量池获得对应的符号引用，再在类创建或运行时解析、翻译到具体的内存地址之中。</p><p>​    常量池中每一项常量都是一个表，表的开始第一位是一个u1类型的标志位（tag），代表当前这个常量属于哪种常量类型。之所以说常量池是最繁琐的数据，是因为常量类型各自均有自己的结构。</p><p>​    由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型的常量来描述名称，所以该类型的最大长度就是Java中方法、字段名的最大长度。这里u2类型能表达的最大值是65535。所以Java程序中如果定义了超过64KB英文字符的变量和方法名，将无法编译。javap -verbose可以用于输出Class文件字节码内容。</p><h5 id="6-3-3-访问标志"><a href="#6-3-3-访问标志" class="headerlink" title="6.3.3 访问标志"></a>6.3.3 访问标志</h5><p>​    常量池结束之后，紧跟着两个字节代表访问标志（access_flags），用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类则是否被声明为final等。一共有16个标记位可以使用。</p><h5 id="6-3-4-类索引、父类索引与接口索引集合"><a href="#6-3-4-类索引、父类索引与接口索引集合" class="headerlink" title="6.3.4 类索引、父类索引与接口索引集合"></a>6.3.4 类索引、父类索引与接口索引集合</h5><p>​    类索引（this_class）和父类索引（super_class）都是u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系。Java不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，即父类索引都不为0。接口索引集合描述这个类实现了哪些接口，这些被实现的接口按Implement语句（如果类本身是一个接口，则是extends语句）后的顺序从左到右排列在接口索引集合中。</p><p>​    类索引和父类索引用两个u2类型索引值表示，各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过其中的索引值找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。</p><p>​    对于接口索引集合，入口第一项——u2类型的数据为接口计数器（interfaces_count），表示索引容量。如果该类没有实现任何接口，则计数器为0，后面索引表不占任何字节。如图所示。</p><h5 id="6-3-5-字段表集合"><a href="#6-3-5-字段表集合" class="headerlink" title="6.3.5 字段表集合"></a>6.3.5 字段表集合</h5><p>​    用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。可以包括的信息有：字段的作用域（public、private、protected）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。上述信息修饰符都是布尔值，要么有某个修饰符，要么没有。而字段叫什么、字段被定义为什么数据类型，这些都是无法固定的只能引用常量池中的常量来描述。</p><p>​    表中的两项索引值：name_index和descriptor_index，它们都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p><p>​    以书中的代码6-1为例，“org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅把类全名中的“.”替换成了“/”而已，为了使多个全限定名之间不产生混淆，在使用时最后一般会加入一个“；”,表示全限定名结束。简单名称指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别是“inc”和“m”。</p><p>​    相对于全限定名和简单名称来说，方法和字段的描述符复杂一些，描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</p><h5 id="6-3-6-方法表集合"><a href="#6-3-6-方法表集合" class="headerlink" title="6.3.6 方法表集合"></a>6.3.6 方法表集合</h5><p>​    Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。</p><p>​    方法的定义可以通过标志、名称索引、描述符索引表达清楚，方法里的java代码经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面。</p><p>​    与字段表中集合相对应，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。同样有可能出现由编译器自动添加的方法，最典型的就是类构造器”<clinit>“方法和实例构造器”<init>“方法。</init></clinit></p><p>​    在Java中，重载（Overload）一个方法除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此Java中无法仅仅依靠返回值的不同来对一个已有方法进行重载的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;分析一波Class类文件的结构，此处所使用的二进制文件查看用的classpy。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://yehengchao.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://yehengchao.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>调优案例分析与实战</title>
    <link href="http://yehengchao.cn/2018/06/20/%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <id>http://yehengchao.cn/2018/06/20/调优案例分析与实战/</id>
    <published>2018-06-20T01:53:00.000Z</published>
    <updated>2018-07-02T01:08:25.847Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过案例来分析Java部署中相关的优化措施。</p></blockquote><a id="more"></a><h4 id="5-2案例分析"><a href="#5-2案例分析" class="headerlink" title="5.2案例分析"></a>5.2案例分析</h4><h5 id="5-2-1-高性能硬件上的程序部署策略"><a href="#5-2-1-高性能硬件上的程序部署策略" class="headerlink" title="5.2.1 高性能硬件上的程序部署策略"></a>5.2.1 高性能硬件上的程序部署策略</h5><p>目前高性能硬件上部署程序主要的两种方式：</p><ol><li><p>通过64位JDK来使用大内存：</p><p>​    对于用户交互性强、对停顿时间敏感的系统给虚拟机分配超大堆的前提是有把握把应用程序的Full GC频率控制得足够低，譬如十几个小时甚至一天才出现一次Full GC。而控制Full GC的频率关键看应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。同时还需要面临的问题：</p><p>​    内存回收导致的长时间停顿。</p><p>​    现阶段64位JDK的性能测试结果普遍低于32位JDK。</p><p>​    需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照（因为要产生十几GB乃至更大的Dump文件），哪怕产生了快照也无法分析。</p><p>​    相同程序在64位JDK消耗的内存一般比32位JDK大，这是由于指针膨胀和数据类型对齐补白等因素导致的。</p><p>​</p></li><li><p>使用若干个32位虚拟机建立逻辑集群来利用硬件资源：</p><p>​    现阶段大多采用该方法，具体做法是在一台物理机器上启动多个应用服务器进程，每个服务器进程分配不同的端口，然后在前端搭建一个负载均衡器以反向代理的方式来分配访问请求。这种方案可能会遇到的问题：</p><p>​    尽量避免节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话（尤其式并发写操作容易出现问题），很容易导致IO异常。</p><p>​    很难高效地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能一些节点池满了而另外一些节点仍有较多空余。尽管可以使用集中式的JNDI（理解为同一资源池），但有一定复杂性并且可能带来额外的性能开销。</p><p>​    各节点仍然不可避免地受到32位的内存限制，32位windows系统每个进程只能使用2GB的内存，若考虑堆以外的内存开销则堆一般最多只能开到1.5GB。在某些Linux或Unix系统中可以提升至3GB甚至接近4GB的内存，但32位中仍然受最高4GB内存的限制。</p><p>​    大量使用本地缓存的应用在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点上都有一份缓存，这时候可以考虑把本地缓存改为集中式缓存。</p></li></ol><h5 id="5-2-2-集群间同步导致的内存溢出"><a href="#5-2-2-集群间同步导致的内存溢出" class="headerlink" title="5.2.2 集群间同步导致的内存溢出"></a>5.2.2 集群间同步导致的内存溢出</h5><p>​    例：一个基于B/S的MIS系统，硬件为两台2个CPU、8GB内存的HP小型机。服务器为WebLogic9.2，每台机器启动了三个WebLogic实例，构成一个6个节点的亲合式集群（节点之间没有进行Session同步），但有一些需求要实现部分数据在各节点间共享。开始这些数据存放在数据库中，由于读写频繁竞争很激烈，性能影响较大，后来使用JBossCatch构建了一个全局缓存。启用后不久却不定期地出现了多次内存溢出问题。</p><p>​    查看生成的dump 文件发现里面有大量的org.jgroups.protocols.pbcast.NAKACK对象。JBossCatch基于自家的JGroups进行集群间的数据通信，JGroups使用协议栈的方式来实现收发数据包的各种所需特性自由组合。由于信息有传输失败需要重发的可能性，在确认所有注册在GMS(Group Membership Service)的节点都收到正确的信息前，发送信息必须在内存中保留。MIS服务端有一个负责安全校验的全局Filter，每当收到请求均更新一次最后操作时间并将其同步到所有节点，使一个用户一段时间内不能在多台机器上登录。服务器使用过程中往往一个页面产生数次乃至数十次的请求，因此这个过滤器导致集群节点之间网络交互非常频繁。当网络情况不能蛮子传输要求时，重发数据在内存中不断堆积，很快产生了内存溢出。若使用JBossCatch缓存来同步的话可以允许读操作频繁，但不应当有过于频繁的写操作。</p><h5 id="5-2-3-堆外内存导致的溢出错误"><a href="#5-2-3-堆外内存导致的溢出错误" class="headerlink" title="5.2.3 堆外内存导致的溢出错误"></a>5.2.3 堆外内存导致的溢出错误</h5><p>​    例子：学校小型项目，基于B/S的电子考试系统，为了实现客户端能实时地从服务器端接收考试数据系统使用了逆向AJAX技术。测试期间发现服务端不定时抛出内存溢出异常，服务器不一定每次都会抛出异常。管理员尝试过把堆卡到最大，32位系统堆最多到1.6G就基本无法再大了，而且开大了基本没什么效果，异常好像还更加频繁了。想通过参数使其产生dump文件，发现什么文件也没有产生。最后在内存溢出后从系统日志中找到异常堆栈。</p><p>​    服务器使用32位Windows平台的限制是2GB，其中划了1.6GB给Java堆，而Direct Memory内存并不算入1.6GB的堆之内，因此最大也只能在剩余的0.4GB中分出一部分。此应用中导致溢出的原因为：垃圾收集时虚拟机虽然会对Direct Memory进行回收，但是Direct Memory不像新生代、老年代那样发现空间不足了就通知收集器进行垃圾回收，它只能等待老年代满了以后Full GC，然后顺便地帮他清理掉废弃的对象。否则它只能一直等到抛出内存溢出异常时先catch掉，再在catch块中调用System.gc()，要是此使虚拟机还不进行gc，那就不得不抛出内存溢出异常了（虽然有可能堆中还有很多空闲内存）。本案例中使用的CometD 1.1.1框架，正好有大量的<strong>NIO</strong>操作要使用到Direct Memory内存。</p><p>除了Java堆和永久代外，下面区域还会占用较多的内存：</p><p>​    Direct Memory：可通过参数-XX:MaxDirectMemorySize进行大小的调整。</p><p>​    线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError（栈深不足，纵向）和OutOfMemoryError（无法建立新线程，横向）。</p><p>​    Socket缓存区：每个Socket连接都有Receive和Send两个缓存区，分别占37KB和25KB，连接多的话这部分内存也比较可观，如无法分配则可能抛出IOException:Too many open files异常。</p><p>​    JNI代码：使用JNI调用本地库，使用的内存也不在堆中。</p><p>​    虚拟机和GC：虚拟机、GC的代码执行也要消耗一定的内存。</p><h5 id="5-2-4-外部命令导致系统缓慢"><a href="#5-2-4-外部命令导致系统缓慢" class="headerlink" title="5.2.4 外部命令导致系统缓慢"></a>5.2.4 外部命令导致系统缓慢</h5><p>​    例子：一个数字校园应用系统运行在Solaris操作系统上，中间件为GlassFish服务器。系统做大并发压力测试发现请求响应时间较慢，使用mpstat发现CPU使用率高并且系统占用绝大多数的CPU资源。后来使用Dtrace发现最消耗CPU资源的是“fork”系统调用。</p><p>​    原因是：每个用户请求的处理都需要执行一个外部shell脚本来获得系统的信息，执行这个shell脚本是通过Java的Runtime.getRuntime().exec()方法来调用的。这种调用方式在虚拟机中非常消耗资源，频繁调用创建进程开销非常可观，系统消耗会很大，不仅是CPU，内存负荷也很重。</p><h5 id="5-2-5-服务器JVM进程崩溃"><a href="#5-2-5-服务器JVM进程崩溃" class="headerlink" title="5.2.5 服务器JVM进程崩溃"></a>5.2.5 服务器JVM进程崩溃</h5><p>​    例子：一个基于B/S的MIS系统正常运行一段时间后发现在运行期间频繁出现集群节点的虚拟机进程自动关闭现象。从系统日志文件可看出发生过大量的远端断开连接的异常，通过系统管理员了解到系统最近与一个OA门户做了集成，在MIS系统工作流的代办事项变化时要通过Web服务通知OA门户系统，把代办事项的变化同步到OA门户中。通过SoapUI测试了同步待办事项的Web服务，发现调用以后需要3分钟才能返回，并且返回结果都是连接中断。</p><p>​    由于MIS系统用户多、待办事项变化快，为了不被OA系统拖累使用了异步方式调用Web服务，由于两边速度不对等，时间久了就积累了越多Web服务没有调用完成，导致等待的线程和Socket来连接越来越多，最终超过虚拟机的承受范围使其崩溃。</p><p>​    解决方法：通知OA门户方修复无法使用的集成接口，并将以不调用改为生产者/消费者模式的消息队列后，系统恢复正常。</p><h5 id="5-2-6-不恰当数据结构导致内存占用过大"><a href="#5-2-6-不恰当数据结构导致内存占用过大" class="headerlink" title="5.2.6 不恰当数据结构导致内存占用过大"></a>5.2.6 不恰当数据结构导致内存占用过大</h5><p>​    例子：一个后台RPC服务器，64位虚拟机内存配置-Xms4g      -Xmx8g      -Xmn1g，使用ParNew+CMS的收集器组合平时Minor GC时间30毫秒以内，能接收。但业务上需每10分钟加载一个约80MB的数据文件到内存，这些数据在内存中形成超过100万个HashMap&lt;Long, long&gt; Entry，在这段时间里Minor GC会造成超过500毫秒停顿。原因在于：分析数据文件期间，800MB的Eden空间很快被填满从而引发GC，但是Minor GC以后新生代绝大多数对象还存活。ParNew收集器使用复制算法，对于这种情况将它们复制到Survivor并维持这些对象的引用成为一个沉重的负担，导致GC暂停时间明显变长。</p><p>​    如果不修改程序仅从GC调优角度去解决这个问题，可以考虑将Survivor空间去掉（通过参数），让新生代中存活的对象在第一次Minor GC后立即进入老年代，等到Major GC的时候再清理他们。这种措施治标不治本，治本的话需要修改程序，因为产生这种情况的根本原因是HashMap&lt;Long, Long&gt; 结构来存储数据文件空间效率太低。</p><h5 id="5-2-7-由Windows虚拟内存导致的长时间停顿"><a href="#5-2-7-由Windows虚拟内存导致的长时间停顿" class="headerlink" title="5.2.7 由Windows虚拟内存导致的长时间停顿"></a>5.2.7 由Windows虚拟内存导致的长时间停顿</h5><p>​    例子：带心跳检测功能的GUI桌面程序，每15秒发送一次心跳检测信号，若30秒内没收到返回信息，就认为和对方程序的连接已经断开。程序上线后发现检测有误报的概率，查询日志发现原因是程序偶尔出现间隔一分钟左右的时间完全无日志输出，处于停顿状态。</p><p>​    从GC日志文件中确认了停顿原因是由GC导致的，偶尔会出现一次接近一分钟的GC。从日志片段中可以看出，真正执行GC动作的时间不是很长，但从准备开始GC，到真正开始GC之间所消耗的时间却占了绝大多数。[Times：<strong>user=0.61 sys=0.52</strong>，real=31.16 secs]可以看出。</p><p>​    除GC日志之外，还观察到这个GUI程序内存变化的一个特点，当它最小化的时候资源管理显示的占用内存大幅度减小，但是虚拟内存则没有变化，因此怀疑程序最小化时工作内存被交换到了磁盘的页面文件之中，这样发生GC时就有可能因为恢复页面而导致不正常的GC停顿，可以通过参数来解决（保证程序在最小化时能立即响应）。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过案例来分析Java部署中相关的优化措施。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://yehengchao.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://yehengchao.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机性能监控与故障处理工具</title>
    <link href="http://yehengchao.cn/2018/06/20/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://yehengchao.cn/2018/06/20/虚拟机性能监控与故障处理工具/</id>
    <published>2018-06-20T01:52:46.000Z</published>
    <updated>2018-07-02T01:11:01.839Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JDK工具使用：主要记录一些JDK工具使用，包括内存监视和快照生成查看等一系列可视化工具。&lt;未完待续&gt;</p></blockquote><a id="more"></a><h4 id="4-2-JDK的命令行工具"><a href="#4-2-JDK的命令行工具" class="headerlink" title="4.2 JDK的命令行工具"></a>4.2 JDK的命令行工具</h4><!-- more --><h5 id="4-2-1-jps：虚拟机进程状况工具"><a href="#4-2-1-jps：虚拟机进程状况工具" class="headerlink" title="4.2.1 jps：虚拟机进程状况工具"></a>4.2.1 jps：虚拟机进程状况工具</h5><p>​    其功能和UNIX中的ps命令相似：列出正在进行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称及进程的本地虚拟机唯一ID(LVMID)。</p><h5 id="4-2-2-jstat：虚拟机统计信息监视工具"><a href="#4-2-2-jstat：虚拟机统计信息监视工具" class="headerlink" title="4.2.2 jstat：虚拟机统计信息监视工具"></a>4.2.2 jstat：虚拟机统计信息监视工具</h5><p>​    用于监视虚拟机各种运行状态信息的命令行工具，可以显示远程或者本地虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p><h5 id="4-2-3-jinfo：Java配置信息工具"><a href="#4-2-3-jinfo：Java配置信息工具" class="headerlink" title="4.2.3 jinfo：Java配置信息工具"></a>4.2.3 jinfo：Java配置信息工具</h5><p>​    该工具可以实时地查看和调整虚拟机各项参数。</p><h5 id="4-2-4-jmap：Java内存映像工具"><a href="#4-2-4-jmap：Java内存映像工具" class="headerlink" title="4.2.4 jmap：Java内存映像工具"></a>4.2.4 jmap：Java内存映像工具</h5><p>​    该命令用于生成堆转储快照（称为dump文件）。</p><h5 id="4-2-5-jhat：虚拟机堆转储快照分析工具"><a href="#4-2-5-jhat：虚拟机堆转储快照分析工具" class="headerlink" title="4.2.5 jhat：虚拟机堆转储快照分析工具"></a>4.2.5 jhat：虚拟机堆转储快照分析工具</h5><p>​    该命令与jmap搭配使用，来分析jmap生成的dump文件，不过实际上一般不会直接使用jhat来分析dump文件，两个原因：1. 一般不在部署应用的服务器上直接分析dump，即使这样做也会尽量将dump复制到其他机器上分析；2. jhat分析功能比较简陋，还有其他强大的工具可以选择。</p><h5 id="4-2-6-jstack：Java堆栈跟踪工具"><a href="#4-2-6-jstack：Java堆栈跟踪工具" class="headerlink" title="4.2.6 jstack：Java堆栈跟踪工具"></a>4.2.6 jstack：Java堆栈跟踪工具</h5><p>​    该命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。其主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。</p><h5 id="4-2-7-HSDIS：JIT生成代码反汇编"><a href="#4-2-7-HSDIS：JIT生成代码反汇编" class="headerlink" title="4.2.7 HSDIS：JIT生成代码反汇编"></a>4.2.7 HSDIS：JIT生成代码反汇编</h5><p>​    将本地代码还原为汇编代码输出（没成功）。</p><h4 id="4-3-JDK的可视化工具"><a href="#4-3-JDK的可视化工具" class="headerlink" title="4.3 JDK的可视化工具"></a>4.3 JDK的可视化工具</h4><h5 id="4-3-1-JConsole：Java监视与管理控制台"><a href="#4-3-1-JConsole：Java监视与管理控制台" class="headerlink" title="4.3.1 JConsole：Java监视与管理控制台"></a>4.3.1 JConsole：Java监视与管理控制台</h5><p>​        </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;JDK工具使用：主要记录一些JDK工具使用，包括内存监视和快照生成查看等一系列可视化工具。&amp;lt;未完待续&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://yehengchao.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://yehengchao.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集和内存分配</title>
    <link href="http://yehengchao.cn/2018/06/20/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>http://yehengchao.cn/2018/06/20/垃圾收集和内存分配/</id>
    <published>2018-06-20T01:51:44.000Z</published>
    <updated>2018-07-02T01:08:33.763Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于Java虚拟机GC垃圾收集机制，主要介绍了不同区域所使用的垃圾收集算法，以及他们的结合种类、适用场景。</p></blockquote><a id="more"></a><h4 id="3-4-HotSpot算法实现"><a href="#3-4-HotSpot算法实现" class="headerlink" title="3.4 HotSpot算法实现"></a>3.4 HotSpot算法实现</h4><h5 id="3-4-2-安全点"><a href="#3-4-2-安全点" class="headerlink" title="3.4.2  安全点"></a>3.4.2  安全点</h5><p>​    JVM通过GC Roots节点来判断某个对象是否可达，但是如果需要逐个检查的话必然会消耗很多时间，所以需要使用一个名为OopMap的数据结构来记录引用位置的信息（如指令流的起始位置，偏移量等）。</p><p>​    在OopMap的帮助下，JVM可以很快的完成GC Roots的枚举，但是这里会出现一个问题：并不是所有的指令都会生成对应的OopMap数据结构，假设如此需要大量的额外空间，导致GC的空间成本将会变得非常高。这里的解决办法是只在“特定位置”记录这些信息，这样的位置称之为安全点（safe point），当线程执行到safe point的时候才会停顿下来开始GC。这里的safe point选定不能太少也不能太多，太少GC等太久，太多增大运行负荷；这里的设置特征为“是否让程序长时间执行的特征”，最明显的特征就是指令序列的复用比如方法调用、循环跳转、异常跳转等位置。</p><p>​    为了让GC发生是所有线程（不包括JNI调用的线程）都能在最近的安全点停下来，有两种方法：抢先式中断和主动式中断。抢先式：GC发生时，中断所有线程，发现不在安全点的就恢复它使之跑到安全点上（目前几乎不用，不详细表）；主动式：GC发生时，不直接操作线程仅设置一个标志，各个线程在执行的时候主动去轮询这个标志，为真时自动挂起（轮询标志和安全点是重合的）。</p><h5 id="3-4-3-安全区域"><a href="#3-4-3-安全区域" class="headerlink" title="3.4.3 安全区域"></a>3.4.3 安全区域</h5><p>​    安全区域的设定是为了解决程序“不执行”的时候，即未分配CPU时间，因此线程无法响应JVM的中断请求挂起，典型的例子就是Sleep和Block状态。这时需要设置一个安全区域（safe region），安全区域是安全点的一个很大的扩展，设置原则为引用关系不会发生变化的一段代码片段。在线程离开安全区域之前会检查GC是否完成了根节点的枚举，完成的话继续执行，否则等待知道收到可以安全离开安全区域的信号为止。</p><h4 id="3-5-垃圾收集器"><a href="#3-5-垃圾收集器" class="headerlink" title="3.5 垃圾收集器"></a>3.5 垃圾收集器</h4><h5 id="3-5-1-Serial收集器"><a href="#3-5-1-Serial收集器" class="headerlink" title="3.5.1  Serial收集器"></a>3.5.1  Serial收集器</h5><p>​    Serial是一个最基本、发展最久的收集器，单线程，但不仅仅说明它只会使用一个CPU或者一条线程去完成垃圾收集工作，更重要的是它在收集垃圾时必须暂停其他所有线程直到它结束（Stop The World），虽然不科学但是依然是Client模式下默认新生代收集器，优点：简单高效（没有线程交互的开销，专心收垃圾）。在桌面场景中新生代内存往往不大，所以停顿时间可以控制在几十最多一百多毫秒以内。</p><h5 id="3-5-2-ParNew收集器"><a href="#3-5-2-ParNew收集器" class="headerlink" title="3.5.2 ParNew收集器"></a>3.5.2 ParNew收集器</h5><p>​    其实是Serial的多线程版本，只有它能与CMS收集器配合使用；目前新生代的垃圾收集只能从Serial和ParNew中选择，在单CPU的情况下ParNew不比Serial好（甚至由于线程交互的开销不能超过Serial）,但是随着CPU数量的增加，它对于GC时的系统资源的有效利用还是很有好处的。默认开启的线程数与CPU数量相同，可用参数进行限制。</p><h5 id="3-5-3-Parallel-Scavenge收集器"><a href="#3-5-3-Parallel-Scavenge收集器" class="headerlink" title="3.5.3 Parallel Scavenge收集器"></a>3.5.3 Parallel Scavenge收集器</h5><p>​    Parallel Scavenge的关注点和其他收集器不同，CMS等收集器是尽可能地缩短垃圾收集时用户线程的停顿时间，而该收集器目标时达到一个可控制的吞吐量（吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间））。和ParNew相比他们都是使用的复制算法，又是并行的多线程~ 但是不同的是Parallel Scavenge提供了两个参数用于精确控制吞吐量，分别为控制最大垃圾收集停顿时间参数以及直接设置吞吐量大小参数；停顿时间是虚拟机通过设置吞吐量和新生代空间大小来调整的。还有一个自适应调节策略（虚拟机根据系统情况自己调节）也是和ParNew的一个重要区别。</p><h5 id="3-5-4-Serial-Old收集器"><a href="#3-5-4-Serial-Old收集器" class="headerlink" title="3.5.4 Serial Old收集器"></a>3.5.4 Serial Old收集器</h5><p>​    Serial的老年代版本，垃圾回收算法使用的是标记-整理算法。主要两大用途：jdk1.5以及之前版本中与Parallel Scavenge收集器搭配使用；作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure 时使用。</p><h5 id="3-5-5-Parallel-Old-收集器"><a href="#3-5-5-Parallel-Old-收集器" class="headerlink" title="3.5.5 Parallel Old 收集器"></a>3.5.5 Parallel Old 收集器</h5><p>​    Parallel Scavenge的老年代版本，使用标记-整理算法。jdk1.6之前Parallel Scavenge较尴尬：因为新生代一旦选择Parallel Scavenge，老年代就只能使用Serial Old，所以无法充分利用多CPU的处理能力。后来有了Parallel Old就可以和它组合使用，真正注重吞吐量了。</p><h5 id="3-5-6-CMS收集器"><a href="#3-5-6-CMS收集器" class="headerlink" title="3.5.6 CMS收集器"></a>3.5.6 CMS收集器</h5><p>​    CMS收集器是一种以获取最短回收停顿时间为目标的收集器。基于“标记-清除”算法实现，运作过程分为四个步骤：初始标记，并发标记，重新标记，并发清除。</p><p>​    初始标记：仅仅标记一下GC Roots能直接关联到的对象，速度快但是需要“Stop The World”。</p><p>​    并发标记：进行GC Roots Tracing的过程，能够与用户线程一起工作。</p><p>​    重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，此阶段停顿时间比初始标记阶段时间稍长但是远比并发标记时间短，需要“Stop The World”。具体如何实现，做了什么还不清楚暂时不表。</p><p>​    并发清除：清理未被标记的对象（不可达的），与用户线程一起并发执行。</p><p>​    主要特点：并发收集、低停顿。</p><p>缺点：</p><ol><li><p>对CPU资源非常敏感，虽然不会导致用户线程停顿但是会明显占用CPU资源而导致应用程序变慢，总吞吐量降低。CMS默认启动的回收线程数是（CPU数+3）/ 4 。这样导致用户程序执行速度忽然降低难以接受，所以虚拟机提供了“增量式并发收集器”，模拟操作系统使用抢占式来模拟多任务，使GC线程、用户线程交替运行，这样会使整个垃圾收集时间变长。实践证明这种处理效果一般，不提倡使用。</p></li><li><p>无法处理浮动垃圾，浮动垃圾：由于并发清理阶段用户线程的运行产生新的垃圾，这部分垃圾未被标记导致当前周期无法被处理，需等下一周期。所以CMS不能老年代满了再收集，需要设置一部分空间给应用程序，jdk1.6中将启动阈值提高到了92%。但是用户可以通过参数进行设置，如果预留内存无法满足需要（Concurrent Mode Failure），虚拟机会启动后备预案：临时启动Serial Old来重新进行老年区的垃圾收集，这样停顿时间就会很久。如果启动阈值设置过高，会导致大量的“Concurrent Mode Failure”失败，性能大大降低。</p></li><li><p>这个缺点就是“标记-清除”算法普遍存在的了，收集结束会有大量空间碎片产生，当有大对象时无法找到足够大的连续空间来分配，因此提前触发了一次Full GC。为此CMS收集器提供-XX:+UseCMSCompactAtFullCollection开关参数（默认开），用于在进行Full GC时开启碎片合并整理过程，这样停顿时间变长。虚拟机设计者还提供-XX:CMSFullGCsBeforeCompaction，设置多少次不压缩的Full GC以后来一次带压缩的（默认0）。</p><p>这里有个疑问：既然使用“标记-清除”会导致大量空间碎片产生，那为什么不使用“标记-整理”算法呢？遂一顿搜索发现：原来CMS为了获取最短回收停顿时间而将耗时长的设为并发（并发标记和并发清理），如果在并发时通过整理移动了对象的内存，那么线程就会找不到应用对象在哪里。</p></li></ol><h5 id="3-5-7-G1收集器"><a href="#3-5-7-G1收集器" class="headerlink" title="3.5.7 G1收集器"></a>3.5.7 G1收集器</h5><p>​    G1（Garbage-First）收集器是新出的，面向服务端应用的收集器，有如下特点：1.并行与并发，能充分利用多CPU、多核环境缩短STW的时间；2.分代收集，能够采用不同方式处理不同类型的旧对象；3.空间整合，从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的（没理解）；4.可预测停顿，G1除了追求低停顿外还建立可预测的停顿时间模型，制定M时间片段内收集垃圾时间不能超过N，其原因在于可以有计划地避免在整个堆中进行全区域的垃圾收集，G1跟踪各个Region中垃圾收集的价值（根据获取空间大小和所需时间）维护一个表，每次优先回收价值高的Region。</p><p>​    Region之间不可能是孤立的，不然检测Region之间的对象引用的时候还得扫描整个Java堆导致效率降低。所以每个Region需维护一个Remembered Set记录该Region被引用对象的相关引用信息，在内存回收时加入Remembered Set的扫描即可。</p><p>G1收集器运作步骤：</p><ol><li>初始标记：和CMS一样，该阶段仅标记一下GC Roots能直接关联的对象并修改TAMS。</li><li>并发标记：从GC Root开始对堆中对象进行可达性分析，找出存活对象，该过程耗时久但是可并发操作。</li><li>最终标记：修正并发标记过程中因用户程序运作而导致产生变化的标记记录，虚拟机将其记录在线程Remembered Set Logs中，并在此阶段将其合并到Remembered Set中，可并行。</li><li>筛选标记：首先对各个Region回收价值和成本进行排序，根据用户期望的停顿时间来制定回收计划，可并行，但是停顿用户线程将大幅提高收集效率。</li></ol><h5 id="3-5-8-GC日志"><a href="#3-5-8-GC日志" class="headerlink" title="3.5.8 GC日志"></a>3.5.8 GC日志</h5><h4 id="3-6-内存分配与回收策略"><a href="#3-6-内存分配与回收策略" class="headerlink" title="3.6 内存分配与回收策略"></a>3.6 内存分配与回收策略</h4><h5 id="3-6-1-对象优先在Eden分配"><a href="#3-6-1-对象优先在Eden分配" class="headerlink" title="3.6.1 对象优先在Eden分配"></a>3.6.1 对象优先在Eden分配</h5><p>​    Eden区和Survivor区都属于新生代，而Eden区存放的对象一般都是生命周期不长的对象（因此使用复制算法进行回收）。</p><h5 id="3-6-2大对象直接进入老年代"><a href="#3-6-2大对象直接进入老年代" class="headerlink" title="3.6.2大对象直接进入老年代"></a>3.6.2大对象直接进入老年代</h5><p>​    所谓大对象指大量连续内存空间的Java对象，最典型的就是很长的字符串以及数组（更坏的消息是遇到一群“朝生夕灭”的“短命大对象”），经常导致内存还有不少就不得不提前触发垃圾收集来获取足够的连续空间来存放他们。可以通过设置-XX:PretenureSizeThreshold参数来设置这个上限值。</p><h5 id="3-6-3-长期存活的对象将进入老年代"><a href="#3-6-3-长期存活的对象将进入老年代" class="headerlink" title="3.6.3 长期存活的对象将进入老年代"></a>3.6.3 长期存活的对象将进入老年代</h5><p>​    通过对象年龄计数器来记录对象，当熬过第一次Minor GC进入Survivor区并将年龄设置为1，接着每熬过一次Minor GC就将年龄加1，当年龄加到一定程度就被晋升入老年代中（默认为15），这个年龄阈值可以通过-XX:MaxTenuringThreshold参数设置。</p><h5 id="3-6-4-动态对象年龄判断"><a href="#3-6-4-动态对象年龄判断" class="headerlink" title="3.6.4 动态对象年龄判断"></a>3.6.4 动态对象年龄判断</h5><p>​    虚拟机并不是永远要求对象年龄达到阈值才晋升老年代的，如果在Survivor中相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就直接进入老年代无需等到要求的阈值年龄了。</p><h5 id="3-6-5-空间分配担保"><a href="#3-6-5-空间分配担保" class="headerlink" title="3.6.5 空间分配担保"></a>3.6.5 空间分配担保</h5><p>​    在发生Minor GC前，虚拟机会检查老年代最大连续可用空间是否大于新生代所有对象总空间，如成立则此次Minor GC是安全的。如不成立，虚拟机检查是否允许担保失败（HandlePromotionFailure参数），若允许则检查老年代最大可用连续空间是否大于历次晋升到老年代对象平均大小，若大于则进行一次有风险的Minor GC，若小于或者设置为不允许担保失败，则进行一次Full GC。</p><p>​    JDK 6 update 24以后规则发生了更改，即不管HandlePromotionFailure参数如何设置，代码中都不会使用它，规则变为只要老年代连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关于Java虚拟机GC垃圾收集机制，主要介绍了不同区域所使用的垃圾收集算法，以及他们的结合种类、适用场景。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://yehengchao.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://yehengchao.cn/tags/jvm/"/>
    
      <category term="gc" scheme="http://yehengchao.cn/tags/gc/"/>
    
  </entry>
  
</feed>
