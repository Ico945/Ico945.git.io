<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>南寒</title>
  
  <subtitle>这一切都是命运石之门的选择！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yehengchao.cn/"/>
  <updated>2019-08-12T01:54:36.503Z</updated>
  <id>http://yehengchao.cn/</id>
  
  <author>
    <name>Ico</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阿里巴巴309期百年技术感想</title>
    <link href="http://yehengchao.cn/2019/08/12/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4309%E6%9C%9F%E7%99%BE%E5%B9%B4%E6%8A%80%E6%9C%AF/"/>
    <id>http://yehengchao.cn/2019/08/12/阿里巴巴309期百年技术/</id>
    <published>2019-08-11T16:00:00.000Z</published>
    <updated>2019-08-12T01:54:36.503Z</updated>
    
    <content type="html"><![CDATA[<h4 id="阿里巴巴309期百年技术"><a href="#阿里巴巴309期百年技术" class="headerlink" title="阿里巴巴309期百年技术"></a>阿里巴巴309期百年技术</h4><p>2019年8月7日到9日，我开始了为期三天的阿里巴巴百年技术，简称“百技”。在开始之前同部门一起实习的妹子就和我说很辛苦，导致我对这个活动有点害怕。好吧这一天终于来了，现在回想起来那几天确实很辛苦，每一天都感觉没睡醒，不过除了辛苦之外全都是惊喜了，不管是人还是事。</p><p>既然是说感想，那就从头开始吧。</p><p>第一天对我来说是最大的挑战，因为要上台自我介绍，我本就是一个不擅长表达的人，没办法也只能硬着头皮，上去之前组织了好久的语言，我有个缺点：在台上一紧张就容易语无伦次，所以每次都要努力控制自己。最后不管讲得怎么样，也算是过关了。表达确实是一种必不可少的能力，自己在这方面还需要加强。</p><p>主线任务：</p><ol><li><p>我们的队名最后确定，叫：给阿里倒上一杯卡布奇诺，嗯 要说特点的话，算是全场最长的队名吧:-) 。logo也是很有意思的，阿里喝Java（咖啡），还有代表我们来自不同部门 阿里云、高德、饿了么的标记，图是队里一个学过画画、很可爱的妹子画的。</p><p><img src="http://image.yehengchao.cn/superbed/2019/08/12/5d504ea7451253d178449d37.jpg" alt=""></p></li><li><p>第二个任务是确定商业项目，我们讨论了近三个小时 最终确定的主题是”阿里教育“，细节就不讲了，反正第一天晚上到家都凌晨了:-) 。讨论了很多包括方向、盈利点、商业模式等等。大家的热情都很高，团队合作中分工真的很重要，好的分工和合作很能提高工作效率。</p><p><img src="http://image.yehengchao.cn/superbed/2019/08/12/5d5050b7451253d17844cc82.jpg" alt=""></p></li><li><p>还有值得说的就是当天晚上有阿里达摩院的大佬 飞刀老师关于数据库的技术分享，我真的有认真听，听明白多少都是随缘了:-) 。</p></li><li><p>最后一个任务就是参加天池比赛”自适应负载均衡的设计实现“，这个任务将”辛苦“提到顶峰了，当天晚上又是凌晨才回去的。小伙伴们都很优秀，他们思考问题的角度，方式都是值得学习的。虽然最后成绩并没有很好，过程最重要吧，比赛期间的图：</p><p><img src="http://image.yehengchao.cn/superbed/2019/08/12/5d5052ff451253d17844fee6.jpg" alt=""></p><p><img src="http://image.yehengchao.cn/superbed/2019/08/12/5d5052ff451253d17844fee8.jpg" alt=""></p></li><li><p>最后的话：其实能来阿里实习我真的很开心，因为实验室的原因我从来没想过居然还能出来实习，要感谢我的主管和师兄，从开始投简历到最后拿到offer，再到现在实习总时长半个多月了。期间出现过种种困难，差一点就放弃了这个实习机会，最后还是挺到了现在。想来真是不容易，只能说这趟阿里真的没有白来。</p></li></ol><p>我的表达能力有限，从来都是心里一大堆想说的结果出来寥寥无语。总之这段时间真的很开心，遇到的人都很可爱，希望大家都能转正成功吧！江湖再见。</p><p>最后上<a href="https://www.bilibili.com/video/av63310916/" target="_blank" rel="noopener">视频</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;阿里巴巴309期百年技术&quot;&gt;&lt;a href=&quot;#阿里巴巴309期百年技术&quot; class=&quot;headerlink&quot; title=&quot;阿里巴巴309期百年技术&quot;&gt;&lt;/a&gt;阿里巴巴309期百年技术&lt;/h4&gt;&lt;p&gt;2019年8月7日到9日，我开始了为期三天的阿里巴巴百年技术
      
    
    </summary>
    
    
      <category term="日常" scheme="http://yehengchao.cn/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="生活" scheme="http://yehengchao.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>浅析通信IO</title>
    <link href="http://yehengchao.cn/2019/07/31/%E6%B5%85%E6%9E%90%E9%80%9A%E4%BF%A1IO/"/>
    <id>http://yehengchao.cn/2019/07/31/浅析通信IO/</id>
    <published>2019-07-31T03:06:08.000Z</published>
    <updated>2019-07-31T03:08:54.203Z</updated>
    
    <content type="html"><![CDATA[<p>记一次IO相关的技术分享</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>虽然在大厂实习总时间也一个多月了，但是因为特殊缘故一周只能过去两天，所以在公司的时间并不多。部门主管也表示理解，师兄也并不布置什么重大任务，现阶段还是以学习为主。作为中间件大厂，就我们部门而言一个项目里的中间件是极多的，即使是一个增删改查项目也少不了主干配置、switch等中间件。所以之前也着重在学习常用中间件的使用比如metaQ、SchedulerX。这不我们部门还有一个传统就是每个人要周期性地进行技术分享。这可真是难为我了，想了好几天最后决定讲讲IO吧，并没有什么技术上的创新。</p><h2 id="理解IO"><a href="#理解IO" class="headerlink" title="理解IO"></a>理解IO</h2><p>首先，I/O顾名思义就是输入输出的意思（input/output）。主要以文件流的形式从某个模块复制/移动到另一个模块，通常指边缘设备、各种存储和内存空间。常见的I/O场景有磁盘I/O、网络I/O、数据库I/O等。</p><p><img src="http://image.yehengchao.cn/superbed/2019/07/30/5d3fed0c451253d178e09ec8.jpg" alt=""></p><p>如上图以网络I/O为例，客户端对服务端连接请求过程中会有相应的数据传输，数据通过网络首先到达的就是服务端的网卡。所以整个I/O过程可以简单地认为是网卡上的数据到用户空间这个转移过程，最终目的就是要让我们写的程序（用户进程）能够得到数据。</p><p>像网卡这类计算机硬件我们的用户进程是无法直接对它操作的，比如微信视频聊天的时候需要你的电脑打开摄像头，这个过程中微信并不能直接去操作摄像头，他需要调用操作系统（内核进程），然后内核态的进程才能发出指令，操控摄像头。同理，这里网卡上的数据先要copy到系统内核空间，然后再从内核空间copy到用户空间。</p><p>网上找的例子：</p><table><thead><tr><th>I/O过程</th><th>用户空间</th><th>网卡</th><th>数据</th><th>内核空间</th></tr></thead><tbody><tr><td>钓鱼</td><td>鱼篓</td><td>池塘</td><td>鱼</td><td>鱼竿/鱼钩</td></tr></tbody></table><p>一次I/O的目的始终是将数据移动到用户空间里，至于应用进程如何操作数据已经和I/O无关了（钓鱼的最终目的就是把鱼放到鱼篓里，至于后面鱼怎么烧那是后面的事情了，心情好想生吃都行:-) ）。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="http://image.yehengchao.cn/superbed/2019/07/30/5d3fed0c451253d178e09eca.jpg" alt=""></p><p>首先讲阻塞/非阻塞、同步/异步。我一直觉得I/O中的这几个概念并没有一个很明确的定义，主要是NIO 大多数说法它是一个同步非阻塞I/O，然后转眼你又看到其他人说它是异步I/O。最主要的原因是对I/O分类不一样。</p><p>首先根据上述的I/O过程，将其分为两个阶段：</p><ol><li>数据准备阶段：网卡将数据copy到内核空间的过程。</li><li>数据I/O阶段：用户进程真正执行数据I/O。</li></ol><p>用户进程首先发起I/O，数据如果未就绪内核进程就会开始网卡到内核空间的数据拷贝过程，此时用户空间是一直等着还是不等去做别的事情，将这一步用来区分I/O是否阻塞的。然后数据准备就绪之后需要拷贝到用户空间，此时用户进程也就是发起I/O请求的用户进程是否需要执行拷贝任务，将这一步用来区分I/O是同步还是异步的。</p><p>所以在这个定义下，NIO就是同步非阻塞I/O了，如果你要说第一步没有阻塞，数据准备过程中用户进程可以同时去做别的事情，明明就是异步的。那他就是异步I/O :-)。只要能理解就行。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><blockquote><p>钓鱼的时候，我们坐在鱼竿前面手拿着鱼竿，等待的过程中什么也不做，直到鱼上钩了我们就把鱼钓起来，放到鱼篓里。然后接着钓鱼。</p></blockquote><p>上面这个例子中对于我们这个人来说，钓鱼过程中我们什么也干不了（是被阻塞的）。硬是得等鱼来了我们才开始干活，对于我们来说效率是很低的。</p><p><img src="http://image.yehengchao.cn/superbed/2019/07/30/5d3fed0c451253d178e09ece.jpg" alt=""></p><p>如上图，对于发起I/O操作的用户进程来看它主要经历的时间分为：等待数据就绪和复制数据这两步，第一步的时候用户进程并没有干什么活，只是眼巴巴地等着，相当于它占着CPU又不用，拉低了CPU的执行效率。</p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><blockquote><p>钓鱼的时候，我们坐在鱼竿前面 由于等待的过程很久，我们一边等一边玩手机，玩着玩着再抬头看看鱼来了没有… 等鱼来了我们再把鱼钓起来放到鱼篓里面。</p></blockquote><p>上面就相当于改良版的钓鱼方式了，我们在等的过程中还可以玩玩手机（当然玩其它东西也行:-)），但是需要时不时看一眼鱼来了没有，对于我来说效率确实是高了。</p><p><img src="http://image.yehengchao.cn/superbed/2019/07/30/5d3fed0c451253d178e09ed2.jpg" alt=""></p><p>如上图，对于发起I/O操作的进程来看它经历的时间也还是等待数据和复制数据，但是它在等待时如果发现数据未就绪会让出CPU，待会再过来看看（来来来老哥，我现在还不急要不你先上，我待会再来看看我急不急-:)）。</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><blockquote><p>还是钓鱼，发现我一个人钓还是太慢了，池塘这边 那边都有好多鱼，要不在叫几个人过来和我一起钓？不行，鱼多的地方实在太多了我朋友平时都很忙的，不能麻烦他们！对了，我可以多带点鱼竿，每个地方都放一根，然后我看着哪个地方的鱼竿鱼来了，我再过去收就行了。</p></blockquote><p>我开始变得贪心了，又想同时钓很多鱼又不想叫人，那我不得累点吗 不过还好钓鱼这个活大部分时间都是在等。这样一来我同时能钓上来的鱼肯定更多了。</p><p><img src="http://image.yehengchao.cn/superbed/2019/07/30/5d3fed0c451253d178e09ed5.jpg" alt=""></p><p>其实这就是IO多路复用模型，如上图所示 未复用的情况下，每个连接都会启用一个线程来处理请求，如果是高并发的情况下内存会不够用。因此让多个连接复用一个线程，并且通过一个Selector选择器通知线程IO就绪的任务。流程图如下图所示，可见多路复用下连接是阻塞在Selector上并不是阻塞在系统IO任务上，因此CPU并不阻塞，文件描述符（fd）的切换只是相当于for循环一样的消耗。</p><p>总结三种模型：</p><p><img src="http://image.yehengchao.cn/superbed/2019/07/30/5d3fed5f451253d178e0a160.jpg" alt=""></p><p><img src="http://image.yehengchao.cn/superbed/2019/07/30/5d3fed5f451253d178e0a162.jpg" alt=""></p><p><img src="http://image.yehengchao.cn/superbed/2019/07/30/5d3fed5f451253d178e0a166.jpg" alt=""></p><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>上文中也有提到I/O过程分为两个阶段，上述的模型不同的只是第一个阶段（数据准备过程），第二阶段（数据IO过程）都是同步的，也就是都需要发起IO的用户进程去将内核态已经准备好的数据拷贝到用户态。AIO则是异步IO，即内核态的数据准备就绪之后内核线程并不会提交信号，内核线程会将准备好的数据copy到用户空间（同步IO里这一步是用户线程做的事情）。当copy完成之后再向用户进程提交信号，用户进程收到信号之后就能操作数据了。</p><p><img src="http://image.yehengchao.cn/superbed/2019/07/30/5d3fed5f451253d178e0a16a.jpg" alt=""></p><p>大概流程如上图所示，可见异步IO在两个阶段都不会发生阻塞，对用户进程而言它只要发出I/O操作就立即返回，等他接受就绪信号的时候已经可以直接操作数据了。</p><p>可以按照下图进行分类：</p><p><img src="http://image.yehengchao.cn/superbed/2019/07/30/5d3fed5f451253d178e0a16d.jpg" alt=""></p><h2 id="实验比较"><a href="#实验比较" class="headerlink" title="实验比较"></a>实验比较</h2><p>因为Java中 AIO 的使用并不多，所以我们比较BIO和NIO的延迟时间，分别打开tomcat的两种模式，然后使用压测工具JMeter模拟1000次首页的访问。</p><p>各个配置如下图所示，tomcat开启各种模式成功与否可以通过日志验证：</p><p><img src="http://image.yehengchao.cn/superbed/2019/07/30/5d3fed96451253d178e0a354.jpg" alt=""></p><p><img src="http://image.yehengchao.cn/superbed/2019/07/30/5d3fed96451253d178e0a357.png" alt=""></p><p><img src="http://image.yehengchao.cn/superbed/2019/07/30/5d3fed96451253d178e0a35b.png" alt=""></p><p><img src="http://image.yehengchao.cn/superbed/2019/07/30/5d3fed96451253d178e0a35f.png" alt=""></p><p><img src="http://image.yehengchao.cn/superbed/2019/07/30/5d3fed96451253d178e0a363.png" alt=""></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Netty：在Java NIO的基础上进行封装（RocketMQ、Dubbo通信层都使用了netty）。</p><p>组成如下图：</p><p><img src="http://image.yehengchao.cn/superbed/2019/07/30/5d3fedba451253d178e0a497.jpg" alt=""></p><p><img src="http://image.yehengchao.cn/superbed/2019/07/30/5d3fedba451253d178e0a49e.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>BIO：同步阻塞I/O，I/O过程中的两个阶段都会发生阻塞。</p><p>NIO：同步非阻塞I/O，I/O的第一个阶段（数据准备阶段）不会阻塞，第二阶段（数据拷贝）需要用户进程主动拷贝，会发生阻塞。</p><p>多路复用IO：和NIO一样，同步非阻塞。在NIO的基础上多连接复用一个线程。</p><p>AIO：两个阶段都不阻塞，异步IO。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记一次IO相关的技术分享&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yehengchao.cn/categories/web/"/>
    
    
      <category term="socket" scheme="http://yehengchao.cn/tags/socket/"/>
    
      <category term="I/O" scheme="http://yehengchao.cn/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>黑苹果安装</title>
    <link href="http://yehengchao.cn/2018/12/02/%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%97%A5%E5%BF%97/"/>
    <id>http://yehengchao.cn/2018/12/02/黑苹果安装日志/</id>
    <published>2018-12-02T02:29:40.000Z</published>
    <updated>2018-12-15T12:34:30.940Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录黑苹果安装。</p></blockquote><a id="more"></a><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>第一次安装黑苹果，中间踩了不少坑，从刚开始一无所知的小白到现在的完美安装，觉得有必要做一个记录。也为以后再装的时候做一个参考吧。废话不多说，先上效果图</p><p><img src="http://image.yehengchao.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-02%2016.44.33.png" alt="屏幕快照 2018-12-02 16.44.33.png"></p><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>先说一下我的配置情况：</p><ul><li>主板：微星（MSI）Z370 TOMAHAWK战斧导弹</li><li>CPU：Intel 8086k（8700k特挑版）</li><li>内存：威刚万紫千红 ddr4 2666 8g + 英睿达 ddr4 2400 8g</li><li>显卡：蓝宝石 rx560d 4g （6pin供电）</li><li>硬盘：阿斯加特 256g(nvme) + hp sata 128g</li><li>板载声卡：ALC892</li></ul><p>主要配置就是这些，其他的和装黑苹果关系不大就省略了。</p><p><img src="http://image.yehengchao.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-02%2016.57.35.png" alt=""></p><h4 id="安装思路"><a href="#安装思路" class="headerlink" title="安装思路"></a>安装思路</h4><p>配置是我当时随便买的，也没想到突然想装黑苹果，当时的显卡是 750ti ，因为新系统mojave（10.14）并没有N卡的驱动，所以一顿搜索闲鱼上淘了一个 amd 560矿卡，考虑到amd免驱不得不AMD YES了。</p><p>首先设置一下BIOS里的设置，这里参考<a href="https://www.tonymacx86.com/threads/unibeast-install-macos-mojave-on-any-supported-intel-based-pc.259381/" target="_blank" rel="noopener">tonymac</a>。由于我是MSI的主板设置界面会有所不同，根据链接给的方法设置即可：<img src="http://image.yehengchao.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-02%2017.07.34.png" alt=""></p><p>设置如下：</p><p>首选显示设备——PEG（有独显设置）</p><p>共享内存——64M（看主板型号，我最大就是64）</p><p>MSI快速启动——禁止</p><p>快速启动——禁止</p><h4 id="CLOVER配置"><a href="#CLOVER配置" class="headerlink" title="CLOVER配置"></a>CLOVER配置</h4><p>这里需要用到几个工具，先介绍一下，由于我当时是在windows里装的，所以这里的工具针对win，当然mac下也有对应的工具 一搜就有了。</p><blockquote><p>Etcher-Setup-1.4.6-x64 ：用作将mac系统写入U盘中，制作安装盘使用</p><p>下载：链接:<a href="https://pan.baidu.com/s/1rcV1rod6hjiW3LAMxD8FZg" target="_blank" rel="noopener">https://pan.baidu.com/s/1rcV1rod6hjiW3LAMxD8FZg</a>  密码:l4fc</p></blockquote><blockquote><p>EasyUEFI_Free ：用作装好以后调整启动EFI顺序，可能用得到</p><p>链接:<a href="https://pan.baidu.com/s/1rcV1rod6hjiW3LAMxD8FZg" target="_blank" rel="noopener">https://pan.baidu.com/s/1rcV1rod6hjiW3LAMxD8FZg</a>  密码:l4fc</p></blockquote><p>系统镜像文件用的是远景上黑果小兵的<a href="https://mirrors.dtops.cc/iso/MacOS/daliansky_macos/" target="_blank" rel="noopener">链接</a>，我下的是macOS Mojave 10.14(18A389) Installer with Clover 4670.dmg。镜像是带Clover的，其中带了很多配置文件和驱动，需要根据自己的情况删减。</p><p>我使用的驱动：<img src="http://image.yehengchao.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-02%2020.58.05.png" alt=""></p><p>如果和我的配置一样，可以直接使用我的clover</p><blockquote><p>链接:<a href="https://pan.baidu.com/s/1xjfkhFCwodesDCYAY8PvQw" target="_blank" rel="noopener">https://pan.baidu.com/s/1xjfkhFCwodesDCYAY8PvQw</a>  密码:awob</p></blockquote><p>这里有两点要说明一下：</p><ul><li><p>AppleAlc 这个驱动是网上找的我这个声卡的驱动（892），对应的需要自己下，config中注入ID为1。</p></li><li><p>CodecCommander 和EAPDFix 这两个驱动刚开始我是没有的，导致了一个问题就是每次开机声卡是正常的，睡眠之后声音就会很小。网上搜了一大堆说的是macos唤醒之后声卡没有驱动，解决的办法是：</p><p>sudo kextunload /System/Library/Extensions/AppleHDA.kext<br>sudo kextload /System/Library/Extensions/AppleHDA.kext</p><p>重新加载声卡，可以写成脚本每次睡眠都运行一下（我觉得太呆了）。所以用了第二个办法，加入这个驱动。不知道原理是什么。</p><p>链接:<a href="https://pan.baidu.com/s/1I7rqzLFplJlxI2UJE_naZw" target="_blank" rel="noopener">https://pan.baidu.com/s/1I7rqzLFplJlxI2UJE_naZw</a>  密码:kary</p><p>链接:<a href="https://pan.baidu.com/s/1ooSgZ5I91zkcWwQQbAELSg" target="_blank" rel="noopener">https://pan.baidu.com/s/1ooSgZ5I91zkcWwQQbAELSg</a>  密码:t368</p></li></ul><p>还有一点，机型的设置尽量针对显卡，因为我的是rx560，所以这里选择18,2。</p><p><img src="http://image.yehengchao.cn/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-02%2017.35.35.png" alt=""></p><h4 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h4><p>因为我的是2k屏，并不能很好的支持苹果的视网膜屏，所以要开启Hidpi，但是还是推荐使用4k屏。</p><p><a href="https://github.com/xzhih/one-key-hidpi" target="_blank" rel="noopener">一键开启Hidpi</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>其他就没什么好说的了，对应什么问题搜索解决即可。</p><p>上一波成果图：</p><p><img src="http://image.yehengchao.cn/61544087673_.pic_hd.jpg" alt=""></p><p><img src="http://image.yehengchao.cn/51544087661_.pic_hd.jpg" alt=""></p><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>之前装好的黑苹果用了一段时间有一个问题。那就是在浏览网页的时候字体发虚，mac系统还是得上4k屏才完美。所以不得不将这个2k屏挂了闲鱼，后来福利价出了师弟。。</p><p>刚好双十二，京东逛了一圈看中一款飞利浦的4k屏，型号是276E，双十二好价果断入手，用了以后发现打开新世界的大门。之前觉得24寸屏幕刚好，现在反而觉得27寸才是王道啊～</p><p>上两张图：</p><p><img src="http://image.yehengchao.cn/mac1.jpg" alt=""></p><p><img src="http://image.yehengchao.cn/mac2.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录黑苹果安装。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="http://yehengchao.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Session和Cookie</title>
    <link href="http://yehengchao.cn/2018/08/07/Session%E5%92%8CCookie/"/>
    <id>http://yehengchao.cn/2018/08/07/Session和Cookie/</id>
    <published>2018-08-07T07:50:21.000Z</published>
    <updated>2019-07-29T06:14:39.907Z</updated>
    
    <content type="html"><![CDATA[<p>我理解的cookie和session</p><a id="more"></a><h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><p>Session和Cookie的作用都是为了保存访问用户的状态信息。由于Http是无状态的协议，所以服务端需要记录用户的状态时就需要用某种机制来识别具体的用户这就是Session。</p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>那cookie又是什么？每次进行Http请求的时候客户端都会发送相应的cookie信息给服务端一般这个信息里面包含了一个ID，服务端通过对这个ID进行识别来判断你是哪个。</p><p>当然cookie不止能发送一个ID，它的内容主要包括：名字、值、过期时间、路径和域。我们可以设置cookie的生命周期，若不设置默认为浏览器会话期间，关闭浏览器cookie就失效了。</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>前面介绍了cookie可以让服务端程序跟踪每个客户端的访问，但是每次客户端在访问时都必须传回这些cookie，如果cookie很多则增加了客户端和服务端的数据传输量，所以session出现了。同一个客户端和服务端交互时不需要每次都传回所有的cookie值，而是只要传回一个ID，这个ID是客户端第一次访问服务端时生成的，且每个客户端是唯一的，这样客户只要传回这个ID就行了，其它信息保存在服务端。</p><h4 id="Session和Cookie协同"><a href="#Session和Cookie协同" class="headerlink" title="Session和Cookie协同"></a>Session和Cookie协同</h4><p>那么session是如何利用cookie来进行工作的？实际上有三种方法：</p><ul><li>基于URL Path Parameter，默认支持。</li><li>基于Cookie，如果没有修改Context容器的Cookie标识，则默认也是支持的。</li><li>基于SSL，默认不支持，只有connector.getAttribute(“SSLEnabled”)为true的时候才支持。</li></ul><p>在第一种情况下，在用户浏览器不支持或者禁用的时候，浏览器会将用户的SessionCookieName重写到用户请求的URL参数中，服务器从这个路径参数中拿到用户配置的SessionCookieName，如果在后台的配置文件(web.xml)中配置session-config下的name属性就是这个SessionCookieName的值。如果没有配置，默认SessionCookieName就是熟悉的”JSESSIONID”。需要说明的是，与session关联的cookie与其他cookie没有什么不同。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我理解的cookie和session&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yehengchao.cn/categories/web/"/>
    
    
      <category term="javaweb" scheme="http://yehengchao.cn/tags/javaweb/"/>
    
      <category term="session" scheme="http://yehengchao.cn/tags/session/"/>
    
      <category term="cookie" scheme="http://yehengchao.cn/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>浅谈观察者模式</title>
    <link href="http://yehengchao.cn/2018/08/01/%E6%B5%85%E8%B0%88%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yehengchao.cn/2018/08/01/浅谈观察者模式/</id>
    <published>2018-08-01T12:14:29.000Z</published>
    <updated>2018-08-02T14:01:12.362Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>设计模式之观察者模式 </p></blockquote><a id="more"></a><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>观察者模式平时经常能听到，也是JDK中使用最多的模式之一，它可以帮你的对象知悉现况，不会错过该对象感兴趣的事。对象甚至在运行时可决定是否要继续被通知。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>首先举一个应用场景的例子来引出为什么需要使用观察者模式。</p><p>场景：</p><p>团队刚刚和气象公司建立了项目合作关系，为气象公司建立下一代Internet气象观测站，该气象站必须建立在专利申请中的WeatherData对象上，由该对象负责追踪目前的天气情况（温度、湿度、气压）。我们的任务是建立一个应用，有三种布告板，分别显示目前的状况、气象统计及简单的预报。当WeatherData对象获得最新的数据更新时，三种布告板必须实时更新。</p><p>而且这是一个可以扩展的气象站，合作方希望可以公布一组API，好让其他开发人员可以写出自己的气象布告板，并插入此应用中。</p><blockquote><p>这里的WeatherData类中涉及到的方法如下所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span></span>&#123;</span><br><span class="line">    getTemperature();<span class="comment">// 返回温度的方法。</span></span><br><span class="line">    getHumidity();<span class="comment">// 返回湿度的方法。</span></span><br><span class="line">    getPressure();<span class="comment">// 返回气压的方法。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *一旦气象测试更新，此方法会被调用。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    measurementsChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的主要目标是实现measurementsChanged()方法，好让它更新目前的状况、气象统计、天气预报的显示布告板。</p><h4 id="认识观察者模式"><a href="#认识观察者模式" class="headerlink" title="认识观察者模式"></a>认识观察者模式</h4><p>首先看看报纸和杂志的订阅是怎么发生的：</p><ul><li>报社的业务就是出版报纸。</li><li>向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户就会一直收到新的报纸。</li><li>当你不想看报纸的时候，取消订阅，他们就不会再送新报纸过来了。</li><li>只要报社还在运营，就会一直有人向他们订阅报纸或者取消订阅报纸。</li></ul><p>将这个例子映射到观察者模式中，出版者改称为“<strong>主题</strong>”，订阅者改称为“<strong>观察者</strong>”。主题对象的数据一旦发生改变，新的数据会以某种形式送到观察者手上。相反不是观察者的话，主题数据改变时就不会收到通知。</p><h4 id="定义观察者模式"><a href="#定义观察者模式" class="headerlink" title="定义观察者模式"></a>定义观察者模式</h4><p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变时，他的所有依赖者都会收到通知并自动更新。</p><p>观察者模式提供了一种对象的设计，让主题和观察者之间松耦合</p><ul><li>关于观察者的一切，主题只知道观察者实现了某个接口（也就是Observer接口）。主题不需要知道观察者的具体类是谁、做了些什么或其他任何细节。</li><li>任何时候都可以增加新的观察者。因为主题唯一依赖的东西是一个实现Observer接口的对象列表，所以随时可以增加观察者。事实上在运行时可以用新的观察者取代现有的观察者，主题不会受到任何影响。同样也可以在任何时候删除某些观察者。</li><li>新类型观察者出现主题的代码不需要修改。假如有个新的具体类需要当观察者，不需要为了兼容新类型而修改主题的代码，所有要做的就是在新的类里实现此观察者接口，然后注册为观察者即可。主题不在乎别的，只会发送通知给所有实现了观察者接口的对象。</li><li>可以独立地复用主题或观察者。如果在其他地方需要使用主题或者观察者，可以轻易地复用，因为二者并非紧耦合。</li><li>改变主题或者观察者一方，并不会影响另一方。因为两者都是松耦合的，只要他们之间的接口仍被遵循，就可以自由地改变他们。</li></ul><p>所以这里就要引出又一个设计原则：<strong>为了交互对象之间地松耦合设计而努力</strong>。</p><h4 id="实现气象站"><a href="#实现气象站" class="headerlink" title="实现气象站"></a>实现气象站</h4><p>根据上述讨论，需要开始对整个系统的实现了，Java中内置了为观察者模式的支持，但是这里暂时不使用而是自己来实现它。</p><blockquote><p>首先建立接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;<span class="comment">// 该方法需要一个观察者作为变量，该观察者用来注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;<span class="comment">// 同上，该观察者用来删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;<span class="comment">//当主题状态发生改变时，该方法被调用，通知所有观察者对象。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;<span class="comment">// 所有观察者必须实现该方法。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisplayElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;<span class="comment">// 布告板需要显示时，调用此方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在WeatherData中实现主题接口"><a href="#在WeatherData中实现主题接口" class="headerlink" title="在WeatherData中实现主题接口"></a>在WeatherData中实现主题接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> huminity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList();<span class="comment">// 用来记录观察者。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;<span class="comment">// 注册观察者</span></span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;<span class="comment">// 删除观察者</span></span><br><span class="line">        <span class="keyword">int</span> i = observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;<span class="comment">// 将发生改变的值告诉每一个观察者。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;observers.size(); i++)&#123;</span><br><span class="line">            Observer observer = (Observer) observers.get(i);</span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span> </span>&#123;<span class="comment">// 当观测值发生改变时，调用该方法通知观察者。</span></span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现布告板</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title">Observser</span>, <span class="title">DisplayElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> Subject weatherData;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;<span class="comment">//构造器需要weatherData作为注册用，保存引用方便可能取消注册。</span></span><br><span class="line">        <span class="keyword">this</span>.weatherData = weatherData;</span><br><span class="line">        weatherData.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;<span class="comment">// 保存参数，调用display()。</span></span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        displsy();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>按照上述做法会有一个问题，主题老是向观察者推送每一条更新，但不是所有观察者都对所有更新感兴趣，所以还存在另外一种模式，即主题提供getter方法，让观察者主动向其索取数据。</p><p>Java也内置了观察者模式的支持，只需要实现或者继承Observable(类)、或者Observer(接口)就好了。接下来利用内置的支持重做气象站。</p><blockquote><p>首先将WeatherData改成使用Observable</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;<span class="comment">// 构造器不再需要为了记住观察者们而建立数据结构了。   </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setChanged();<span class="comment">// 调用该方法表示状态已改变。</span></span><br><span class="line">        notifyObservers();<span class="comment">// 不使用该方法传数据，说明使用get的形式。（因为里面调用update）</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略一系列getter方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不要依赖于观察者被通知的次序</strong>。因为Observable实现了他的notifyObservers()方法，导致通知者次序可能和自己实现的不一样。</p><h4 id="java-util-Observable的黑暗面"><a href="#java-util-Observable的黑暗面" class="headerlink" title="java.util.Observable的黑暗面"></a>java.util.Observable的黑暗面</h4><p>这里JDK中的Observable是一个类，甚至没有实现一个接口。从之前说过的设计原则中得知这并不是一件好事情。</p><ul><li>首先，因为它是一个类，必须设计一个类来继承它。如果某一个类想同时具有Observable类和另一个超类的行为，就会陷入两难，因为Java不支持多重继承。限制了Observable的复用潜力。</li><li>再者，因为没有Observable接口，所以无法建立自己的实现，和内置的Observer API搭配使用 ，也无法将这个实现用另一种方法实现：如Observable将关键方法保护起来，如setChanged()（定义成了protected）。意味着：除非你继承Observable，否则无法创建Observable实例并组合到自己的对象中来。这个设计违反了 “多用组合，少用继承”原则。</li></ul><p>JDK中还有很多地方都是用了观察者模式~</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;设计模式之观察者模式 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yehengchao.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yehengchao.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="观察者模式" scheme="http://yehengchao.cn/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈策略模式</title>
    <link href="http://yehengchao.cn/2018/07/25/%E6%B5%85%E8%B0%88%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yehengchao.cn/2018/07/25/浅谈策略模式/</id>
    <published>2018-07-25T14:11:19.000Z</published>
    <updated>2018-07-25T14:18:18.094Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>设计模式之策略模式</p></blockquote><a id="more"></a><p>首先，给出策略模式的定义：策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式可以让算法的变化独立于使用算法的客户。</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>为了引出为什么使用策略模式，先说说不用这个模式之前是怎么做的。从简单的模拟鸭子应用开始，首先需要设计一套模拟鸭子的游戏，游戏中会出现各种类型的鸭子，一边游泳戏水，一边呱呱叫。系统内部使用标准的OO技术，设计了一个鸭子超类（SuperClass），并让各种鸭子继承超类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MallardDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//外观是绿头</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedheadDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//外观是红头</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后公司因为竞争压力巨大。客户需要改需求了，他们说要让鸭子会飞；主管也表示会飞的鸭子来将竞争者抛在后头。所以这个时候首先想到最直观的方法当然就是直接在超类中添加飞的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样一来问题出现了，一些本来不应该会飞的鸭子也在空中飞来飞去了，比如之前继承超类实现的橡皮鸭。直接在超类中加上新的行为会使得某些并不适合该行为的子类也具有该行为。</p><h5 id="分开变化和不变的部分"><a href="#分开变化和不变的部分" class="headerlink" title="分开变化和不变的部分"></a>分开变化和不变的部分</h5><p>所以这里提出了第一个设计原则：<strong>找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。</strong></p><p>意思就是说如果每次新的需求一来，都会使某方面的代码发生变化，那就可以确定这部分代码需要被抽离出来，和其他稳定的代码有所区分。</p><p>换个思考方式：把会变化的部分取出来并封装起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分。</p><p>所以这里以鸭子为例，把变化的和不变化的部分分开来，就目前所知除了fly()和quack()的问题之外，其他行为还算正常，没有特别需要改变的地方。所以现在准备建立两组类（完全远离Duck类），一个是“fly”相关的，一个是“quack”相关的，每组类将实现各自的动作。比如叫声不一样实现“呱呱叫”、“吱吱叫”、“安静不叫”。</p><h5 id="设计鸭子的行为"><a href="#设计鸭子的行为" class="headerlink" title="设计鸭子的行为"></a>设计鸭子的行为</h5><p>那我们如何设计实现飞行和呱呱叫的行为类呢？我们希望一切能有弹性，我们想能够“指定”行为到鸭子的实例。比如，想要产生一个新的绿头鸭的示例，并指定特定“类型”的飞行行为给他。干脆顺便让鸭子的行为可以动态地改变好了。</p><p>所以这里提出了第二个设计原则：<strong>针对接口编程，而不死针对实现编程。</strong></p><p>利用接口代表每个行为，比如FlyBehavior与QuackBehavior，而行为的实现都将实现其中的一个接口。所以鸭子类不会负责实现Flying与Quacking接口，反而制造一组其他类专门实现这两个行为。</p><p>所以新的设计中，鸭子的子类将使用接口（FlyBehavior与QuackBehavior）所表示的行为，实际的“实现”不会被绑死在鸭子的子类中。</p><p>这里所说的针对接口编程的接口并不是一定要用到Java的interface构造，其关键在于<strong>多态</strong>。利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上（向上转型）。举个例子：</p><p>针对实现编程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">d.bark();</span><br></pre></td></tr></table></figure><p>但是，针对接口/超类型编程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        bark();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        meow();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">meow</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line">animal.makeSound();</span><br></pre></td></tr></table></figure><p>这样做的好处就是，子类的实例化动作不再需要在代码中硬编码，例如 <em>new Dog()</em> ，<strong>而是在运行是才指定具体的实现的对象</strong>。</p><h5 id="鸭子的行为"><a href="#鸭子的行为" class="headerlink" title="鸭子的行为"></a>鸭子的行为</h5><p>所以为了将鸭子的叫和飞这两种行为分离开来，实现了两个接口：FlyBehavior和QuackBehavior，还有他们对应的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyWithWings</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//实现鸭子飞行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyNoway</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//什么都不做，不会飞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//实现鸭子呱呱叫</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Squeak</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//橡皮鸭子吱吱叫</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MuteQuack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//什么都不做，不会叫</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的设计，可以让飞行和呱呱叫的动作被其他对象复用，因为这些行为已经和鸭子类无关了。而可以新增一些行为，不会影响到既有的行为类，也不会影响“使用”到飞行行为的鸭子类。<strong>有了继承的好处，却没有继承所带来的包袱</strong>。</p><h5 id="整合鸭子行为"><a href="#整合鸭子行为" class="headerlink" title="整合鸭子行为"></a>整合鸭子行为</h5><p>这样做的关键在于，鸭子现在将飞行和呱呱叫的动作“委托”给别人处理，而不是使用定义在Duck()类（或子类）内的呱呱叫和飞行方法。</p><ul><li><p>首先，在Duck类中加入两个示例变量，分别为“flyBehavior”与“quackBehavior”，声明为接口类型，每个鸭子对象动态的设置这样变量以在运行时引用正确的行为类型（FlyWithWings、Squeak等）。</p></li><li><p>然后实现表现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    QuackBehavior quckBehavior;</span><br><span class="line">    <span class="comment">//其他省略</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        quckBehavior.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后设定flyBehavior与quackBehavior的实例对象。以MallardDuck为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MallardDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MallardDuck</span><span class="params">()</span></span>&#123;</span><br><span class="line">        quckBehavior = <span class="keyword">new</span> Quack();</span><br><span class="line">        flyBehavior = <span class="keyword">new</span> FlyWithWings();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//绿头鸭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="动态设定行为"><a href="#动态设定行为" class="headerlink" title="动态设定行为"></a>动态设定行为</h5><p>假设在鸭子类中通过设定方法（setter method）来设定鸭子的行为，而不是在鸭子的构造器内部实例化。</p><p>在Duck类中加入下面方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFlyBehavior</span><span class="params">(FlyBehavior fb)</span> </span>&#123;</span><br><span class="line">    flyBehavior = fb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior qb)</span> </span>&#123;</span><br><span class="line">    quackBehavior = qb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来就可以随时调用这两个方法改变鸭子的行为。</p><p>比如，一开始制造一个新的鸭子类型，是不会飞的：模型鸭（ModelDuck）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ModelDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flyBehavior = <span class="keyword">new</span> FlyNoWay();</span><br><span class="line">        quackBehavior = <span class="keyword">new</span> Quack();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//xxxxxx</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时建立一个新的飞行方式，火箭。。（FlyRocketPowered）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyRocketPowered</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//火箭飞行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用setter方法将该飞行模式加到模型鸭上去，使其具有火煎动力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Duck model = <span class="keyword">new</span> ModelDuck();</span><br><span class="line">model.setFlyBehavior(<span class="keyword">new</span> FlyRocketPowered());</span><br></pre></td></tr></table></figure><h5 id="“有一个”的关系"><a href="#“有一个”的关系" class="headerlink" title="“有一个”的关系"></a>“有一个”的关系</h5><p>上面的例子每一个鸭子都有一个FlyBehavior和一个QuackBehavior，好将飞行和叫委托给他们代为处理。这种将两个类结合起来使用的方式就是组合，这种做法和继承的不同之处在于：鸭子的行为不是继承来的，而是和适当的行为对象组合来的。</p><p>这里有一个很重要的设计原则：<strong>多用组合，少用继承</strong>。</p><p>使用组合建立系统具有很大的弹性，不仅可以将算法封装成类，更可以“在运行时动态地改变行为”，只要组合的行为对象符合正确的接口标准即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;设计模式之策略模式&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yehengchao.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yehengchao.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="策略模式" scheme="http://yehengchao.cn/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC基础</title>
    <link href="http://yehengchao.cn/2018/07/03/SpringMVC%E5%9F%BA%E7%A1%80/"/>
    <id>http://yehengchao.cn/2018/07/03/SpringMVC基础/</id>
    <published>2018-07-03T02:32:53.000Z</published>
    <updated>2018-07-25T14:09:15.142Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&lt;未完待续 &gt;</p></blockquote><a id="more"></a><h4 id="SpringMVC概述"><a href="#SpringMVC概述" class="headerlink" title="SpringMVC概述"></a>SpringMVC概述</h4><p>​    首先说说什么是MVC，它和三层架构的关系：</p><ul><li>MVC：Model + View  + Controller (数据模型+视图+控制器)。</li><li>三层架构：Presentation tier + Application tier + Data tier (展现层+应用层+数据访问层)。</li></ul><p>​       实际上MVC只存在三层架构的展现层，M是数据模型，是包含数据的对象 。在SpringMVC里有一个专门的类叫Model，用来和V之间进行数据交互、传值；V指的是视图页面，包含JSP、freeMarker、Velocity、Thymeleaf、Tile等；C是控制器(SpringMVC的注解@Controller的类)。</p><p>​    而三层架构是整个应用的架构，是由Spring框架负责管理的。一般项目结构中都有Service层、DAO层，这两个反馈在应用层和数据访问层。</p><h4 id="SpringMVC的常用注解"><a href="#SpringMVC的常用注解" class="headerlink" title="SpringMVC的常用注解"></a>SpringMVC的常用注解</h4><p>SpringMVC常用以下几个注解：</p><ul><li><p>@Controller</p><p>​    该注解在类上，表明这个类是Spring MVC里的Controller，将其声明为Spring的一个Bean，Dispatcher Servlet会自动扫描注解了此注解的类，将Web请求映射到注解了@RequestMapping的方法上。在声明普通Bean的时候，使用@Component、@Service、@Repository和@Controller是等同的，因为后面三个都组合了@Component元注解；但在Spring MVC声明控制器Bean的时候只能使用@Controller。</p></li><li><p>@RequestMapping</p><p>​    该注解是用来映射Web请求(访问路径和参数)、处理类和方法的。@RequestMapping可注解在类和方法上。注解在方法上的@RequestMapping路径会继承注解在类上的路径，@RequestMapping支持Servlet的request和response作为参数，也支持对request和response的媒体类型进行配置。</p></li><li><p>@ResponseBody</p><p>​    该注解支持将返回值放在response体内，而不是返回一个页面。在很多基于Ajax的程序的时候，可以以此注解返回数据而不是页面；此注解可放置在返回值前或者方法上。</p></li><li><p>@RequestBody</p><p>​    该注解允许request的参数在request体中，而不是直接链接在地址后面。此注解放置在参数前。</p></li><li><p>@PathVariable</p><p>​    该注解用来接收路径参数，如/news/001，可接收001作为参数，此注解放置在参数前。</p></li><li><p>@RestController</p><p>该注解是一个组合注解，组合了@Controller和@ResponseBody，所以在只开发一个和页面交互数据的控制时，需要使用此注解。若没有此注解，想要实现上述功能，则需要在代码中加@Controller和@ResponseBody两个注解。</p></li></ul><p>接下来实现一个各种注解使用的示例。</p><blockquote><p>首先在pom.xml添加jackson依赖，获得对象和json或xml之间的转换：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>然后实现用来演示获取request对象参数和返回此对象到response：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.yhc.highlight_springmvc4.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoObj</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoObj</span><span class="params">()</span></span>&#123;   <span class="comment">//jackson对对象和json做转换时需要此空构造。</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoObj</span><span class="params">(Long id, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注解演示控制器：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.yhc.highlight_springmvc4.web.ch4_3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.yhc.highlight_springmvc4.domain.DemoObj;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span> <span class="comment">//注解声明此类是一个控制器</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/anno"</span>)    <span class="comment">//映射此类的访问路径是/anno。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoAnnoController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(produces = <span class="string">"text/plain;charset=UTF-8"</span>)  <span class="comment">//方法未标注路径，因此使用类级别的路径/anno，produces参数定制返回的response媒体类型和字符集。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">index</span><span class="params">(HttpServletRequest request)</span></span>&#123;  <span class="comment">//演示可接受HttpServletRequest作为参数，也可接受HttpServletResponse作为参数；@ResponseBody注解用在返回值前面。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"url:"</span> + request.getRequestURL() + <span class="string">"can access"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/pathvar/&#123;str&#125;"</span>, produces = <span class="string">"text/plain;charset=UTF-8"</span>)    <span class="comment">//演示接受路径参数，在方法参数前结合@PathVariable使用。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">demoPathVar</span><span class="params">(@PathVariable String str, HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"url:"</span> + request.getRequestURL() + <span class="string">"can access, str: "</span> + str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"requestParam"</span>, produces = <span class="string">"text/plain;charset=UTF-8"</span>)  <span class="comment">//演示常规的request参数获取，访问路径为/anno/requestParam?id=1。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">passRequestParam</span><span class="params">(Long id, HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"url:"</span> + request.getRequestURL() + <span class="string">" can access, id: "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/obj"</span>, produces = <span class="string">"application/json;charset=UTF-8"</span>)    <span class="comment">//演示解释参数到对象，访问路径为/anno/obj?id=1&amp;name=xxx。</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>   <span class="comment">//该注解也可以用在方法上。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">passObj</span><span class="params">(DemoObj obj, HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"url: "</span> + request.getRequestURL() + <span class="string">"can access, obj id: "</span> + obj.getId() + <span class="string">"obj name: "</span> + obj.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = &#123;<span class="string">"/name1"</span>, <span class="string">"/name2"</span>&#125;, produces = <span class="string">"text/plain;charset=UTF-8"</span>)    <span class="comment">//演示映射不同路径到相同的方法上，访问路径为/anno/name1，/anno/name2。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">remove</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"url: "</span> + request.getRequestURL() + <span class="string">"can access"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面提到也可以使用@RestController注解进行演示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.yhc.highlight_springmvc4.web.ch4_3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.yhc.highlight_springmvc4.domain.DemoObj;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">//该注解声明是控制器，并且返回数据时不需要@ResponseBody。</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/rest"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoRestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/getjson"</span>,produces = &#123;<span class="string">"application/json;charset=UTF-8"</span>&#125;)   <span class="comment">//返回数据的媒体类型为json。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoObj <span class="title">getjson</span><span class="params">(DemoObj obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoObj(obj.getId()+<span class="number">1</span>, obj.getName()+<span class="string">"yyy"</span>); <span class="comment">//直接返回对象，对象会自动转换成json。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/getxml"</span>, produces = &#123;<span class="string">"application/xml;charset=UTF-8"</span>&#125;)    <span class="comment">//返回数据的媒体类型为xml。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoObj <span class="title">getxml</span><span class="params">(DemoObj obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoObj(obj.getId()+<span class="number">1</span>, obj.getName()+<span class="string">"yyy"</span>); <span class="comment">//直接返回对象，对象会自动转换成xml。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行项目，对部分实现进行验证：</p><p><img src="4.3_1.png" alt=""></p><p><img src="4.3_2.png" alt=""></p><p><img src="4.3_3.png" alt=""></p><p><img src="4.3_4.png" alt=""></p><h4 id="Spring-MVC基本配置"><a href="#Spring-MVC基本配置" class="headerlink" title="Spring MVC基本配置"></a>Spring MVC基本配置</h4><p>​    Spring MVC的定制配置需要继承WebMvcConfigurerAdapter类，并在此类使用@EnableWebMvc注解，来开启对Spring MVC的配置支持，这样就可以重写这个类的方法，完成常用配置。</p><blockquote><p>首先，将刚才的配置类继承WebMvcConfigurerAdapter类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.yhc.highlight_springmvc4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.yhc.highlight_springmvc4.interceptor.DemoInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.view.InternalResourceViewResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.view.JstlView;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>   <span class="comment">// 开启SpringMVC支持，若无此句，重写WebMvcConfigurerAdapter方法无效。</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"cn.yhc.highlight_springmvc4"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;  <span class="comment">// 继承WebMvcConfigurerAdapter类，重写其方法可对Spring MVC进行配置。</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InternalResourceViewResolver <span class="title">viewResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        InternalResourceViewResolver viewResolver = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line"></span><br><span class="line">        viewResolver.setPrefix(<span class="string">"/WEB-INF/classes/views/"</span>);</span><br><span class="line">        viewResolver.setSuffix(<span class="string">".jsp"</span>);</span><br><span class="line">        viewResolver.setViewClass(JstlView.class);</span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span></span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">"/assets/**"</span>).addResourceLocations(<span class="string">"classpath:/assets/"</span>);    <span class="comment">// addResourceLocations指文件放置的目录，addResourceHandler指对外暴露的访问路径。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拦截器配置"><a href="#拦截器配置" class="headerlink" title="拦截器配置"></a>拦截器配置</h4><p>​    拦截器(Interceptor)实现对每个请求处理前后进行相关的业务处理，类似Servlet的Filter。可以让普通的Bean实现HandlerInterceptor接口或者继承HandlerInterceptorAdapter类来实现自定义拦截器，然后通过重写WebMvcConfigurerAdapter配置类的addInterceptors方法来注册自定义拦截器。解析来演示一个简单的拦截器的开发和配置，计算每一次请求的处理时间。</p><blockquote><p>示例拦截器：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.yhc.highlight_springmvc4.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.handler.HandlerInterceptorAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;    <span class="comment">//继承HandlerInterceptorAdapter来实现自定义拦截器。</span></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//重写preHandle方法，在请求发生前执行。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        request.setAttribute(<span class="string">"startTime"</span>, startTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = (<span class="keyword">long</span>)request.getAttribute(<span class="string">"startTime"</span>);</span><br><span class="line">        request.removeAttribute(<span class="string">"startTime"</span>);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"本次请求处理时间为："</span> + <span class="keyword">new</span> Long(endTime-startTime)+<span class="string">"ms"</span>);</span><br><span class="line">        request.setAttribute(<span class="string">"handlingTime"</span>, endTime - startTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在配置类中增加重写的addInterceptors方法：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>   <span class="comment">//配置拦截器的Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoInterceptor <span class="title">demoInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span></span>&#123;  <span class="comment">// 重写addInterceptors方法注册拦截器。</span></span><br><span class="line">        registry.addInterceptor(demoInterceptor());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果如下图所示：</p><p><img src="4.3_5.png" alt=""></p><h4 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h4><p>​    通过该注解可以将对于控制器的全局配置放在同一个位置，注解了@Controller的类的方法可以使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上，这对所有注解了@RequestMapping的控制器内的方法有效。</p><ul><li>@ExceptionHandler：用于全局处理控制器里的异常。</li><li>@InitBinder：用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。</li><li>@ModelAttribute：该注解本来的作用是绑定键值对到Model中，此处演示让全局的@RequestMapping都能获得在此处设置的键值对。</li></ul><p>接下来演示一个使用@ExceptionHandler处理全局异常。</p><blockquote><p>定制ControllerAdvice：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.yhc.highlight_springmvc4.advice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.WebDataBinder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.InitBinder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ModelAttribute;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.WebRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span>   <span class="comment">// 声明一个控制器建言，该注解组合了@Component注解，所以自动注册为Spring的Bean。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandlerAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception.class)  <span class="comment">// @ExceptionHandler在此处定义全局处理，通过该注解的value属性可过滤拦截的条件，在此处我们可以看出拦截的所有Exception</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">exception</span><span class="params">(Exception exception, WebRequest request)</span></span>&#123;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);  <span class="comment">// error页面</span></span><br><span class="line">        modelAndView.addObject(<span class="string">"errorMessage"</span>, exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span> <span class="comment">// 此处使用该注解将键值对添加到全局，所有注解的@RequestMapping的方法都可获得此键值对。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAttributes</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"msg"</span>, <span class="string">"额外的信息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span> <span class="comment">// 通过该注解定制WebDataBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder webDataBinder)</span></span>&#123;</span><br><span class="line">        webDataBinder.setDisallowedFields(<span class="string">"id"</span>);    <span class="comment">// 忽略request参数的id。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了区分之前的控制器，这里新建演示控制器：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.yhc.highlight_springmvc4.web.ch4_3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.yhc.highlight_springmvc4.domain.DemoObj;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ModelAttribute;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviceController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/advice"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSomething</span><span class="params">(@ModelAttribute(<span class="string">"msg"</span>)</span> String msg, DemoObj obj)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"抱歉，参数有误/"</span> + <span class="string">"来自@ModelAttribute: "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要一个error.jsp用作异常展示界面：</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;@ControllerAdvice Demo&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    $&#123;errorMessage&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>可以分析一下请求流程，首先运行项目，通过浏览器访问 <a href="http://localhost:8080/advice?id=1&amp;name=xx" target="_blank" rel="noopener">http://localhost:8080/advice?id=1&amp;name=xx</a> ，可以看到请求参数中有id和name两个，因为在控制建言类中使用了@InitBinder注解定制的initBinder方法，忽略了id这个参数，所以会造成参数有误这个异常。</p><p>结果如下图所示：</p><p><img src="4.4_2.png" alt=""></p><p><img src="4.4_1.png" alt=""></p><h4 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h4>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;lt;未完待续 &amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Springboot" scheme="http://yehengchao.cn/categories/Springboot/"/>
    
    
      <category term="SpringMVC" scheme="http://yehengchao.cn/tags/SpringMVC/"/>
    
      <category term="注解" scheme="http://yehengchao.cn/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Spring高级话题</title>
    <link href="http://yehengchao.cn/2018/06/30/Spring%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/"/>
    <id>http://yehengchao.cn/2018/06/30/Spring高级话题/</id>
    <published>2018-06-30T02:16:29.000Z</published>
    <updated>2018-07-02T01:05:55.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要记录Spring容器中的Bean如何实现Aware接口来对事件进行发布管理，Spring容器通过一个基于线程池的任务执行器来进行异步任务的并发，条件注解的使用，组合注解声明，Enable*注解的原理以及如何进行测试。</p></blockquote><a id="more"></a><h4 id="Spring-Aware"><a href="#Spring-Aware" class="headerlink" title="Spring Aware"></a>Spring Aware</h4><p>​    Spring的依赖注入最大亮点就是所有的Bean 对Spring 容器的存在是没有意识的。即可以将现在的容器换成别的容器，比如 Goole Guice，这时Bean之间的耦合度很低。</p><p>​    但是实际项目中不可避免的用到Spring 容器本身的功能资源，这时Bean必须意识到Spring 容器的存在，才能调用Spring所提供的资源，这就是Spring Aware。使用了Spring Aware 的话Bean将会和Spring 架构之间耦合。</p><p>Spring 提供的Aware接口如图所示：</p><table><thead><tr><th>接口</th><th>功能</th></tr></thead><tbody><tr><td>BeanNameAware</td><td>获得容器中Bean的名称</td></tr><tr><td>BeanFactoryAware</td><td>获得当前 bean factory，这样可以调用容器服务。</td></tr><tr><td>ApplicationContextAware*</td><td>当前 application context，这样可以调用容器服务。</td></tr><tr><td>MessageSourceAware</td><td>获得message source，这样可以获得文本信息。</td></tr><tr><td>ApplicationEventPublisherAware</td><td>应用事件发布器，可以发布事件。</td></tr><tr><td>ResourceLoaderAware</td><td>获得资源加载器，可以获得外部资源文件</td></tr></tbody></table><p>​    Spring Aware 的目的是为了让Bean获得Spring 容器的服务。因为ApplicationContext接口集成了MessageSource接口、ApplicationEventPublisher接口和ResourceLoader接口，所以Bean 只要继承ApplicationContext就可以获得Spring容器的所有服务，但原则上还是用到什么接口就实现什么接口。</p><blockquote><p>示例，Spring Aware演示的Bean</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ResourceLoaderAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ResourceLoader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwareService</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;   <span class="comment">//实现BeanNameAware和ResourceLoaderAware两个接口，获得Bean名称和资源加载的服务。</span></span><br><span class="line">    <span class="keyword">private</span> String beanName;</span><br><span class="line">    <span class="keyword">private</span> ResourceLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//这里还有下面的注解刚开始出了点小问题，实现接口方法用@Override出现 "@Override is not allowed when implementing interface method" ,[解决办法及原因](https://stackoverflow.com/questions/15402615/override-is-not-allowed-when-implementing-interface-method)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span></span>&#123;    <span class="comment">//重写setResource方法。</span></span><br><span class="line">        <span class="keyword">this</span>.loader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span></span>&#123;   <span class="comment">//重写setBeanName方法。</span></span><br><span class="line">        <span class="keyword">this</span>.beanName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outputResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean的名称为："</span> + beanName);</span><br><span class="line">        Resource resource = loader.getResource(<span class="string">"classpath:aware/test.txt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"ResourceLoader加载的文件内容为："</span> + IOUtils.toString(resource.getInputStream()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"aware"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwareConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AwareConfig.class);</span><br><span class="line"></span><br><span class="line">        AwareService awareService = context.getBean(AwareService.class);</span><br><span class="line"></span><br><span class="line">        awareService.outputResult();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Bean的名称为：awareService</span><br><span class="line">ResourceLoader加载的文件内容为：<span class="keyword">this</span> is a test file</span><br></pre></td></tr></table></figure><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>​    Spring 通过任务执行器(TaskExecutor) 来实现多线程和并发编程。使用TaskExecutorConfig 可实现一个基于线程池的TaskExecutor。实际开发中的任务一般是非阻碍的，即异步的，所以需要在配置类中使用@EnableAsync开启对异步任务的支持，并通过在实际执行的Bean方法中使用@Async注解来生命这是一个异步任务。</p><blockquote><p>通过一个示例来进行说明，首先写配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> taskexecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.AsyncConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableAsync;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"taskexecutor"</span>)</span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskExecutorConfig</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;    <span class="comment">//配置类实现AsyncConfigurer接口对异常线程池更加细粒度的控制，创建线程自己的线程池。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span></span>&#123; <span class="comment">//重写getAsyncExecutor方法并返回一个ThreadPoolTaskExecutor，这样就获得了一个基于线程池TaskExecutor</span></span><br><span class="line">        ThreadPoolTaskExecutor taskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        taskExecutor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line">        taskExecutor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        taskExecutor.setQueueCapacity(<span class="number">25</span>);</span><br><span class="line">        taskExecutor.initialize();</span><br><span class="line">        <span class="keyword">return</span> taskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后是任务执行类，就是上面所说的Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> taskexecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span>  <span class="comment">//通过该注解表明该方法是个异步方法，如果注解在类级别上，则表明该类所有的方法都是异步方法，这里的方法自动被注入使用ThreadPoolTaskExecutor作为TaskExecutor。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executorAsyncTask</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行异步任务： "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>  <span class="comment">//同上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executorAsyncTaskPlus</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行异步任务+1： "</span> + (i+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> taskexecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(TaskExecutorConfig.class);</span><br><span class="line"></span><br><span class="line">        AsyncTaskService asyncTaskService = context.getBean(AsyncTaskService.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            asyncTaskService.executorAsyncTask(i);</span><br><span class="line">            asyncTaskService.executorAsyncTaskPlus(i);</span><br><span class="line">        &#125;</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下所示：</span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">1</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">3</span></span><br><span class="line">执行异步任务： <span class="number">3</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">4</span></span><br><span class="line">执行异步任务： <span class="number">4</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">5</span></span><br><span class="line">执行异步任务： <span class="number">5</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">6</span></span><br><span class="line">执行异步任务： <span class="number">6</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">7</span></span><br><span class="line">执行异步任务： <span class="number">7</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">8</span></span><br><span class="line">执行异步任务： <span class="number">8</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">9</span></span><br><span class="line">执行异步任务： <span class="number">9</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">10</span></span><br><span class="line">执行异步任务+<span class="number">1</span>： <span class="number">2</span></span><br><span class="line">执行异步任务： <span class="number">2</span></span><br><span class="line">执行异步任务： <span class="number">0</span></span><br><span class="line">执行异步任务： <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看出运行结果是并发执行而不是顺序执行的。</p><h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><p>​    从Spring3.1开始，计划任务在Spring中的实现变得非常简单，首先通过在配置类添加注解@EnableScheduling 来开启对计划任务的支持，然后在要执行计划任务的方法上注解@Scheduled，声明这是一个计划任务。通过该注解Spring支持多种类型的计划任务，包含cron、fixDelay、fixRate等。</p><blockquote><p>首先实现计划任务实现类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> taskscheduler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledTaskService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">5000</span>)    <span class="comment">//通过@Scheduled声明该方法是计划任务，使用fixedRate设定每隔固定时间5秒执行一次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportCurrentTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"每隔五秒执行一次 "</span> + dateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0 50 19 ? * *"</span>)   <span class="comment">//使用cron属性可以按照指定的时间执行。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fixTimeExecution</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在指定时间 "</span> + dateFormat.format(<span class="keyword">new</span> Date()) + <span class="string">"执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后实现配置类，主要是开启对计划任务的支持：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> taskscheduler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"taskscheduler"</span>)</span><br><span class="line"><span class="meta">@EnableScheduling</span>   <span class="comment">//使用此注解开启对计划任务的支持。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskSchedulerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> taskscheduler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(TaskSchedulerConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行效果如下图所示：</span><br><span class="line">每隔五秒执行一次 <span class="number">19</span>:<span class="number">49</span>:<span class="number">46</span></span><br><span class="line">每隔五秒执行一次 <span class="number">19</span>:<span class="number">49</span>:<span class="number">51</span></span><br><span class="line">每隔五秒执行一次 <span class="number">19</span>:<span class="number">49</span>:<span class="number">56</span></span><br><span class="line">在指定时间 <span class="number">19</span>:<span class="number">50</span>:<span class="number">00</span>执行</span><br><span class="line">每隔五秒执行一次 <span class="number">19</span>:<span class="number">50</span>:<span class="number">01</span></span><br><span class="line">每隔五秒执行一次 <span class="number">19</span>:<span class="number">50</span>:<span class="number">06</span></span><br></pre></td></tr></table></figure><h4 id="条件注解-Conditional"><a href="#条件注解-Conditional" class="headerlink" title="条件注解@Conditional"></a>条件注解@Conditional</h4><p>​    Spring 4提供了一个基于条件的Bean的创建，即使用@Conditional注解，该注解根据满足某一个特定条件创建一个特定的Bean。如当一个jar包在一个类路径下的时候，自动配置一个或多个Bean；或者只有某个Bean被创建才会创建另外一个Bean。</p><p>​    下面演示一个以不同操作系统为条件，通过实现Condition接口，并重写matches方法来构造判断条件。</p><blockquote><p>首先实现Windows条件的判定：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> conditional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Condition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.getEnvironment().getProperty(<span class="string">"os.name"</span>).contains(<span class="string">"Windows"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Linux条件判定：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> conditional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Condition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.getEnvironment().getProperty(<span class="string">"os.name"</span>).contains(<span class="string">"Linux"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义Service接口：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> conditional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Windows下要创建的Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> conditional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsListService</span> <span class="keyword">implements</span> <span class="title">ListService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"dir"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> conditional;</span><br></pre></td></tr></table></figure><blockquote><p>Linux下要创建的Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> conditional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxListService</span> <span class="keyword">implements</span> <span class="title">ListService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ls"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> conditional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Conditional;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional</span>(WindowsCondition.class)    <span class="comment">//通过@Conditional注解，符合Windows条件则实例化WindowsListService。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListService <span class="title">WindowsListService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowsListService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional</span>(LinuxCondition.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListService <span class="title">LinuxListService</span><span class="params">()</span></span>&#123;  <span class="comment">//同上，实例化LinuxListService。</span></span><br><span class="line">        <span class="keyword">return</span> LinuxListService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> conditional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ConditionConfig.class);</span><br><span class="line"></span><br><span class="line">        ListService listService = context.getBean(ListService.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getEnvironment().getProperty(<span class="string">"os.name"</span>) + <span class="string">"系统下的列表命令为："</span> + listService.showList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在Windows下的运行结果：</span><br><span class="line">Windows <span class="number">10</span>系统下的列表命令为：dir</span><br><span class="line"></span><br><span class="line">打包为jar包，Linux下的运行结果：</span><br><span class="line">INFO: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@<span class="number">7</span>cd84586: startup date [Sun Jul <span class="number">01</span> <span class="number">21</span>:<span class="number">06</span>:<span class="number">31</span> CST <span class="number">2018</span>]; root of context hierarchy</span><br><span class="line">Linux系统下的列表命令为：ls</span><br></pre></td></tr></table></figure><h4 id="组合注解与元注解"><a href="#组合注解与元注解" class="headerlink" title="组合注解与元注解"></a>组合注解与元注解</h4><p>​    从Spring 2开始，为了响应jdk 1.5推出的注解功能，Spring开始大量加入注解来代替xml配置。之前所涉及到的基本上都是元注解，元注解其实就是可以注解到别的注解上的注解，被注解的注解则称为组合注解，组合注解具备注解其上的元注解的功能。下面通过一个自定义的注解实现将@Configuration和@ComponentScan两个注解的组合。</p><blockquote><p>首先实现示例组合注解：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//组合@Configuration元注解</span></span><br><span class="line"><span class="meta">@ComponentScan</span>  <span class="comment">//组合@ComponentScan元注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WiselyConfigration &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;    <span class="comment">//覆盖value参数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>演示服务Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outputResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"从组合注解获得bean"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>加上组合注解的配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"><span class="meta">@WiselyConfigration</span>(<span class="string">"annotation"</span>)   <span class="comment">//使用自定义的组合注解，代替@Configuration和@ComponentScan。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(DemoConfig.class);</span><br><span class="line"></span><br><span class="line">        DemoService demoService = context.getBean(DemoService.class);</span><br><span class="line"></span><br><span class="line">        demoService.outputResult();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下：</span><br><span class="line">从组合注解获得bean</span><br></pre></td></tr></table></figure><h4 id="Enable-注解的工作原理"><a href="#Enable-注解的工作原理" class="headerlink" title="@Enable*注解的工作原理"></a>@Enable*注解的工作原理</h4><p>​    所有的@Enable*注解中都有一个@Import注解，是用来导入配置类的。具体说明可以看<a href="https://www.jianshu.com/p/3da069bd865c" target="_blank" rel="noopener">这里</a>。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>​    Spring 通过Spring TestContext Framework对集成测试提供顶级支持，它不依赖特定的测试框架，既可使用Junit、也可使用TestNG。</p><p>​    基于Maven构建的项目结构默认有关于测试的目录：src/test/java(测试代码)、src/test/resources(测试资源)，区别于src/main/java(项目源码)、src/main/resources(项目资源)。</p><p>​    Spring提供了一个SpringJUnit4ClassRunner类，接下来对该类提供的部分功能进行演示。</p><blockquote><p>首先添加Spring测试的依赖包到Maven：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单元测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4)Spring test --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>业务代码，在 src/main/java目录下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fortest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestBean</span><span class="params">(String content)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置类，在 src/main/java目录下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fortest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">devTestBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"from development profile"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"prod"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">prodTestBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">"from production profile"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试类，在src/test/java目录下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fortest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ActiveProfiles;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class) <span class="comment">//SpringJUnit4ClassRunner在JUnit环境下提供Spring TestContext Framework的功能。</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = &#123;TestConfig.class&#125;) <span class="comment">//加载配置</span></span><br><span class="line"><span class="meta">@ActiveProfiles</span>(<span class="string">"prod"</span>) <span class="comment">//声明活动的profile</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBeanIntegrationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">//使用@Autowired注解注入Bean。</span></span><br><span class="line">    <span class="keyword">private</span> TestBean testBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>   <span class="comment">//测试代码，使用JUnit的Assert来校验结果是否和预期一样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">proBeanShouldInject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String expected = <span class="string">"from production profile"</span>;</span><br><span class="line">        String actual = testBean.getContent();</span><br><span class="line">        Assert.assertEquals(expected, actual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果如下图所示：</p><p><img src="3.7_1.png" alt="Alt text"></p><p>接下来将@ActiveProfiles(“prod”)改为@ActiveProfiles(“dev”)，效果如下所示：</p><p><img src="3.7_2.png" alt="Alt text"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;主要记录Spring容器中的Bean如何实现Aware接口来对事件进行发布管理，Spring容器通过一个基于线程池的任务执行器来进行异步任务的并发，条件注解的使用，组合注解声明，Enable*注解的原理以及如何进行测试。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Springboot" scheme="http://yehengchao.cn/categories/Springboot/"/>
    
    
      <category term="Springboot" scheme="http://yehengchao.cn/tags/Springboot/"/>
    
      <category term="SpringAware" scheme="http://yehengchao.cn/tags/SpringAware/"/>
    
      <category term="多线程" scheme="http://yehengchao.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Spring常用配置</title>
    <link href="http://yehengchao.cn/2018/06/26/Spring%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://yehengchao.cn/2018/06/26/Spring常用配置/</id>
    <published>2018-06-26T02:29:40.000Z</published>
    <updated>2018-07-02T01:01:19.287Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录Spring中Bean的配置、EL和资源调用、Bean的声明周期、Profile、事件。</p></blockquote><a id="more"></a><h4 id="Bean的Scope"><a href="#Bean的Scope" class="headerlink" title="Bean的Scope"></a>Bean的Scope</h4><p>​    Scope描述的是Spring容器如何新建Bean实例的，通过 @Scope 注解来实现，有以下几种：</p><ul><li>Singleton：一个Spring容器中只有一个Bean的实例，此为Spring的默认配置，全容器共享一个实例。</li><li>Prototype：每次调用都新建一个Bean的实例。</li><li>Request：Web项目中，给每个http request 新建一个Bean实例。</li><li>Session：Web项目中，给每个http session新建一个Bean实例。</li><li>GlobalSession：这个只在portal应用中有用，给每个global http session新建一个Bean实例。</li></ul><p>singleton 和 prototype 实例：</p><blockquote><p>Singleton的Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span> <span class="comment">//默认为Singleton，相当于Scope("singleton")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSingletonService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Prototype的Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>) <span class="comment">//声明Scope为Prototype</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPrototypeService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"scope"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopeConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ScopeConfig.class);</span><br><span class="line">        DemoSingletonService s1 = context.getBean(DemoSingletonService.class);</span><br><span class="line">        DemoSingletonService s2 = context.getBean(DemoSingletonService.class);</span><br><span class="line"></span><br><span class="line">        DemoPrototypeService p1 = context.getBean(DemoPrototypeService.class);</span><br><span class="line">        DemoPrototypeService p2 = context.getBean(DemoPrototypeService.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"s1与s2是否相等： "</span> + s1.equals(s2));</span><br><span class="line">        System.out.println(<span class="string">"p1与p2是否相等： "</span> + p1.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果为：</span><br><span class="line">s1与s2是否相等： <span class="keyword">true</span></span><br><span class="line">p1与p2是否相等： <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h4 id="Spring-EL和资源调用"><a href="#Spring-EL和资源调用" class="headerlink" title="Spring EL和资源调用"></a>Spring EL和资源调用</h4><p>​    Spring EL-Spring 表达式语言支持在xml和注解中使用，类似于JSP的EL表达式，其中涉及调用各种资源包括普通文件、网址、配置文件、系统环境变量等。Spring主要在注解@Value 的参数中使用表达式。本文涉及到的有以下几种情况：</p><ul><li>注入普通字符</li><li>注入操作系统属性</li><li>注入表达式运算结果</li><li>注入其他Bean 的属性</li><li>注入文件内容</li><li>注入网址内容</li><li>注入属性文件</li></ul><p>示例：</p><blockquote><p>增加commons-io 可简化文件相关操作：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在包内添加test.txt文件，内容随意~</p><blockquote><p>在包内添加test.properties资源文件，内容如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">book.author=yyyy</span><br><span class="line">book.name=xxxx</span><br></pre></td></tr></table></figure><blockquote><p>编辑被注入的Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> el;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"其他类的属性"</span>)    <span class="comment">//表示注入普通的字符串</span></span><br><span class="line">    <span class="keyword">private</span> String another;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAnother</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> another;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnother</span><span class="params">(String another)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.another = another;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编写演示配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> el;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.PropertySourcesPlaceholderConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"el"</span>)</span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:el/test.properties"</span>) <span class="comment">//注入配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"I Love You!"</span>)   <span class="comment">//注入普通字符串</span></span><br><span class="line">    <span class="keyword">private</span> String normal;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;systemProperties.os.name&#125;"</span>)    <span class="comment">//注入操作系统属性</span></span><br><span class="line">    <span class="keyword">private</span> String osName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123; T(java.lang.Math).random() * 100.0 &#125;"</span>)   <span class="comment">//注入表达式结果</span></span><br><span class="line">    <span class="keyword">private</span> String randomNumber;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;demoService.another&#125;"</span>) <span class="comment">//注入其他Bean属性</span></span><br><span class="line">    <span class="keyword">private</span> String fromAnother;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"classpath:el/test.txt"</span>) <span class="comment">//注入文件资源</span></span><br><span class="line">    <span class="keyword">private</span> Resource testFile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"http://www.baidu.com"</span>)  <span class="comment">//注入网址资源</span></span><br><span class="line">    <span class="keyword">private</span> Resource testUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;book.name&#125;"</span>)  <span class="comment">//注入配置文件</span></span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertySourcesPlaceholderConfigurer <span class="title">propertyConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outputResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(normal);</span><br><span class="line">            System.out.println(osName);</span><br><span class="line">            System.out.println(randomNumber);</span><br><span class="line">            System.out.println(fromAnother);</span><br><span class="line"></span><br><span class="line">            System.out.println(IOUtils.toString(testFile.getInputStream()));</span><br><span class="line">            System.out.println(IOUtils.toString(testUrl.getInputStream()));</span><br><span class="line">            System.out.println(bookName);</span><br><span class="line">            System.out.println(environment.getProperty(<span class="string">"book.author"</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编写运行类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> el;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ElConfig.class);</span><br><span class="line"></span><br><span class="line">        ElConfig resourceService = context.getBean(ElConfig.class);</span><br><span class="line"></span><br><span class="line">        resourceService.outputResource();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出信息：</span><br><span class="line">I Love You!</span><br><span class="line">Windows <span class="number">10</span></span><br><span class="line"><span class="number">9.515003283753941</span></span><br><span class="line">其他类的属性</span><br><span class="line">文本测试</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">六月 <span class="number">26</span>, <span class="number">2018</span> <span class="number">5</span>:<span class="number">04</span>:<span class="number">41</span> 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose</span><br><span class="line">信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@<span class="number">531</span>d72ca: startup date [Tue Jun <span class="number">26</span> <span class="number">17</span>:<span class="number">04</span>:<span class="number">41</span> CST <span class="number">2018</span>]; root of context hierarchy</span><br><span class="line">&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-<span class="number">8</span>&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http:<span class="comment">//s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class="bg s_ipt_wr"&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus&gt;&lt;/span&gt;&lt;span class="bg s_btn_wr"&gt;&lt;input type=submit id=su value=百度一下 class="bg s_btn"&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;新闻&lt;/a&gt; &lt;a href=http://www.hao123.com name=tj_trhao123 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;地图&lt;/a&gt; &lt;a href=http://v.baidu.com name=tj_trvideo class=mnav&gt;视频&lt;/a&gt; &lt;a href=http://tieba.baidu.com name=tj_trtieba class=mnav&gt;贴吧&lt;/a&gt; &lt;noscript&gt; &lt;a href=http://www.baidu.com/bdorz/login.gif?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb&gt;登录&lt;/a&gt; &lt;/noscript&gt; &lt;script&gt;document.write('&lt;a href="http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u='+ encodeURIComponent(window.location.href+ (window.location.search === "" ? "?" : "&amp;")+ "bdorz_come=1")+ '" name="tj_login" class="lb"&gt;登录&lt;/a&gt;');&lt;/script&gt; &lt;a href=//www.baidu.com/more/ name=tj_briicon class=bri style="display: block;"&gt;更多产品&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=ftCon&gt; &lt;div id=ftConw&gt; &lt;p id=lh&gt; &lt;a href=http://home.baidu.com&gt;关于百度&lt;/a&gt; &lt;a href=http://ir.baidu.com&gt;About Baidu&lt;/a&gt; &lt;/p&gt; &lt;p id=cp&gt;&amp;copy;2017&amp;nbsp;Baidu&amp;nbsp;&lt;a href=http://www.baidu.com/duty/&gt;使用百度前必读&lt;/a&gt;&amp;nbsp; &lt;a href=http://jianyi.baidu.com/ class=cp-feedback&gt;意见反馈&lt;/a&gt;&amp;nbsp;京ICP证030173号&amp;nbsp; &lt;img src=//www.baidu.com/img/gs.gif&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;</span></span><br><span class="line"></span><br><span class="line">xxxx</span><br><span class="line">yyyy</span><br></pre></td></tr></table></figure><h4 id="Bean-的初始化和销毁"><a href="#Bean-的初始化和销毁" class="headerlink" title="Bean 的初始化和销毁"></a>Bean 的初始化和销毁</h4><p>​    在实际开发中，经常会遇到在Bean使用之前和使用之后做些必要的操作，Spring对Bean的生命周期的操作提供了支持，在Java配置和注解配置下提供两种方式：</p><ul><li>Java配置方式：使用@Bean 的initMethod 和destroyMethod (相当于xml配置的init-method 和 destroy-method)。</li><li>注解方式：利用JSR-250的@PostConstruct 和@PreDestroy。</li></ul><blockquote><p>首先在maven配置文件中增加JSR250的支持</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.annotion<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsr250-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用@Bean 形式的Bean如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> prepost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanWayService</span> </span>&#123;   <span class="comment">//此类不预先声明为Bean，在配置类中手动创建成为Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@Bean-init-method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanWayService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"初始化构造函数-BeanWayService"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@Bean-destroy-method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用JSR250形式的Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> prepost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSR250WayService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span>  <span class="comment">//在构造函数执行完之后执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jsr250-init-method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JSR250WayService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"初始化构造函数-JSR250WayService"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span> <span class="comment">//在Bean销毁之前执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jsr250-destroy-method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> prepost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"prepost"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrePostConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>, destroyMethod = <span class="string">"destroy"</span>)   <span class="comment">//initMethod和destroyMethod指定BeanWayService类的init和destroy方法在构造函数之后，Bean销毁之前执行</span></span><br><span class="line">    <span class="function">BeanWayService <span class="title">beanWayService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanWayService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//这里因为在JSR250WayService类中的方法已经指定了，所以不用上述那样</span></span><br><span class="line">    <span class="function">JSR250WayService <span class="title">jsr250WayService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JSR250WayService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> prepost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(PrePostConfig.class);</span><br><span class="line"></span><br><span class="line">        BeanWayService beanWayService = context.getBean(BeanWayService.class);</span><br><span class="line">        JSR250WayService jsr250WayService = context.getBean(JSR250WayService.class);</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果如下：</span><br><span class="line">初始化构造函数-BeanWayService</span><br><span class="line"><span class="meta">@Bean</span>-init-method</span><br><span class="line">初始化构造函数-JSR250WayService</span><br><span class="line">jsr250-init-method</span><br><span class="line">jsr250-destroy-method</span><br><span class="line"><span class="meta">@Bean</span>-destroy-method</span><br></pre></td></tr></table></figure><h4 id="Profile使用"><a href="#Profile使用" class="headerlink" title="Profile使用"></a>Profile使用</h4><p>Profile为在不同的环境下使用不同的配置提供了支持：</p><ul><li>通过设定Environment 的ActiveProfiles 来设定当前context 需要使用的环境配置。在开发中使用@Profile 注解类或者方法，达到在不同情况下选择实例化不同的Bean。</li><li>通过设定jvm的spring.profile.active参数来设置配置环境。</li><li>Web项目设置在Servlet 的context parameter中。（也就是上下文参数）</li></ul><blockquote><p>下面进行简单的代码演示，示例Bean：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> profile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoBean</span><span class="params">(String content)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Profile 配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> profile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"dev"</span>) <span class="comment">//Profile为dev时实例化devDemoBean。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoBean <span class="title">devDemoBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoBean(<span class="string">"from development profile"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"prod"</span>) <span class="comment">//Profile为prod时实例化为proDemoBean。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoBean <span class="title">prodDemoBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoBean(<span class="string">"from production profile"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Main类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> profile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">        context.getEnvironment().setActiveProfiles(<span class="string">"prod"</span>); <span class="comment">//将活动的Profile设置为prod。</span></span><br><span class="line">        context.register(ProfileConfig.class);  <span class="comment">//后置注册Bean配置类，不然会报Bean未定义的错误。</span></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        DemoBean demoBean = context.getBean(DemoBean.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(demoBean.getContent());</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果为：</span><br><span class="line">六月 <span class="number">29</span>, <span class="number">2018</span> <span class="number">9</span>:<span class="number">17</span>:<span class="number">42</span> 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh</span><br><span class="line">信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@<span class="number">67424e82</span>: startup date [Fri Jun <span class="number">29</span> <span class="number">21</span>:<span class="number">17</span>:<span class="number">42</span> CST <span class="number">2018</span>]; root of context hierarchy</span><br><span class="line">from production profile</span><br><span class="line">六月 <span class="number">29</span>, <span class="number">2018</span> <span class="number">9</span>:<span class="number">17</span>:<span class="number">42</span> 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose</span><br><span class="line">信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@<span class="number">67424e82</span>: startup date [Fri Jun <span class="number">29</span> <span class="number">21</span>:<span class="number">17</span>:<span class="number">42</span> CST <span class="number">2018</span>]; root of context hierarchy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果将 <span class="string">"pro"</span> 改为 <span class="string">"dev"</span> ：</span><br><span class="line">六月 <span class="number">29</span>, <span class="number">2018</span> <span class="number">9</span>:<span class="number">18</span>:<span class="number">37</span> 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh</span><br><span class="line">信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@<span class="number">67424e82</span>: startup date [Fri Jun <span class="number">29</span> <span class="number">21</span>:<span class="number">18</span>:<span class="number">37</span> CST <span class="number">2018</span>]; root of context hierarchy</span><br><span class="line">from development profile</span><br><span class="line">六月 <span class="number">29</span>, <span class="number">2018</span> <span class="number">9</span>:<span class="number">18</span>:<span class="number">37</span> 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose</span><br><span class="line">信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@<span class="number">67424e82</span>: startup date [Fri Jun <span class="number">29</span> <span class="number">21</span>:<span class="number">18</span>:<span class="number">37</span> CST <span class="number">2018</span>]; root of context hierarchy</span><br></pre></td></tr></table></figure><h4 id="事件-Application"><a href="#事件-Application" class="headerlink" title="事件(Application)"></a>事件(Application)</h4><p>​    Spring 的事件(Application Event) 为Bean 和 Bean 之间的消息通信提供了支持。当一个Bean 处理完一个任务之后，希望另一个Bean知道并能做出相应的处理，这时我们就能让另一个Bean 监听当前Bean 所发送的事件。(讲到这里，相当了Servlet中也有类似的事件监听，或许是差不多的东西)</p><p>Spring 实现事件监听流程：</p><ol><li>自定义事件，继承ApplicationEvent。</li><li>定义事件监听器，实现ApplicationListener。</li><li>使用容器发布事件。</li></ol><blockquote><p>首先，自定义事件，为了让消息更加可视化，传入参数msg：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoEvent</span><span class="params">(Object source, String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第二步，实现事件监听器：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">DemoEvent</span>&gt; </span>&#123;   <span class="comment">//实现ApplicationListener 接口，并且指定监听的事件类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(DemoEvent event)</span> </span>&#123;   <span class="comment">//使用onApplicationEvent 方法对消息进行接受处理。</span></span><br><span class="line">        String msg = event.getMsg();</span><br><span class="line">        System.out.println(<span class="string">"我(bean-DemoListener)接收到了bean-demoPublisher发布的消息："</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>事件发布类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPublisher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext context; <span class="comment">//注入ApplicationContext用来发布事件。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> DemoEvent(<span class="keyword">this</span>, msg)); <span class="comment">//使用publishEvent方法来发布事件。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"event"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行函数：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(EventConfig.class);</span><br><span class="line"></span><br><span class="line">        DemoPublisher demoPublisher = context.getBean(DemoPublisher.class);</span><br><span class="line"></span><br><span class="line">        demoPublisher.publish(<span class="string">"hello application event"</span>);</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下所示：</span><br><span class="line">六月 <span class="number">29</span>, <span class="number">2018</span> <span class="number">9</span>:<span class="number">56</span>:<span class="number">20</span> 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh</span><br><span class="line">信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@<span class="number">67424e82</span>: startup date [Fri Jun <span class="number">29</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">20</span> CST <span class="number">2018</span>]; root of context hierarchy</span><br><span class="line">我(bean-DemoListener)接收到了bean-demoPublisher发布的消息：hello application event</span><br><span class="line">六月 <span class="number">29</span>, <span class="number">2018</span> <span class="number">9</span>:<span class="number">56</span>:<span class="number">20</span> 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose</span><br><span class="line">信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@<span class="number">67424e82</span>: startup date [Fri Jun <span class="number">29</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">20</span> CST <span class="number">2018</span>]; root of context hierarchy</span><br></pre></td></tr></table></figure><p>可以看出，DemoListener成功监听到了DemoPublisher发布的事件。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录Spring中Bean的配置、EL和资源调用、Bean的声明周期、Profile、事件。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Springboot" scheme="http://yehengchao.cn/categories/Springboot/"/>
    
    
      <category term="Bean" scheme="http://yehengchao.cn/tags/Bean/"/>
    
      <category term="Spring" scheme="http://yehengchao.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring基础</title>
    <link href="http://yehengchao.cn/2018/06/25/Spring%E5%9F%BA%E7%A1%80/"/>
    <id>http://yehengchao.cn/2018/06/25/Spring基础/</id>
    <published>2018-06-25T05:40:28.000Z</published>
    <updated>2018-07-02T01:08:06.343Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Spring基础，主要涉及maven的介绍使用，控制反转和依赖注入以及关于(AOP)面向切面编程。</p></blockquote><a id="more"></a><h4 id="Spring配置方式"><a href="#Spring配置方式" class="headerlink" title="Spring配置方式"></a>Spring配置方式</h4><ol><li>xml配置</li><li>注解配置</li><li>Java配置</li></ol><h4 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h4><p>​    maven是一个软件项目管理工具。基于项目管理对象模型的概念，可用来管理项目的依赖、编译、文档等信息。</p><p>​    在maven中管理依赖时只需要在配置文件pom.xml中按下面的形式添加就好了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    添加完成以后maven就会通过互联网在maven中心库下载相关的依赖包到.m2目录下，也是你的本地maven库，如果中心库没有你需要的jar包，需要自己使用maven命令导入到本地maven库。</p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>​    在Spring的概念下，控制翻转和依赖注入是等同的概念，控制翻转是通过依赖注入实现的。依赖注入指容器负责创建对象和维护对象间的依赖关系，而不是通过对象本身负责自己的创建和解决自己的依赖。</p><p>​    依赖注入的目的是为了解耦，使用“组合”的概念降低类之间的耦合度。Spring IoC容器负责创建Bean，并且通过容器将功能类Bean注入到需要的Bean中。Spring 提供使用xml、注解、Java配置、groovy配置实现Bean的创建和注入。</p><p>声明Bean的注解有：</p><ul><li>@Component 组件，没有明确的角色</li><li>@Service 在业务逻辑层(service层)使用</li><li>@Respository 在数据访问层(dao层）使用</li><li>@Controller 在展现层(MVC - SpringMVC)使用</li></ul><p>注入Bean的注解：</p><ul><li>@Autowired：Spring提供的注解</li><li>@Inject：JSR-330提供的注解</li><li>@Resource：JSR-250提供的注解</li></ul><p>注入Bean的注解可以用在set方法上或者属性上。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>​    Java配置是现在推荐的方式，主要通过@Configuration 和@Bean 来实现</p><ul><li>@Configuration 声明当前类是一个配置类，相当于一个Spring配置的xml文件。</li><li>@Bean 注解在方法上，声明当前方法的返回值为一个Bean。</li></ul><p>遵循的基本原则是：全局配置使用Java配置(如数据库相关配置、maven相关配置)，业务Bean的配置使用注解配置。</p><h4 id="AOP：面向切面编程"><a href="#AOP：面向切面编程" class="headerlink" title="AOP：面向切面编程"></a>AOP：面向切面编程</h4><p>​    Spring的AOP 存在的目的就是为了解耦。可以让一组类共享相同的行为。Spring 支持AspectJ 的注解式切面编程。</p><ul><li>使用@Aspect 声明是一个切面。</li><li>使用@After 、@Before 、@Around 定义建言(advice)，可直接将拦截规则(切点)作为参数。</li><li>其中@After 、@Before 、@Around 参数的拦截规则作为切点(PointCut)，为了使切点复用，可使用@PointCut专门定义拦截规则，然后在@After 、@Before 、@Around 的参数中调用。</li><li>其中符合条件的每一个被拦截处为连接点(JoinPoint)。</li></ul><p>下面给出一个AOP的 demo：</p><p>​    首先在pom.xml中添加相关的依赖，相应信息可以在maven仓库中查询。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- aspectj支持 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjrt --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>编写拦截规则的注解：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)<span class="comment">//说明该注解的作用目标是方法</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="comment">//运行时有效</span></span><br><span class="line"><span class="meta">@Documented</span><span class="comment">//定义为Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Action &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编写使用注解的被拦截器：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="meta">@Service</span><span class="comment">//定义为Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoAnnotationService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Action</span>(name=<span class="string">"注解式拦截的add操作"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编写使用方法规则被拦截器：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMethodService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编写切面：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//该注解声明一个切面</span></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//定义为Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(aop.Action)"</span>)<span class="comment">//声明一个切点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotationPointCut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"annotationPointCut()"</span>)<span class="comment">//声明一个建言，并使用@Pointcut定义的切点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        Action action = method.getAnnotation(Action.class);</span><br><span class="line">        System.out.println(<span class="string">"注解式拦截 "</span> + action.name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* aop.DemoMethodService.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        System.out.println(<span class="string">"方法式拦截 "</span> + method.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"aop"</span>)</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span><span class="comment">//开启Spring对AspectJ的支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AopConfig.class);</span><br><span class="line">        DemoAnnotationService demoAnnotationService = context.getBean(DemoAnnotationService.class);</span><br><span class="line">        DemoMethodService demoMethodService = context.getBean(DemoMethodService.class);</span><br><span class="line"></span><br><span class="line">        demoAnnotationService.add();</span><br><span class="line">        demoMethodService.add();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line">注解式拦截 注解式拦截的add操作</span><br><span class="line">方法式拦截 add</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Spring基础，主要涉及maven的介绍使用，控制反转和依赖注入以及关于(AOP)面向切面编程。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Springboot" scheme="http://yehengchao.cn/categories/Springboot/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows内存</title>
    <link href="http://yehengchao.cn/2018/06/20/Windows%E5%86%85%E5%AD%98%E7%90%86%E8%A7%A3/"/>
    <id>http://yehengchao.cn/2018/06/20/Windows内存理解/</id>
    <published>2018-06-20T01:53:38.000Z</published>
    <updated>2018-07-02T01:08:17.923Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Windows中内存是如何分配的。</p></blockquote><a id="more"></a><p><strong>分配的是虚拟地址空间，不是虚拟空间；</strong><br>为什么分配这么大？这是windows给出的承诺，向应用程序承诺，在物理内存足够大的情况下，我能够提供给你这么大的地址空间（注意这里的用词是地址空间，意思是有允许其内存寻址最多到8T这个数字）<br>当然，虚拟内存空间地址是一回事，实际空间是另一回事。<br>之前说了，虚拟空间地址只是承诺<strong>能够寻址</strong>，并非真的分配了空间；当应用程序真的申请了地址空间内能访问的内存时，windows才会开始把被访问的<strong>内存页</strong>映射到物理内存中。（没错，人家就是打了个空头支票，实际情况是你用一页我分配一页）<br>所以总结如下：<br><strong>所谓的8T（0x200000000）有什么用：</strong>允许应用程序访问0x0-0x200000000的任意地址，当然访问0x200000001就会报错，因为超出地址空间了（所以虚拟地址空间越大越好，这样编译器布局内存自由度更大）<br><strong>64位系统为例，物理内存16G，应用程序用了10G，会发生什么：</strong>也就是说我允许应用程序用8T内存，但他只用了10G，那没问题，因为可以映射到16G物理内存中；<br><strong>64位系统为例，物理内存16G，应用程序用了17G，会发生什么：</strong>唔，物理内存有点不够用，但是可以把一些内存页存到硬盘上（虚拟内存），所以问题也不大，但是进程切换可能引起内存页在硬盘上的读写，所以电脑会有点卡<br><strong>64位系统为例，物理内存16G，应用程序申请了8T，会发生什么：</strong>没错，应用程序的确被允许使用8T内存，但是此时系统提供不了这么多，空头支票暴露，你的系统奔溃了</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Windows中内存是如何分配的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="内存" scheme="http://yehengchao.cn/categories/%E5%86%85%E5%AD%98/"/>
    
    
      <category term="Windows" scheme="http://yehengchao.cn/tags/Windows/"/>
    
      <category term="内存管理" scheme="http://yehengchao.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类加载机制</title>
    <link href="http://yehengchao.cn/2018/06/20/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yehengchao.cn/2018/06/20/虚拟机类加载机制/</id>
    <published>2018-06-20T01:53:25.000Z</published>
    <updated>2018-07-02T01:08:49.603Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录下Java中类加载的时机，类在加载过程经历的阶段。&lt;未完待续&gt;</p></blockquote><a id="more"></a><h4 id="7-2-类加载的时机"><a href="#7-2-类加载的时机" class="headerlink" title="7.2 类加载的时机"></a>7.2 类加载的时机</h4><pre><code>类从被加载到虚拟机内存开始，到卸载出内存，其整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析部分统称为连接。</code></pre><p>​    加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，什么时候开始加载并没有进行强制约束，可以交给虚拟机的具体实现来自由把握。</p><p>​    对于初始阶段，虚拟机规范严格规定了有且只有5种情况必须对类立即进行初始化：</p><ol><li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类时，发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>虚拟机启动时，用户需指定一个要执行的主类（包含main()方法的那个类），虚拟机会初始化这个类。</li><li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ol><p>​       接口加载过程与类加载过程与类加载过程稍微有一些不同，接口也有初始化的过程，接口中不能使用static{}语句块，但编译器仍然会为接口生成“<clinit>()”类构造器，用于初始化接口中所定义的成员变量。接口与类真正有所求区别的是前面讲述的5种“有且只有”需要初始化场景中的第3种：当初始化一个类时，发现其父类还没有进行过初始化，则需要先触发其父类的初始化。但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</clinit></p><h4 id="7-3-类加载的过程"><a href="#7-3-类加载的过程" class="headerlink" title="7.3 类加载的过程"></a>7.3 类加载的过程</h4><h5 id="7-3-1-加载"><a href="#7-3-1-加载" class="headerlink" title="7.3.1 加载"></a>7.3.1 加载</h5><p>加载阶段虚拟机需要完成3件事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 通过一个类的全限定名来获取定义此类的二进制字节流。</span><br><span class="line">2. 将字节流所代表的静态存储结构转化为方法区的运行时数据结构。</span><br><span class="line">3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</span><br></pre></td></tr></table></figure><p>​       这三点要求并不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的，例如：通过全限定名来获取此类的二进制流，没有规定要从Class文件中获取，所以就有多种花样：</p><p>​    从ZIP包中读取，最终成为日后JAR、EAR、WAR格式的基础。</p><p>​    从网络中获取，这种场景最典型的应用就是Applet。</p><p>​    运行时计算生成，这种场景使用最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是使用了ProxyGenerator.generateProxyClass来为特定接口生成形式为“*＄Proxy”的代理类的二进制字节流。</p><p>​    由其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。</p><p>​    从数据库中读取，这种场景相对少见些。例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库来完成程序代码在集群中的分发。</p><p>​    对于数组类而言，情况有所不同，数组类本身不通过类加载器创建，由Java虚拟机直接创建。但数组类与类加载器仍由紧密的联系，因为数组类的元素类型最终是要靠类加载器去创建，一个数组（C）创建过程如下：</p><p>​    数组组件类型是引用型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识。</p><p>​    如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与引导类加载器关联。</p><p>​    数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。</p><p>​    加载阶段完成后，虚拟机外部的二进制字节流按照虚拟机所需格式存储在方法区中，数据存储格式由虚拟机自行定义。然后在内存实例化一个java.lang.Class类的对象（没有明确在Java堆中，对于HotSpot而言，Class虽然是对象，但是存放在方法区中），这个对象作为程序访问方法区中的这些类型数据的外部接口。加载阶段和连接阶段的部分内容是交叉进行的。</p><h5 id="7-3-2-验证"><a href="#7-3-2-验证" class="headerlink" title="7.3.2 验证"></a>7.3.2 验证</h5><p>​    JVM通过检查输入的字节流是否符合Class文件格式的约束，验证阶段大致上会完成4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><ol><li><p>文件格式验证</p><p>​    验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理：</p><p>是否以魔数0xCAFEBABE开头。</p><p>主、次版本号是否在当前虚拟机处理范围之内。</p><p>常量池的常量中是否有不被支持的常量类型（检查tag标志）</p><p>指向常量的索引值是否有指向不存在的常量或不符合类型常量</p><p>……………………</p></li></ol><p>​       第一阶段的验证远不止如此，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。该验证基于二进制字节流进行，通过该验证后字节流才进入内存的方法区中进行存储，所以后面的验证都是基于方法区的存储结构进行的，不会直接操作字节流。</p><ol><li><p>元数据验证</p><p>​    第二阶段是对字节码描述的信息进行语义分析以确保描述的信息符合Java语言规范的要求：</p><p>这个类是否有父类（除了Object外所有类都要有父类）</p><p>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</p><p>如果不是抽象类是否实现了父类或接口中要求实现的所有方法</p><p>类中字段、方法是否与父类产生矛盾</p><p>………………………………..</p></li></ol><p>​       第二阶段目的主要是对类的元数据信息进行语义分析验证，保证不存在不符合Java语言规范的元数据信息。</p><ol><li><p>字节码验证</p><p>​    第三阶段是最复杂的阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。该阶段对类的方法体进行校验分析，保证被校验类方法在运行时不会做出危害虚拟机安全的事件：</p><p>保证任意时刻操作数栈数据类型与指令代码序列能配合工作。</p><p>保证跳转指令不会跳转到方法体以外的字节码指令上。</p><p>保证方法体中类型转换是有效的 子类可赋值给父类 反之不行。</p><p>………………………………………..</p></li></ol><p>​       若一个类方法的字节码未通过字节码验证，肯定是有问题的；但如果一个方法通过字节码验证，也不能说明其一定是安全的。这里涉及著名的“Halting Problem”（停机问题）：通俗讲就是通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。</p><p>​    JDK1.6之后Javac编译器和JVM进行了优化，给方法体Code属性的属性表里增加了一项“StackMapTable“属性，描述了方法体所有基本块（Basic Block，按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，在字节码验证期间就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。</p><ol><li><p>符号引用验证</p><p>​    最后阶段校验发生在虚拟机将符号引用转化为直接引用，这个转化将在连接的第三阶段——解析阶段中发生。可看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验：</p><p>符号引用中通过字符串描述的全限定名是否能找到对应的类。</p><p>指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</p><p>符号引用中的类、字段、方法访问性是否可以被当前类访问。</p><p>…………………………………………..</p></li></ol><p>符号验证目的是确保解析动作正常执行。</p><h5 id="7-3-3-准备"><a href="#7-3-3-准备" class="headerlink" title="7.3.3 准备"></a>7.3.3 准备</h5><p>​    该阶段是正式为类变量分配内存并设置类变量初始值的阶段，类变量所使用的内存都将在方法区中进行分配。该阶段有两个概念：首先，进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象初始化的时候随着对象一起分配在Java堆中。其次这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量定义为：public static int value = 123；那变量在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法中，所以把value赋值为123的动作将在初始化阶段才会执行。</clinit></p><p><img src="C:\Users\yehen\AppData\Local\Temp\1526473361124.png" alt="1526473361124"></p><p>​    上述提到的只是“通俗情况”下初始值是零值，还有一些“特殊情况”下：如果类字段的字段属性表中存在ConstantValue属性所指定的值，假设上述变量定义为：public static final int value = 123；编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据这个设置将value赋值为123.</p><p><img src="C:\Users\yehen\AppData\Local\Temp\1526474197627.png" alt="1526474197627"></p><p>可以看到字节码中多了ConstantValue属性并且有一个初始值为123</p><h5 id="7-3-4-解析"><a href="#7-3-4-解析" class="headerlink" title="7.3.4 解析"></a>7.3.4 解析</h5>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录下Java中类加载的时机，类在加载过程经历的阶段。&amp;lt;未完待续&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://yehengchao.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://yehengchao.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>类文件结构</title>
    <link href="http://yehengchao.cn/2018/06/20/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://yehengchao.cn/2018/06/20/类文件结构/</id>
    <published>2018-06-20T01:53:13.000Z</published>
    <updated>2018-07-02T01:08:41.683Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>分析一波Class类文件的结构，此处所使用的二进制文件查看用的classpy。</p></blockquote><a id="more"></a><h4 id="6-3-Class类文件的结构"><a href="#6-3-Class类文件的结构" class="headerlink" title="6.3 Class类文件的结构"></a>6.3 Class类文件的结构</h4><h5 id="6-3-1-魔数与Class文件的版本"><a href="#6-3-1-魔数与Class文件的版本" class="headerlink" title="6.3.1 魔数与Class文件的版本"></a>6.3.1 魔数与Class文件的版本</h5><p>​    Class文件是一组以8位（1个字节）为基础单位的二进制流，中间没有分隔符。每个Class文件的头4个字节成为魔数，它唯一作用就是确定这个文件是否为一个能被虚拟机接受的Class文件（其实好多文件类型都是使用魔数来识别的）。使用魔数而不是扩展名来进行识别主要是考虑安全性，因为文件扩展名是可以随意改动的。<img src="file:///E:/study/jvm/1524634239368.png?lastModify=1524634247" alt="img"></p><p>​    紧接着魔数的四个字节存储的是Class文件的版本号（如图所示）：第5个和第6个字节是次版本号（Minor Version），第7个和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的（图中0X0034转化为十进制为52，说明这个文件可以被JDK1.8或以上的本地虚拟机执行的Class文件），JDK1.1之后的每个JDK大版本发布主版本号向上加1，高版本JDK向下兼容以前版本的Class文件，但不能运行以后版本的class文件，即使文件格式并未发生任何变化。</p><h5 id="6-3-2-常量池"><a href="#6-3-2-常量池" class="headerlink" title="6.3.2 常量池"></a>6.3.2 常量池</h5><p>​    理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时还是在Class文件中第一次出现的表类型数据项目。</p><p>​    常量池中主要存放两大类常量：字面量和符号引用。</p><p>​    字面量：比较接近Java语言层面的常量概念，如文本串、申明为final的常量值等。</p><p>​    符号引用：编译原理层面，包含三类，即类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。Java在编译的时候不会像C/C++那样有一个“连接”的过程，而是在虚拟机加载Class文件的时候进行动态连接。Class文件不保存方法字段的最终内存信息，所以这些方法、字段的符号引用不经过运行期转换的话无法得到真正的内存入口地址，无法被虚拟机使用。当虚拟机运行时，需从常量池获得对应的符号引用，再在类创建或运行时解析、翻译到具体的内存地址之中。</p><p>​    常量池中每一项常量都是一个表，表的开始第一位是一个u1类型的标志位（tag），代表当前这个常量属于哪种常量类型。之所以说常量池是最繁琐的数据，是因为常量类型各自均有自己的结构。</p><p>​    由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型的常量来描述名称，所以该类型的最大长度就是Java中方法、字段名的最大长度。这里u2类型能表达的最大值是65535。所以Java程序中如果定义了超过64KB英文字符的变量和方法名，将无法编译。javap -verbose可以用于输出Class文件字节码内容。</p><h5 id="6-3-3-访问标志"><a href="#6-3-3-访问标志" class="headerlink" title="6.3.3 访问标志"></a>6.3.3 访问标志</h5><p>​    常量池结束之后，紧跟着两个字节代表访问标志（access_flags），用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类则是否被声明为final等。一共有16个标记位可以使用。</p><h5 id="6-3-4-类索引、父类索引与接口索引集合"><a href="#6-3-4-类索引、父类索引与接口索引集合" class="headerlink" title="6.3.4 类索引、父类索引与接口索引集合"></a>6.3.4 类索引、父类索引与接口索引集合</h5><p>​    类索引（this_class）和父类索引（super_class）都是u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系。Java不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，即父类索引都不为0。接口索引集合描述这个类实现了哪些接口，这些被实现的接口按Implement语句（如果类本身是一个接口，则是extends语句）后的顺序从左到右排列在接口索引集合中。</p><p>​    类索引和父类索引用两个u2类型索引值表示，各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过其中的索引值找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。</p><p>​    对于接口索引集合，入口第一项——u2类型的数据为接口计数器（interfaces_count），表示索引容量。如果该类没有实现任何接口，则计数器为0，后面索引表不占任何字节。如图所示。</p><h5 id="6-3-5-字段表集合"><a href="#6-3-5-字段表集合" class="headerlink" title="6.3.5 字段表集合"></a>6.3.5 字段表集合</h5><p>​    用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。可以包括的信息有：字段的作用域（public、private、protected）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。上述信息修饰符都是布尔值，要么有某个修饰符，要么没有。而字段叫什么、字段被定义为什么数据类型，这些都是无法固定的只能引用常量池中的常量来描述。</p><p>​    表中的两项索引值：name_index和descriptor_index，它们都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p><p>​    以书中的代码6-1为例，“org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅把类全名中的“.”替换成了“/”而已，为了使多个全限定名之间不产生混淆，在使用时最后一般会加入一个“；”,表示全限定名结束。简单名称指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别是“inc”和“m”。</p><p>​    相对于全限定名和简单名称来说，方法和字段的描述符复杂一些，描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</p><h5 id="6-3-6-方法表集合"><a href="#6-3-6-方法表集合" class="headerlink" title="6.3.6 方法表集合"></a>6.3.6 方法表集合</h5><p>​    Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。</p><p>​    方法的定义可以通过标志、名称索引、描述符索引表达清楚，方法里的java代码经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面。</p><p>​    与字段表中集合相对应，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。同样有可能出现由编译器自动添加的方法，最典型的就是类构造器”<clinit>“方法和实例构造器”<init>“方法。</init></clinit></p><p>​    在Java中，重载（Overload）一个方法除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此Java中无法仅仅依靠返回值的不同来对一个已有方法进行重载的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;分析一波Class类文件的结构，此处所使用的二进制文件查看用的classpy。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://yehengchao.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://yehengchao.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>调优案例分析与实战</title>
    <link href="http://yehengchao.cn/2018/06/20/%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <id>http://yehengchao.cn/2018/06/20/调优案例分析与实战/</id>
    <published>2018-06-20T01:53:00.000Z</published>
    <updated>2018-07-02T01:08:25.847Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过案例来分析Java部署中相关的优化措施。</p></blockquote><a id="more"></a><h4 id="5-2案例分析"><a href="#5-2案例分析" class="headerlink" title="5.2案例分析"></a>5.2案例分析</h4><h5 id="5-2-1-高性能硬件上的程序部署策略"><a href="#5-2-1-高性能硬件上的程序部署策略" class="headerlink" title="5.2.1 高性能硬件上的程序部署策略"></a>5.2.1 高性能硬件上的程序部署策略</h5><p>目前高性能硬件上部署程序主要的两种方式：</p><ol><li><p>通过64位JDK来使用大内存：</p><p>​    对于用户交互性强、对停顿时间敏感的系统给虚拟机分配超大堆的前提是有把握把应用程序的Full GC频率控制得足够低，譬如十几个小时甚至一天才出现一次Full GC。而控制Full GC的频率关键看应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。同时还需要面临的问题：</p><p>​    内存回收导致的长时间停顿。</p><p>​    现阶段64位JDK的性能测试结果普遍低于32位JDK。</p><p>​    需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照（因为要产生十几GB乃至更大的Dump文件），哪怕产生了快照也无法分析。</p><p>​    相同程序在64位JDK消耗的内存一般比32位JDK大，这是由于指针膨胀和数据类型对齐补白等因素导致的。</p><p>​</p></li><li><p>使用若干个32位虚拟机建立逻辑集群来利用硬件资源：</p><p>​    现阶段大多采用该方法，具体做法是在一台物理机器上启动多个应用服务器进程，每个服务器进程分配不同的端口，然后在前端搭建一个负载均衡器以反向代理的方式来分配访问请求。这种方案可能会遇到的问题：</p><p>​    尽量避免节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话（尤其式并发写操作容易出现问题），很容易导致IO异常。</p><p>​    很难高效地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能一些节点池满了而另外一些节点仍有较多空余。尽管可以使用集中式的JNDI（理解为同一资源池），但有一定复杂性并且可能带来额外的性能开销。</p><p>​    各节点仍然不可避免地受到32位的内存限制，32位windows系统每个进程只能使用2GB的内存，若考虑堆以外的内存开销则堆一般最多只能开到1.5GB。在某些Linux或Unix系统中可以提升至3GB甚至接近4GB的内存，但32位中仍然受最高4GB内存的限制。</p><p>​    大量使用本地缓存的应用在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点上都有一份缓存，这时候可以考虑把本地缓存改为集中式缓存。</p></li></ol><h5 id="5-2-2-集群间同步导致的内存溢出"><a href="#5-2-2-集群间同步导致的内存溢出" class="headerlink" title="5.2.2 集群间同步导致的内存溢出"></a>5.2.2 集群间同步导致的内存溢出</h5><p>​    例：一个基于B/S的MIS系统，硬件为两台2个CPU、8GB内存的HP小型机。服务器为WebLogic9.2，每台机器启动了三个WebLogic实例，构成一个6个节点的亲合式集群（节点之间没有进行Session同步），但有一些需求要实现部分数据在各节点间共享。开始这些数据存放在数据库中，由于读写频繁竞争很激烈，性能影响较大，后来使用JBossCatch构建了一个全局缓存。启用后不久却不定期地出现了多次内存溢出问题。</p><p>​    查看生成的dump 文件发现里面有大量的org.jgroups.protocols.pbcast.NAKACK对象。JBossCatch基于自家的JGroups进行集群间的数据通信，JGroups使用协议栈的方式来实现收发数据包的各种所需特性自由组合。由于信息有传输失败需要重发的可能性，在确认所有注册在GMS(Group Membership Service)的节点都收到正确的信息前，发送信息必须在内存中保留。MIS服务端有一个负责安全校验的全局Filter，每当收到请求均更新一次最后操作时间并将其同步到所有节点，使一个用户一段时间内不能在多台机器上登录。服务器使用过程中往往一个页面产生数次乃至数十次的请求，因此这个过滤器导致集群节点之间网络交互非常频繁。当网络情况不能蛮子传输要求时，重发数据在内存中不断堆积，很快产生了内存溢出。若使用JBossCatch缓存来同步的话可以允许读操作频繁，但不应当有过于频繁的写操作。</p><h5 id="5-2-3-堆外内存导致的溢出错误"><a href="#5-2-3-堆外内存导致的溢出错误" class="headerlink" title="5.2.3 堆外内存导致的溢出错误"></a>5.2.3 堆外内存导致的溢出错误</h5><p>​    例子：学校小型项目，基于B/S的电子考试系统，为了实现客户端能实时地从服务器端接收考试数据系统使用了逆向AJAX技术。测试期间发现服务端不定时抛出内存溢出异常，服务器不一定每次都会抛出异常。管理员尝试过把堆卡到最大，32位系统堆最多到1.6G就基本无法再大了，而且开大了基本没什么效果，异常好像还更加频繁了。想通过参数使其产生dump文件，发现什么文件也没有产生。最后在内存溢出后从系统日志中找到异常堆栈。</p><p>​    服务器使用32位Windows平台的限制是2GB，其中划了1.6GB给Java堆，而Direct Memory内存并不算入1.6GB的堆之内，因此最大也只能在剩余的0.4GB中分出一部分。此应用中导致溢出的原因为：垃圾收集时虚拟机虽然会对Direct Memory进行回收，但是Direct Memory不像新生代、老年代那样发现空间不足了就通知收集器进行垃圾回收，它只能等待老年代满了以后Full GC，然后顺便地帮他清理掉废弃的对象。否则它只能一直等到抛出内存溢出异常时先catch掉，再在catch块中调用System.gc()，要是此使虚拟机还不进行gc，那就不得不抛出内存溢出异常了（虽然有可能堆中还有很多空闲内存）。本案例中使用的CometD 1.1.1框架，正好有大量的<strong>NIO</strong>操作要使用到Direct Memory内存。</p><p>除了Java堆和永久代外，下面区域还会占用较多的内存：</p><p>​    Direct Memory：可通过参数-XX:MaxDirectMemorySize进行大小的调整。</p><p>​    线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError（栈深不足，纵向）和OutOfMemoryError（无法建立新线程，横向）。</p><p>​    Socket缓存区：每个Socket连接都有Receive和Send两个缓存区，分别占37KB和25KB，连接多的话这部分内存也比较可观，如无法分配则可能抛出IOException:Too many open files异常。</p><p>​    JNI代码：使用JNI调用本地库，使用的内存也不在堆中。</p><p>​    虚拟机和GC：虚拟机、GC的代码执行也要消耗一定的内存。</p><h5 id="5-2-4-外部命令导致系统缓慢"><a href="#5-2-4-外部命令导致系统缓慢" class="headerlink" title="5.2.4 外部命令导致系统缓慢"></a>5.2.4 外部命令导致系统缓慢</h5><p>​    例子：一个数字校园应用系统运行在Solaris操作系统上，中间件为GlassFish服务器。系统做大并发压力测试发现请求响应时间较慢，使用mpstat发现CPU使用率高并且系统占用绝大多数的CPU资源。后来使用Dtrace发现最消耗CPU资源的是“fork”系统调用。</p><p>​    原因是：每个用户请求的处理都需要执行一个外部shell脚本来获得系统的信息，执行这个shell脚本是通过Java的Runtime.getRuntime().exec()方法来调用的。这种调用方式在虚拟机中非常消耗资源，频繁调用创建进程开销非常可观，系统消耗会很大，不仅是CPU，内存负荷也很重。</p><h5 id="5-2-5-服务器JVM进程崩溃"><a href="#5-2-5-服务器JVM进程崩溃" class="headerlink" title="5.2.5 服务器JVM进程崩溃"></a>5.2.5 服务器JVM进程崩溃</h5><p>​    例子：一个基于B/S的MIS系统正常运行一段时间后发现在运行期间频繁出现集群节点的虚拟机进程自动关闭现象。从系统日志文件可看出发生过大量的远端断开连接的异常，通过系统管理员了解到系统最近与一个OA门户做了集成，在MIS系统工作流的代办事项变化时要通过Web服务通知OA门户系统，把代办事项的变化同步到OA门户中。通过SoapUI测试了同步待办事项的Web服务，发现调用以后需要3分钟才能返回，并且返回结果都是连接中断。</p><p>​    由于MIS系统用户多、待办事项变化快，为了不被OA系统拖累使用了异步方式调用Web服务，由于两边速度不对等，时间久了就积累了越多Web服务没有调用完成，导致等待的线程和Socket来连接越来越多，最终超过虚拟机的承受范围使其崩溃。</p><p>​    解决方法：通知OA门户方修复无法使用的集成接口，并将以不调用改为生产者/消费者模式的消息队列后，系统恢复正常。</p><h5 id="5-2-6-不恰当数据结构导致内存占用过大"><a href="#5-2-6-不恰当数据结构导致内存占用过大" class="headerlink" title="5.2.6 不恰当数据结构导致内存占用过大"></a>5.2.6 不恰当数据结构导致内存占用过大</h5><p>​    例子：一个后台RPC服务器，64位虚拟机内存配置-Xms4g      -Xmx8g      -Xmn1g，使用ParNew+CMS的收集器组合平时Minor GC时间30毫秒以内，能接收。但业务上需每10分钟加载一个约80MB的数据文件到内存，这些数据在内存中形成超过100万个HashMap&lt;Long, long&gt; Entry，在这段时间里Minor GC会造成超过500毫秒停顿。原因在于：分析数据文件期间，800MB的Eden空间很快被填满从而引发GC，但是Minor GC以后新生代绝大多数对象还存活。ParNew收集器使用复制算法，对于这种情况将它们复制到Survivor并维持这些对象的引用成为一个沉重的负担，导致GC暂停时间明显变长。</p><p>​    如果不修改程序仅从GC调优角度去解决这个问题，可以考虑将Survivor空间去掉（通过参数），让新生代中存活的对象在第一次Minor GC后立即进入老年代，等到Major GC的时候再清理他们。这种措施治标不治本，治本的话需要修改程序，因为产生这种情况的根本原因是HashMap&lt;Long, Long&gt; 结构来存储数据文件空间效率太低。</p><h5 id="5-2-7-由Windows虚拟内存导致的长时间停顿"><a href="#5-2-7-由Windows虚拟内存导致的长时间停顿" class="headerlink" title="5.2.7 由Windows虚拟内存导致的长时间停顿"></a>5.2.7 由Windows虚拟内存导致的长时间停顿</h5><p>​    例子：带心跳检测功能的GUI桌面程序，每15秒发送一次心跳检测信号，若30秒内没收到返回信息，就认为和对方程序的连接已经断开。程序上线后发现检测有误报的概率，查询日志发现原因是程序偶尔出现间隔一分钟左右的时间完全无日志输出，处于停顿状态。</p><p>​    从GC日志文件中确认了停顿原因是由GC导致的，偶尔会出现一次接近一分钟的GC。从日志片段中可以看出，真正执行GC动作的时间不是很长，但从准备开始GC，到真正开始GC之间所消耗的时间却占了绝大多数。[Times：<strong>user=0.61 sys=0.52</strong>，real=31.16 secs]可以看出。</p><p>​    除GC日志之外，还观察到这个GUI程序内存变化的一个特点，当它最小化的时候资源管理显示的占用内存大幅度减小，但是虚拟内存则没有变化，因此怀疑程序最小化时工作内存被交换到了磁盘的页面文件之中，这样发生GC时就有可能因为恢复页面而导致不正常的GC停顿，可以通过参数来解决（保证程序在最小化时能立即响应）。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过案例来分析Java部署中相关的优化措施。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://yehengchao.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://yehengchao.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机性能监控与故障处理工具</title>
    <link href="http://yehengchao.cn/2018/06/20/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://yehengchao.cn/2018/06/20/虚拟机性能监控与故障处理工具/</id>
    <published>2018-06-20T01:52:46.000Z</published>
    <updated>2018-07-02T01:11:01.839Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JDK工具使用：主要记录一些JDK工具使用，包括内存监视和快照生成查看等一系列可视化工具。&lt;未完待续&gt;</p></blockquote><a id="more"></a><h4 id="4-2-JDK的命令行工具"><a href="#4-2-JDK的命令行工具" class="headerlink" title="4.2 JDK的命令行工具"></a>4.2 JDK的命令行工具</h4><!-- more --><h5 id="4-2-1-jps：虚拟机进程状况工具"><a href="#4-2-1-jps：虚拟机进程状况工具" class="headerlink" title="4.2.1 jps：虚拟机进程状况工具"></a>4.2.1 jps：虚拟机进程状况工具</h5><p>​    其功能和UNIX中的ps命令相似：列出正在进行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称及进程的本地虚拟机唯一ID(LVMID)。</p><h5 id="4-2-2-jstat：虚拟机统计信息监视工具"><a href="#4-2-2-jstat：虚拟机统计信息监视工具" class="headerlink" title="4.2.2 jstat：虚拟机统计信息监视工具"></a>4.2.2 jstat：虚拟机统计信息监视工具</h5><p>​    用于监视虚拟机各种运行状态信息的命令行工具，可以显示远程或者本地虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p><h5 id="4-2-3-jinfo：Java配置信息工具"><a href="#4-2-3-jinfo：Java配置信息工具" class="headerlink" title="4.2.3 jinfo：Java配置信息工具"></a>4.2.3 jinfo：Java配置信息工具</h5><p>​    该工具可以实时地查看和调整虚拟机各项参数。</p><h5 id="4-2-4-jmap：Java内存映像工具"><a href="#4-2-4-jmap：Java内存映像工具" class="headerlink" title="4.2.4 jmap：Java内存映像工具"></a>4.2.4 jmap：Java内存映像工具</h5><p>​    该命令用于生成堆转储快照（称为dump文件）。</p><h5 id="4-2-5-jhat：虚拟机堆转储快照分析工具"><a href="#4-2-5-jhat：虚拟机堆转储快照分析工具" class="headerlink" title="4.2.5 jhat：虚拟机堆转储快照分析工具"></a>4.2.5 jhat：虚拟机堆转储快照分析工具</h5><p>​    该命令与jmap搭配使用，来分析jmap生成的dump文件，不过实际上一般不会直接使用jhat来分析dump文件，两个原因：1. 一般不在部署应用的服务器上直接分析dump，即使这样做也会尽量将dump复制到其他机器上分析；2. jhat分析功能比较简陋，还有其他强大的工具可以选择。</p><h5 id="4-2-6-jstack：Java堆栈跟踪工具"><a href="#4-2-6-jstack：Java堆栈跟踪工具" class="headerlink" title="4.2.6 jstack：Java堆栈跟踪工具"></a>4.2.6 jstack：Java堆栈跟踪工具</h5><p>​    该命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。其主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。</p><h5 id="4-2-7-HSDIS：JIT生成代码反汇编"><a href="#4-2-7-HSDIS：JIT生成代码反汇编" class="headerlink" title="4.2.7 HSDIS：JIT生成代码反汇编"></a>4.2.7 HSDIS：JIT生成代码反汇编</h5><p>​    将本地代码还原为汇编代码输出（没成功）。</p><h4 id="4-3-JDK的可视化工具"><a href="#4-3-JDK的可视化工具" class="headerlink" title="4.3 JDK的可视化工具"></a>4.3 JDK的可视化工具</h4><h5 id="4-3-1-JConsole：Java监视与管理控制台"><a href="#4-3-1-JConsole：Java监视与管理控制台" class="headerlink" title="4.3.1 JConsole：Java监视与管理控制台"></a>4.3.1 JConsole：Java监视与管理控制台</h5><p>​        </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;JDK工具使用：主要记录一些JDK工具使用，包括内存监视和快照生成查看等一系列可视化工具。&amp;lt;未完待续&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://yehengchao.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://yehengchao.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集和内存分配</title>
    <link href="http://yehengchao.cn/2018/06/20/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>http://yehengchao.cn/2018/06/20/垃圾收集和内存分配/</id>
    <published>2018-06-20T01:51:44.000Z</published>
    <updated>2018-07-02T01:08:33.763Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于Java虚拟机GC垃圾收集机制，主要介绍了不同区域所使用的垃圾收集算法，以及他们的结合种类、适用场景。</p></blockquote><a id="more"></a><h4 id="3-4-HotSpot算法实现"><a href="#3-4-HotSpot算法实现" class="headerlink" title="3.4 HotSpot算法实现"></a>3.4 HotSpot算法实现</h4><h5 id="3-4-2-安全点"><a href="#3-4-2-安全点" class="headerlink" title="3.4.2  安全点"></a>3.4.2  安全点</h5><p>​    JVM通过GC Roots节点来判断某个对象是否可达，但是如果需要逐个检查的话必然会消耗很多时间，所以需要使用一个名为OopMap的数据结构来记录引用位置的信息（如指令流的起始位置，偏移量等）。</p><p>​    在OopMap的帮助下，JVM可以很快的完成GC Roots的枚举，但是这里会出现一个问题：并不是所有的指令都会生成对应的OopMap数据结构，假设如此需要大量的额外空间，导致GC的空间成本将会变得非常高。这里的解决办法是只在“特定位置”记录这些信息，这样的位置称之为安全点（safe point），当线程执行到safe point的时候才会停顿下来开始GC。这里的safe point选定不能太少也不能太多，太少GC等太久，太多增大运行负荷；这里的设置特征为“是否让程序长时间执行的特征”，最明显的特征就是指令序列的复用比如方法调用、循环跳转、异常跳转等位置。</p><p>​    为了让GC发生是所有线程（不包括JNI调用的线程）都能在最近的安全点停下来，有两种方法：抢先式中断和主动式中断。抢先式：GC发生时，中断所有线程，发现不在安全点的就恢复它使之跑到安全点上（目前几乎不用，不详细表）；主动式：GC发生时，不直接操作线程仅设置一个标志，各个线程在执行的时候主动去轮询这个标志，为真时自动挂起（轮询标志和安全点是重合的）。</p><h5 id="3-4-3-安全区域"><a href="#3-4-3-安全区域" class="headerlink" title="3.4.3 安全区域"></a>3.4.3 安全区域</h5><p>​    安全区域的设定是为了解决程序“不执行”的时候，即未分配CPU时间，因此线程无法响应JVM的中断请求挂起，典型的例子就是Sleep和Block状态。这时需要设置一个安全区域（safe region），安全区域是安全点的一个很大的扩展，设置原则为引用关系不会发生变化的一段代码片段。在线程离开安全区域之前会检查GC是否完成了根节点的枚举，完成的话继续执行，否则等待知道收到可以安全离开安全区域的信号为止。</p><h4 id="3-5-垃圾收集器"><a href="#3-5-垃圾收集器" class="headerlink" title="3.5 垃圾收集器"></a>3.5 垃圾收集器</h4><h5 id="3-5-1-Serial收集器"><a href="#3-5-1-Serial收集器" class="headerlink" title="3.5.1  Serial收集器"></a>3.5.1  Serial收集器</h5><p>​    Serial是一个最基本、发展最久的收集器，单线程，但不仅仅说明它只会使用一个CPU或者一条线程去完成垃圾收集工作，更重要的是它在收集垃圾时必须暂停其他所有线程直到它结束（Stop The World），虽然不科学但是依然是Client模式下默认新生代收集器，优点：简单高效（没有线程交互的开销，专心收垃圾）。在桌面场景中新生代内存往往不大，所以停顿时间可以控制在几十最多一百多毫秒以内。</p><h5 id="3-5-2-ParNew收集器"><a href="#3-5-2-ParNew收集器" class="headerlink" title="3.5.2 ParNew收集器"></a>3.5.2 ParNew收集器</h5><p>​    其实是Serial的多线程版本，只有它能与CMS收集器配合使用；目前新生代的垃圾收集只能从Serial和ParNew中选择，在单CPU的情况下ParNew不比Serial好（甚至由于线程交互的开销不能超过Serial）,但是随着CPU数量的增加，它对于GC时的系统资源的有效利用还是很有好处的。默认开启的线程数与CPU数量相同，可用参数进行限制。</p><h5 id="3-5-3-Parallel-Scavenge收集器"><a href="#3-5-3-Parallel-Scavenge收集器" class="headerlink" title="3.5.3 Parallel Scavenge收集器"></a>3.5.3 Parallel Scavenge收集器</h5><p>​    Parallel Scavenge的关注点和其他收集器不同，CMS等收集器是尽可能地缩短垃圾收集时用户线程的停顿时间，而该收集器目标时达到一个可控制的吞吐量（吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间））。和ParNew相比他们都是使用的复制算法，又是并行的多线程~ 但是不同的是Parallel Scavenge提供了两个参数用于精确控制吞吐量，分别为控制最大垃圾收集停顿时间参数以及直接设置吞吐量大小参数；停顿时间是虚拟机通过设置吞吐量和新生代空间大小来调整的。还有一个自适应调节策略（虚拟机根据系统情况自己调节）也是和ParNew的一个重要区别。</p><h5 id="3-5-4-Serial-Old收集器"><a href="#3-5-4-Serial-Old收集器" class="headerlink" title="3.5.4 Serial Old收集器"></a>3.5.4 Serial Old收集器</h5><p>​    Serial的老年代版本，垃圾回收算法使用的是标记-整理算法。主要两大用途：jdk1.5以及之前版本中与Parallel Scavenge收集器搭配使用；作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure 时使用。</p><h5 id="3-5-5-Parallel-Old-收集器"><a href="#3-5-5-Parallel-Old-收集器" class="headerlink" title="3.5.5 Parallel Old 收集器"></a>3.5.5 Parallel Old 收集器</h5><p>​    Parallel Scavenge的老年代版本，使用标记-整理算法。jdk1.6之前Parallel Scavenge较尴尬：因为新生代一旦选择Parallel Scavenge，老年代就只能使用Serial Old，所以无法充分利用多CPU的处理能力。后来有了Parallel Old就可以和它组合使用，真正注重吞吐量了。</p><h5 id="3-5-6-CMS收集器"><a href="#3-5-6-CMS收集器" class="headerlink" title="3.5.6 CMS收集器"></a>3.5.6 CMS收集器</h5><p>​    CMS收集器是一种以获取最短回收停顿时间为目标的收集器。基于“标记-清除”算法实现，运作过程分为四个步骤：初始标记，并发标记，重新标记，并发清除。</p><p>​    初始标记：仅仅标记一下GC Roots能直接关联到的对象，速度快但是需要“Stop The World”。</p><p>​    并发标记：进行GC Roots Tracing的过程，能够与用户线程一起工作。</p><p>​    重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，此阶段停顿时间比初始标记阶段时间稍长但是远比并发标记时间短，需要“Stop The World”。具体如何实现，做了什么还不清楚暂时不表。</p><p>​    并发清除：清理未被标记的对象（不可达的），与用户线程一起并发执行。</p><p>​    主要特点：并发收集、低停顿。</p><p>缺点：</p><ol><li><p>对CPU资源非常敏感，虽然不会导致用户线程停顿但是会明显占用CPU资源而导致应用程序变慢，总吞吐量降低。CMS默认启动的回收线程数是（CPU数+3）/ 4 。这样导致用户程序执行速度忽然降低难以接受，所以虚拟机提供了“增量式并发收集器”，模拟操作系统使用抢占式来模拟多任务，使GC线程、用户线程交替运行，这样会使整个垃圾收集时间变长。实践证明这种处理效果一般，不提倡使用。</p></li><li><p>无法处理浮动垃圾，浮动垃圾：由于并发清理阶段用户线程的运行产生新的垃圾，这部分垃圾未被标记导致当前周期无法被处理，需等下一周期。所以CMS不能老年代满了再收集，需要设置一部分空间给应用程序，jdk1.6中将启动阈值提高到了92%。但是用户可以通过参数进行设置，如果预留内存无法满足需要（Concurrent Mode Failure），虚拟机会启动后备预案：临时启动Serial Old来重新进行老年区的垃圾收集，这样停顿时间就会很久。如果启动阈值设置过高，会导致大量的“Concurrent Mode Failure”失败，性能大大降低。</p></li><li><p>这个缺点就是“标记-清除”算法普遍存在的了，收集结束会有大量空间碎片产生，当有大对象时无法找到足够大的连续空间来分配，因此提前触发了一次Full GC。为此CMS收集器提供-XX:+UseCMSCompactAtFullCollection开关参数（默认开），用于在进行Full GC时开启碎片合并整理过程，这样停顿时间变长。虚拟机设计者还提供-XX:CMSFullGCsBeforeCompaction，设置多少次不压缩的Full GC以后来一次带压缩的（默认0）。</p><p>这里有个疑问：既然使用“标记-清除”会导致大量空间碎片产生，那为什么不使用“标记-整理”算法呢？遂一顿搜索发现：原来CMS为了获取最短回收停顿时间而将耗时长的设为并发（并发标记和并发清理），如果在并发时通过整理移动了对象的内存，那么线程就会找不到应用对象在哪里。</p></li></ol><h5 id="3-5-7-G1收集器"><a href="#3-5-7-G1收集器" class="headerlink" title="3.5.7 G1收集器"></a>3.5.7 G1收集器</h5><p>​    G1（Garbage-First）收集器是新出的，面向服务端应用的收集器，有如下特点：1.并行与并发，能充分利用多CPU、多核环境缩短STW的时间；2.分代收集，能够采用不同方式处理不同类型的旧对象；3.空间整合，从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的（没理解）；4.可预测停顿，G1除了追求低停顿外还建立可预测的停顿时间模型，制定M时间片段内收集垃圾时间不能超过N，其原因在于可以有计划地避免在整个堆中进行全区域的垃圾收集，G1跟踪各个Region中垃圾收集的价值（根据获取空间大小和所需时间）维护一个表，每次优先回收价值高的Region。</p><p>​    Region之间不可能是孤立的，不然检测Region之间的对象引用的时候还得扫描整个Java堆导致效率降低。所以每个Region需维护一个Remembered Set记录该Region被引用对象的相关引用信息，在内存回收时加入Remembered Set的扫描即可。</p><p>G1收集器运作步骤：</p><ol><li>初始标记：和CMS一样，该阶段仅标记一下GC Roots能直接关联的对象并修改TAMS。</li><li>并发标记：从GC Root开始对堆中对象进行可达性分析，找出存活对象，该过程耗时久但是可并发操作。</li><li>最终标记：修正并发标记过程中因用户程序运作而导致产生变化的标记记录，虚拟机将其记录在线程Remembered Set Logs中，并在此阶段将其合并到Remembered Set中，可并行。</li><li>筛选标记：首先对各个Region回收价值和成本进行排序，根据用户期望的停顿时间来制定回收计划，可并行，但是停顿用户线程将大幅提高收集效率。</li></ol><h5 id="3-5-8-GC日志"><a href="#3-5-8-GC日志" class="headerlink" title="3.5.8 GC日志"></a>3.5.8 GC日志</h5><h4 id="3-6-内存分配与回收策略"><a href="#3-6-内存分配与回收策略" class="headerlink" title="3.6 内存分配与回收策略"></a>3.6 内存分配与回收策略</h4><h5 id="3-6-1-对象优先在Eden分配"><a href="#3-6-1-对象优先在Eden分配" class="headerlink" title="3.6.1 对象优先在Eden分配"></a>3.6.1 对象优先在Eden分配</h5><p>​    Eden区和Survivor区都属于新生代，而Eden区存放的对象一般都是生命周期不长的对象（因此使用复制算法进行回收）。</p><h5 id="3-6-2大对象直接进入老年代"><a href="#3-6-2大对象直接进入老年代" class="headerlink" title="3.6.2大对象直接进入老年代"></a>3.6.2大对象直接进入老年代</h5><p>​    所谓大对象指大量连续内存空间的Java对象，最典型的就是很长的字符串以及数组（更坏的消息是遇到一群“朝生夕灭”的“短命大对象”），经常导致内存还有不少就不得不提前触发垃圾收集来获取足够的连续空间来存放他们。可以通过设置-XX:PretenureSizeThreshold参数来设置这个上限值。</p><h5 id="3-6-3-长期存活的对象将进入老年代"><a href="#3-6-3-长期存活的对象将进入老年代" class="headerlink" title="3.6.3 长期存活的对象将进入老年代"></a>3.6.3 长期存活的对象将进入老年代</h5><p>​    通过对象年龄计数器来记录对象，当熬过第一次Minor GC进入Survivor区并将年龄设置为1，接着每熬过一次Minor GC就将年龄加1，当年龄加到一定程度就被晋升入老年代中（默认为15），这个年龄阈值可以通过-XX:MaxTenuringThreshold参数设置。</p><h5 id="3-6-4-动态对象年龄判断"><a href="#3-6-4-动态对象年龄判断" class="headerlink" title="3.6.4 动态对象年龄判断"></a>3.6.4 动态对象年龄判断</h5><p>​    虚拟机并不是永远要求对象年龄达到阈值才晋升老年代的，如果在Survivor中相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就直接进入老年代无需等到要求的阈值年龄了。</p><h5 id="3-6-5-空间分配担保"><a href="#3-6-5-空间分配担保" class="headerlink" title="3.6.5 空间分配担保"></a>3.6.5 空间分配担保</h5><p>​    在发生Minor GC前，虚拟机会检查老年代最大连续可用空间是否大于新生代所有对象总空间，如成立则此次Minor GC是安全的。如不成立，虚拟机检查是否允许担保失败（HandlePromotionFailure参数），若允许则检查老年代最大可用连续空间是否大于历次晋升到老年代对象平均大小，若大于则进行一次有风险的Minor GC，若小于或者设置为不允许担保失败，则进行一次Full GC。</p><p>​    JDK 6 update 24以后规则发生了更改，即不管HandlePromotionFailure参数如何设置，代码中都不会使用它，规则变为只要老年代连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关于Java虚拟机GC垃圾收集机制，主要介绍了不同区域所使用的垃圾收集算法，以及他们的结合种类、适用场景。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://yehengchao.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://yehengchao.cn/tags/jvm/"/>
    
      <category term="gc" scheme="http://yehengchao.cn/tags/gc/"/>
    
  </entry>
  
</feed>
