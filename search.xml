<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Session和Cookie]]></title>
    <url>%2F2018%2F08%2F07%2FSession%E5%92%8CCookie%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈观察者模式]]></title>
    <url>%2F2018%2F08%2F01%2F%E6%B5%85%E8%B0%88%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之观察者模式 概述观察者模式平时经常能听到，也是JDK中使用最多的模式之一，它可以帮你的对象知悉现况，不会错过该对象感兴趣的事。对象甚至在运行时可决定是否要继续被通知。 例子首先举一个应用场景的例子来引出为什么需要使用观察者模式。 场景： 团队刚刚和气象公司建立了项目合作关系，为气象公司建立下一代Internet气象观测站，该气象站必须建立在专利申请中的WeatherData对象上，由该对象负责追踪目前的天气情况（温度、湿度、气压）。我们的任务是建立一个应用，有三种布告板，分别显示目前的状况、气象统计及简单的预报。当WeatherData对象获得最新的数据更新时，三种布告板必须实时更新。 而且这是一个可以扩展的气象站，合作方希望可以公布一组API，好让其他开发人员可以写出自己的气象布告板，并插入此应用中。 这里的WeatherData类中涉及到的方法如下所示： 12345678910class WeatherData&#123; getTemperature(); // 返回温度的方法。 getHumidity(); // 返回湿度的方法。 getPressure(); // 返回气压的方法。 /* *一旦气象测试更新，此方法会被调用。 */ measurementsChanged();&#125; 我们的主要目标是实现measurementsChanged()方法，好让它更新目前的状况、气象统计、天气预报的显示布告板。 认识观察者模式首先看看报纸和杂志的订阅是怎么发生的： 报社的业务就是出版报纸。 向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户就会一直收到新的报纸。 当你不想看报纸的时候，取消订阅，他们就不会再送新报纸过来了。 只要报社还在运营，就会一直有人向他们订阅报纸或者取消订阅报纸。 将这个例子映射到观察者模式中，出版者改称为“主题”，订阅者改称为“观察者”。主题对象的数据一旦发生改变，新的数据会以某种形式送到观察者手上。相反不是观察者的话，主题数据改变时就不会收到通知。 定义观察者模式观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变时，他的所有依赖者都会收到通知并自动更新。 观察者模式提供了一种对象的设计，让主题和观察者之间松耦合 关于观察者的一切，主题只知道观察者实现了某个接口（也就是Observer接口）。主题不需要知道观察者的具体类是谁、做了些什么或其他任何细节。 任何时候都可以增加新的观察者。因为主题唯一依赖的东西是一个实现Observer接口的对象列表，所以随时可以增加观察者。事实上在运行时可以用新的观察者取代现有的观察者，主题不会受到任何影响。同样也可以在任何时候删除某些观察者。 新类型观察者出现主题的代码不需要修改。假如有个新的具体类需要当观察者，不需要为了兼容新类型而修改主题的代码，所有要做的就是在新的类里实现此观察者接口，然后注册为观察者即可。主题不在乎别的，只会发送通知给所有实现了观察者接口的对象。 可以独立地复用主题或观察者。如果在其他地方需要使用主题或者观察者，可以轻易地复用，因为二者并非紧耦合。 改变主题或者观察者一方，并不会影响另一方。因为两者都是松耦合的，只要他们之间的接口仍被遵循，就可以自由地改变他们。 所以这里就要引出又一个设计原则：为了交互对象之间地松耦合设计而努力。 实现气象站根据上述讨论，需要开始对整个系统的实现了，Java中内置了为观察者模式的支持，但是这里暂时不使用而是自己来实现它。 首先建立接口 12345678910111213public interface Subject &#123; public void registerObserver(Observer o); // 该方法需要一个观察者作为变量，该观察者用来注册 public void removeObserver(Observer o); // 同上，该观察者用来删除 public void notifyObservers(); // 当主题状态发生改变时，该方法被调用，通知所有观察者对象。&#125;public interface Observer &#123; public void update(float temp, float humidity, float pressure); // 所有观察者必须实现该方法。&#125;public interface DisplayElement &#123; public void display(); // 布告板需要显示时，调用此方法。&#125; 在WeatherData中实现主题接口123456789101112131415161718192021222324252627282930313233343536373839public class WeatherData implements Subject &#123; private ArrayList observers; private float temperature; private float huminity; private float pressure; public WeatherData() &#123; observers = new ArrayList(); // 用来记录观察者。 &#125; public void registerObserver(Observer o) &#123; // 注册观察者 observers.add(o); &#125; public void removeObserver(Observer o) &#123; // 删除观察者 int i = observers.indexOf(o); if(i &gt;= 0)&#123; observers.remove(i); &#125; &#125; public void notifyObservers() &#123; // 将发生改变的值告诉每一个观察者。 for (int i = 0; i&lt;observers.size(); i++)&#123; Observer observer = (Observer) observers.get(i); observer.update(temperature, humidity, pressure); &#125; &#125; public void measurementsChanged() &#123; // 当观测值发生改变时，调用该方法通知观察者。 notifyObservers(); &#125; public void setMeasurements(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); &#125;&#125; 实现布告板 1234567891011121314151617181920public class CurrentConditionsDisplay implements Observser, DisplayElement &#123; private float temperature; private float humidity; private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData) &#123; //构造器需要weatherData作为注册用，保存引用方便可能取消注册。 this.weatherData = weatherData; weatherData.registerObserver(this); &#125; public void update(float temperature, float humidity, float pressure) &#123; // 保存参数，调用display()。 this.temperature = temperature; this.humidity = humidity; displsy(); &#125; public void display() &#123; System.out.print(); &#125;&#125; 存在的问题按照上述做法会有一个问题，主题老是向观察者推送每一条更新，但不是所有观察者都对所有更新感兴趣，所以还存在另外一种模式，即主题提供getter方法，让观察者主动向其索取数据。 Java也内置了观察者模式的支持，只需要实现或者继承Observable(类)、或者Observer(接口)就好了。接下来利用内置的支持重做气象站。 首先将WeatherData改成使用Observable 1234567891011121314151617181920212223public class WeatherData extends Observable &#123; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; // 构造器不再需要为了记住观察者们而建立数据结构了。 &#125; public void measurementsChanged() &#123; setChanged(); // 调用该方法表示状态已改变。 notifyObservers(); // 不使用该方法传数据，说明使用get的形式。（因为里面调用update） &#125; public void setMeasurements(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); &#125; // 省略一系列getter方法。&#125; 不要依赖于观察者被通知的次序。因为Observable实现了他的notifyObservers()方法，导致通知者次序可能和自己实现的不一样。 java.util.Observable的黑暗面这里JDK中的Observable是一个类，甚至没有实现一个接口。从之前说过的设计原则中得知这并不是一件好事情。 首先，因为它是一个类，必须设计一个类来继承它。如果某一个类想同时具有Observable类和另一个超类的行为，就会陷入两难，因为Java不支持多重继承。限制了Observable的复用潜力。 再者，因为没有Observable接口，所以无法建立自己的实现，和内置的Observer API搭配使用 ，也无法将这个实现用另一种方法实现：如Observable将关键方法保护起来，如setChanged()（定义成了protected）。意味着：除非你继承Observable，否则无法创建Observable实例并组合到自己的对象中来。这个设计违反了 “多用组合，少用继承”原则。 JDK中还有很多地方都是用了观察者模式~]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈策略模式]]></title>
    <url>%2F2018%2F07%2F25%2F%E6%B5%85%E8%B0%88%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之策略模式 首先，给出策略模式的定义：策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式可以让算法的变化独立于使用算法的客户。 例子为了引出为什么使用策略模式，先说说不用这个模式之前是怎么做的。从简单的模拟鸭子应用开始，首先需要设计一套模拟鸭子的游戏，游戏中会出现各种类型的鸭子，一边游泳戏水，一边呱呱叫。系统内部使用标准的OO技术，设计了一个鸭子超类（SuperClass），并让各种鸭子继承超类。 123456789101112131415class Duck&#123; void quack(); void swim(); void display();&#125;class MallardDuck extends Duck&#123; void display()&#123; //外观是绿头 &#125;&#125;class RedheadDuck extends Duck&#123; void display()&#123; //外观是红头 &#125;&#125; 然后公司因为竞争压力巨大。客户需要改需求了，他们说要让鸭子会飞；主管也表示会飞的鸭子来将竞争者抛在后头。所以这个时候首先想到最直观的方法当然就是直接在超类中添加飞的方法： 123456class Duck&#123; void quack(); void swim(); void display(); void fly();&#125; 但是这样一来问题出现了，一些本来不应该会飞的鸭子也在空中飞来飞去了，比如之前继承超类实现的橡皮鸭。直接在超类中加上新的行为会使得某些并不适合该行为的子类也具有该行为。 分开变化和不变的部分所以这里提出了第一个设计原则：找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。 意思就是说如果每次新的需求一来，都会使某方面的代码发生变化，那就可以确定这部分代码需要被抽离出来，和其他稳定的代码有所区分。 换个思考方式：把会变化的部分取出来并封装起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分。 所以这里以鸭子为例，把变化的和不变化的部分分开来，就目前所知除了fly()和quack()的问题之外，其他行为还算正常，没有特别需要改变的地方。所以现在准备建立两组类（完全远离Duck类），一个是“fly”相关的，一个是“quack”相关的，每组类将实现各自的动作。比如叫声不一样实现“呱呱叫”、“吱吱叫”、“安静不叫”。 设计鸭子的行为那我们如何设计实现飞行和呱呱叫的行为类呢？我们希望一切能有弹性，我们想能够“指定”行为到鸭子的实例。比如，想要产生一个新的绿头鸭的示例，并指定特定“类型”的飞行行为给他。干脆顺便让鸭子的行为可以动态地改变好了。 所以这里提出了第二个设计原则：针对接口编程，而不死针对实现编程。 利用接口代表每个行为，比如FlyBehavior与QuackBehavior，而行为的实现都将实现其中的一个接口。所以鸭子类不会负责实现Flying与Quacking接口，反而制造一组其他类专门实现这两个行为。 所以新的设计中，鸭子的子类将使用接口（FlyBehavior与QuackBehavior）所表示的行为，实际的“实现”不会被绑死在鸭子的子类中。 这里所说的针对接口编程的接口并不是一定要用到Java的interface构造，其关键在于多态。利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上（向上转型）。举个例子： 针对实现编程： 12Dog d = new Dog();d.bark(); 但是，针对接口/超类型编程： 1234567891011121314151617class Animal&#123; void makeSound();&#125;class Dog extends Animal&#123; void makeSound()&#123; bark(); &#125; void bark();&#125;class Cat extends Animal&#123; void makeSound()&#123; meow(); &#125; void meow();&#125;Animal animal = new Dog();animal.makeSound(); 这样做的好处就是，子类的实例化动作不再需要在代码中硬编码，例如 new Dog() ，而是在运行是才指定具体的实现的对象。 鸭子的行为所以为了将鸭子的叫和飞这两种行为分离开来，实现了两个接口：FlyBehavior和QuackBehavior，还有他们对应的类： 12345678910111213interface FlyBehavior&#123; void fly();&#125;class FlyWithWings implements FlyBehavior&#123; void fly()&#123; //实现鸭子飞行 &#125;&#125;class FlyNoway implements FlyBehavior&#123; void fly()&#123; //什么都不做，不会飞 &#125;&#125; 123456789101112131415161718interface QuackBehavior&#123; void quack();&#125;class Quack implements QuackBehavior&#123; void quack()&#123; //实现鸭子呱呱叫 &#125;&#125;class Squeak implements QuackBehavior&#123; void quack()&#123; //橡皮鸭子吱吱叫 &#125;&#125;class MuteQuack implements QuackBehavior&#123; void quack()&#123; //什么都不做，不会叫 &#125;&#125; 这样的设计，可以让飞行和呱呱叫的动作被其他对象复用，因为这些行为已经和鸭子类无关了。而可以新增一些行为，不会影响到既有的行为类，也不会影响“使用”到飞行行为的鸭子类。有了继承的好处，却没有继承所带来的包袱。 整合鸭子行为这样做的关键在于，鸭子现在将飞行和呱呱叫的动作“委托”给别人处理，而不是使用定义在Duck()类（或子类）内的呱呱叫和飞行方法。 首先，在Duck类中加入两个示例变量，分别为“flyBehavior”与“quackBehavior”，声明为接口类型，每个鸭子对象动态的设置这样变量以在运行时引用正确的行为类型（FlyWithWings、Squeak等）。 然后实现表现类： 1234567class Duck &#123; QuackBehavior quckBehavior; //其他省略 void performQuack()&#123; quckBehavior.quack(); &#125;&#125; 最后设定flyBehavior与quackBehavior的实例对象。以MallardDuck为例： 12345678910class MallardDuck extends Duck &#123; public MallardDuck()&#123; quckBehavior = new Quack(); flyBehavior = new FlyWithWings(); &#125; void display()&#123; //绿头鸭 &#125;&#125; 动态设定行为假设在鸭子类中通过设定方法（setter method）来设定鸭子的行为，而不是在鸭子的构造器内部实例化。 在Duck类中加入下面方法： 123456void setFlyBehavior(FlyBehavior fb) &#123; flyBehavior = fb;&#125;void setQuackBehavior(QuackBehavior qb) &#123; quackBehavior = qb;&#125; 这样一来就可以随时调用这两个方法改变鸭子的行为。 比如，一开始制造一个新的鸭子类型，是不会飞的：模型鸭（ModelDuck） 123456789class ModelDuck extends Duck &#123; public ModelDuck() &#123; flyBehavior = new FlyNoWay(); quackBehavior = new Quack(); &#125; void display()&#123; //xxxxxx &#125;&#125; 此时建立一个新的飞行方式，火箭。。（FlyRocketPowered）： 12345class FlyRocketPowered implements FlyBehavior &#123; void fly() &#123; //火箭飞行 &#125;&#125; 然后使用setter方法将该飞行模式加到模型鸭上去，使其具有火煎动力： 12Duck model = new ModelDuck();model.setFlyBehavior(new FlyRocketPowered()); “有一个”的关系上面的例子每一个鸭子都有一个FlyBehavior和一个QuackBehavior，好将飞行和叫委托给他们代为处理。这种将两个类结合起来使用的方式就是组合，这种做法和继承的不同之处在于：鸭子的行为不是继承来的，而是和适当的行为对象组合来的。 这里有一个很重要的设计原则：多用组合，少用继承。 使用组合建立系统具有很大的弹性，不仅可以将算法封装成类，更可以“在运行时动态地改变行为”，只要组合的行为对象符合正确的接口标准即可。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC基础]]></title>
    <url>%2F2018%2F07%2F03%2FSpringMVC%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[&lt;未完待续 &gt; SpringMVC概述​ 首先说说什么是MVC，它和三层架构的关系： MVC：Model + View + Controller (数据模型+视图+控制器)。 三层架构：Presentation tier + Application tier + Data tier (展现层+应用层+数据访问层)。 ​ 实际上MVC只存在三层架构的展现层，M是数据模型，是包含数据的对象 。在SpringMVC里有一个专门的类叫Model，用来和V之间进行数据交互、传值；V指的是视图页面，包含JSP、freeMarker、Velocity、Thymeleaf、Tile等；C是控制器(SpringMVC的注解@Controller的类)。 ​ 而三层架构是整个应用的架构，是由Spring框架负责管理的。一般项目结构中都有Service层、DAO层，这两个反馈在应用层和数据访问层。 SpringMVC的常用注解SpringMVC常用以下几个注解： @Controller ​ 该注解在类上，表明这个类是Spring MVC里的Controller，将其声明为Spring的一个Bean，Dispatcher Servlet会自动扫描注解了此注解的类，将Web请求映射到注解了@RequestMapping的方法上。在声明普通Bean的时候，使用@Component、@Service、@Repository和@Controller是等同的，因为后面三个都组合了@Component元注解；但在Spring MVC声明控制器Bean的时候只能使用@Controller。 @RequestMapping ​ 该注解是用来映射Web请求(访问路径和参数)、处理类和方法的。@RequestMapping可注解在类和方法上。注解在方法上的@RequestMapping路径会继承注解在类上的路径，@RequestMapping支持Servlet的request和response作为参数，也支持对request和response的媒体类型进行配置。 @ResponseBody ​ 该注解支持将返回值放在response体内，而不是返回一个页面。在很多基于Ajax的程序的时候，可以以此注解返回数据而不是页面；此注解可放置在返回值前或者方法上。 @RequestBody ​ 该注解允许request的参数在request体中，而不是直接链接在地址后面。此注解放置在参数前。 @PathVariable ​ 该注解用来接收路径参数，如/news/001，可接收001作为参数，此注解放置在参数前。 @RestController 该注解是一个组合注解，组合了@Controller和@ResponseBody，所以在只开发一个和页面交互数据的控制时，需要使用此注解。若没有此注解，想要实现上述功能，则需要在代码中加@Controller和@ResponseBody两个注解。 接下来实现一个各种注解使用的示例。 首先在pom.xml添加jackson依赖，获得对象和json或xml之间的转换： 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt;&lt;/dependency&gt; 然后实现用来演示获取request对象参数和返回此对象到response： 1234567891011121314151617181920212223242526272829303132package cn.yhc.highlight_springmvc4.domain;public class DemoObj &#123; private Long id; private String name; public DemoObj()&#123; //jackson对对象和json做转换时需要此空构造。 super(); &#125; public DemoObj(Long id, String name)&#123; super(); this.id = id; this.name = name; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 注解演示控制器： 123456789101112131415161718192021222324252627282930313233343536373839package cn.yhc.highlight_springmvc4.web.ch4_3;import cn.yhc.highlight_springmvc4.domain.DemoObj;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;@Controller //注解声明此类是一个控制器@RequestMapping("/anno") //映射此类的访问路径是/anno。public class DemoAnnoController &#123; @RequestMapping(produces = "text/plain;charset=UTF-8") //方法未标注路径，因此使用类级别的路径/anno，produces参数定制返回的response媒体类型和字符集。 public @ResponseBody String index(HttpServletRequest request)&#123; //演示可接受HttpServletRequest作为参数，也可接受HttpServletResponse作为参数；@ResponseBody注解用在返回值前面。 return "url:" + request.getRequestURL() + "can access"; &#125; @RequestMapping(value = "/pathvar/&#123;str&#125;", produces = "text/plain;charset=UTF-8") //演示接受路径参数，在方法参数前结合@PathVariable使用。 public @ResponseBody String demoPathVar(@PathVariable String str, HttpServletRequest request)&#123; return "url:" + request.getRequestURL() + "can access, str: " + str; &#125; @RequestMapping(value = "requestParam", produces = "text/plain;charset=UTF-8") //演示常规的request参数获取，访问路径为/anno/requestParam?id=1。 public @ResponseBody String passRequestParam(Long id, HttpServletRequest request)&#123; return "url:" + request.getRequestURL() + " can access, id: " + id; &#125; @RequestMapping(value = "/obj", produces = "application/json;charset=UTF-8") //演示解释参数到对象，访问路径为/anno/obj?id=1&amp;name=xxx。 @ResponseBody //该注解也可以用在方法上。 public String passObj(DemoObj obj, HttpServletRequest request)&#123; return "url: " + request.getRequestURL() + "can access, obj id: " + obj.getId() + "obj name: " + obj.getName(); &#125; @RequestMapping(value = &#123;"/name1", "/name2"&#125;, produces = "text/plain;charset=UTF-8") //演示映射不同路径到相同的方法上，访问路径为/anno/name1，/anno/name2。 public @ResponseBody String remove(HttpServletRequest request)&#123; return "url: " + request.getRequestURL() + "can access"; &#125;&#125; 上面提到也可以使用@RestController注解进行演示： 12345678910111213141516171819package cn.yhc.highlight_springmvc4.web.ch4_3;import cn.yhc.highlight_springmvc4.domain.DemoObj;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController //该注解声明是控制器，并且返回数据时不需要@ResponseBody。@RequestMapping("/rest")public class DemoRestController &#123; @RequestMapping(value = "/getjson",produces = &#123;"application/json;charset=UTF-8"&#125;) //返回数据的媒体类型为json。 public DemoObj getjson(DemoObj obj)&#123; return new DemoObj(obj.getId()+1, obj.getName()+"yyy"); //直接返回对象，对象会自动转换成json。 &#125; @RequestMapping(value = "/getxml", produces = &#123;"application/xml;charset=UTF-8"&#125;) //返回数据的媒体类型为xml。 public DemoObj getxml(DemoObj obj)&#123; return new DemoObj(obj.getId()+1, obj.getName()+"yyy"); //直接返回对象，对象会自动转换成xml。 &#125;&#125; 最后运行项目，对部分实现进行验证： Spring MVC基本配置​ Spring MVC的定制配置需要继承WebMvcConfigurerAdapter类，并在此类使用@EnableWebMvc注解，来开启对Spring MVC的配置支持，这样就可以重写这个类的方法，完成常用配置。 首先，将刚才的配置类继承WebMvcConfigurerAdapter类： 1234567891011121314151617181920212223242526272829303132package cn.yhc.highlight_springmvc4;import cn.yhc.highlight_springmvc4.interceptor.DemoInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import org.springframework.web.servlet.view.InternalResourceViewResolver;import org.springframework.web.servlet.view.JstlView;@Configuration@EnableWebMvc // 开启SpringMVC支持，若无此句，重写WebMvcConfigurerAdapter方法无效。@ComponentScan("cn.yhc.highlight_springmvc4")public class MyMvcConfig extends WebMvcConfigurerAdapter &#123; // 继承WebMvcConfigurerAdapter类，重写其方法可对Spring MVC进行配置。 @Bean public InternalResourceViewResolver viewResolver()&#123; InternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); viewResolver.setPrefix("/WEB-INF/classes/views/"); viewResolver.setSuffix(".jsp"); viewResolver.setViewClass(JstlView.class); return viewResolver; &#125; @Override public void addResourceHandlers(ResourceHandlerRegistry registry)&#123; registry.addResourceHandler("/assets/**").addResourceLocations("classpath:/assets/"); // addResourceLocations指文件放置的目录，addResourceHandler指对外暴露的访问路径。 &#125;&#125; 拦截器配置​ 拦截器(Interceptor)实现对每个请求处理前后进行相关的业务处理，类似Servlet的Filter。可以让普通的Bean实现HandlerInterceptor接口或者继承HandlerInterceptorAdapter类来实现自定义拦截器，然后通过重写WebMvcConfigurerAdapter配置类的addInterceptors方法来注册自定义拦截器。解析来演示一个简单的拦截器的开发和配置，计算每一次请求的处理时间。 示例拦截器： 1234567891011121314151617181920212223242526package cn.yhc.highlight_springmvc4.interceptor;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class DemoInterceptor extends HandlerInterceptorAdapter &#123; //继承HandlerInterceptorAdapter来实现自定义拦截器。 @Override //重写preHandle方法，在请求发生前执行。 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception&#123; long startTime = System.currentTimeMillis(); request.setAttribute("startTime", startTime); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception&#123; long startTime = (long)request.getAttribute("startTime"); request.removeAttribute("startTime"); long endTime = System.currentTimeMillis(); System.out.println("本次请求处理时间为：" + new Long(endTime-startTime)+"ms"); request.setAttribute("handlingTime", endTime - startTime); &#125;&#125; 在配置类中增加重写的addInterceptors方法： 123456789@Bean //配置拦截器的Bean public DemoInterceptor demoInterceptor()&#123; return new DemoInterceptor(); &#125; @Override public void addInterceptors(InterceptorRegistry registry)&#123; // 重写addInterceptors方法注册拦截器。 registry.addInterceptor(demoInterceptor()); &#125; 运行结果如下图所示： @ControllerAdvice​ 通过该注解可以将对于控制器的全局配置放在同一个位置，注解了@Controller的类的方法可以使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上，这对所有注解了@RequestMapping的控制器内的方法有效。 @ExceptionHandler：用于全局处理控制器里的异常。 @InitBinder：用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。 @ModelAttribute：该注解本来的作用是绑定键值对到Model中，此处演示让全局的@RequestMapping都能获得在此处设置的键值对。 接下来演示一个使用@ExceptionHandler处理全局异常。 定制ControllerAdvice： 123456789101112131415161718192021222324252627282930package cn.yhc.highlight_springmvc4.advice;import org.springframework.ui.Model;import org.springframework.web.bind.WebDataBinder;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.InitBinder;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.context.request.WebRequest;import org.springframework.web.servlet.ModelAndView;@ControllerAdvice // 声明一个控制器建言，该注解组合了@Component注解，所以自动注册为Spring的Bean。public class ExceptionHandlerAdvice &#123; @ExceptionHandler(value = Exception.class) // @ExceptionHandler在此处定义全局处理，通过该注解的value属性可过滤拦截的条件，在此处我们可以看出拦截的所有Exception public ModelAndView exception(Exception exception, WebRequest request)&#123; ModelAndView modelAndView = new ModelAndView("error"); // error页面 modelAndView.addObject("errorMessage", exception.getMessage()); return modelAndView; &#125; @ModelAttribute // 此处使用该注解将键值对添加到全局，所有注解的@RequestMapping的方法都可获得此键值对。 public void addAttributes(Model model)&#123; model.addAttribute("msg", "额外的信息"); &#125; @InitBinder // 通过该注解定制WebDataBinder public void initBinder(WebDataBinder webDataBinder)&#123; webDataBinder.setDisallowedFields("id"); // 忽略request参数的id。 &#125;&#125; 为了区分之前的控制器，这里新建演示控制器： 1234567891011121314package cn.yhc.highlight_springmvc4.web.ch4_3;import cn.yhc.highlight_springmvc4.domain.DemoObj;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class AdviceController &#123; @RequestMapping("/advice") public String getSomething(@ModelAttribute("msg") String msg, DemoObj obj)&#123; throw new IllegalArgumentException("抱歉，参数有误/" + "来自@ModelAttribute: " + msg); &#125;&#125; 需要一个error.jsp用作异常展示界面： 123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;@ControllerAdvice Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;errorMessage&#125;&lt;/body&gt;&lt;/html&gt; 可以分析一下请求流程，首先运行项目，通过浏览器访问 http://localhost:8080/advice?id=1&amp;name=xx ，可以看到请求参数中有id和name两个，因为在控制建言类中使用了@InitBinder注解定制的initBinder方法，忽略了id这个参数，所以会造成参数有误这个异常。 结果如下图所示： 其他配置]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring高级话题]]></title>
    <url>%2F2018%2F06%2F30%2FSpring%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98%2F</url>
    <content type="text"><![CDATA[主要记录Spring容器中的Bean如何实现Aware接口来对事件进行发布管理，Spring容器通过一个基于线程池的任务执行器来进行异步任务的并发，条件注解的使用，组合注解声明，Enable*注解的原理以及如何进行测试。 Spring Aware​ Spring的依赖注入最大亮点就是所有的Bean 对Spring 容器的存在是没有意识的。即可以将现在的容器换成别的容器，比如 Goole Guice，这时Bean之间的耦合度很低。 ​ 但是实际项目中不可避免的用到Spring 容器本身的功能资源，这时Bean必须意识到Spring 容器的存在，才能调用Spring所提供的资源，这就是Spring Aware。使用了Spring Aware 的话Bean将会和Spring 架构之间耦合。 Spring 提供的Aware接口如图所示： 接口 功能 BeanNameAware 获得容器中Bean的名称 BeanFactoryAware 获得当前 bean factory，这样可以调用容器服务。 ApplicationContextAware* 当前 application context，这样可以调用容器服务。 MessageSourceAware 获得message source，这样可以获得文本信息。 ApplicationEventPublisherAware 应用事件发布器，可以发布事件。 ResourceLoaderAware 获得资源加载器，可以获得外部资源文件 ​ Spring Aware 的目的是为了让Bean获得Spring 容器的服务。因为ApplicationContext接口集成了MessageSource接口、ApplicationEventPublisher接口和ResourceLoader接口，所以Bean 只要继承ApplicationContext就可以获得Spring容器的所有服务，但原则上还是用到什么接口就实现什么接口。 示例，Spring Aware演示的Bean 12345678910111213141516171819202122232425262728293031323334353637package aware;import org.apache.commons.io.IOUtils;import org.springframework.beans.factory.BeanNameAware;import org.springframework.context.ResourceLoaderAware;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;import org.springframework.stereotype.Service;import java.io.IOException;@Servicepublic class AwareService implements BeanNameAware, ResourceLoaderAware &#123; //实现BeanNameAware和ResourceLoaderAware两个接口，获得Bean名称和资源加载的服务。 private String beanName; private ResourceLoader loader; @Override //这里还有下面的注解刚开始出了点小问题，实现接口方法用@Override出现 "@Override is not allowed when implementing interface method" ,[解决办法及原因](https://stackoverflow.com/questions/15402615/override-is-not-allowed-when-implementing-interface-method) public void setResourceLoader(ResourceLoader resourceLoader)&#123; //重写setResource方法。 this.loader = resourceLoader; &#125; @Override public void setBeanName(String name)&#123; //重写setBeanName方法。 this.beanName = name; &#125; public void outputResult()&#123; System.out.println("Bean的名称为：" + beanName); Resource resource = loader.getResource("classpath:aware/test.txt"); try &#123; System.out.println("ResourceLoader加载的文件内容为：" + IOUtils.toString(resource.getInputStream())); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 配置类： 123456789package aware;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan("aware")public class AwareConfig &#123;&#125; 运行： 12345678910111213141516171819package aware;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AwareConfig.class); AwareService awareService = context.getBean(AwareService.class); awareService.outputResult(); context.close(); &#125;&#125;运行结果：Bean的名称为：awareServiceResourceLoader加载的文件内容为：this is a test file 多线程​ Spring 通过任务执行器(TaskExecutor) 来实现多线程和并发编程。使用TaskExecutorConfig 可实现一个基于线程池的TaskExecutor。实际开发中的任务一般是非阻碍的，即异步的，所以需要在配置类中使用@EnableAsync开启对异步任务的支持，并通过在实际执行的Bean方法中使用@Async注解来生命这是一个异步任务。 通过一个示例来进行说明，首先写配置类： 123456789101112131415161718192021222324252627282930package taskexecutor;import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.annotation.AsyncConfigurer;import org.springframework.scheduling.annotation.EnableAsync;import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;import java.util.concurrent.Executor;@Configuration@ComponentScan("taskexecutor")@EnableAsyncpublic class TaskExecutorConfig implements AsyncConfigurer &#123; //配置类实现AsyncConfigurer接口对异常线程池更加细粒度的控制，创建线程自己的线程池。 @Override public Executor getAsyncExecutor()&#123; //重写getAsyncExecutor方法并返回一个ThreadPoolTaskExecutor，这样就获得了一个基于线程池TaskExecutor ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); taskExecutor.setCorePoolSize(5); taskExecutor.setMaxPoolSize(10); taskExecutor.setQueueCapacity(25); taskExecutor.initialize(); return taskExecutor; &#125; @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler()&#123; return null; &#125;&#125; 然后是任务执行类，就是上面所说的Bean： 123456789101112131415161718package taskexecutor;import org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Service;@Servicepublic class AsyncTaskService &#123; @Async //通过该注解表明该方法是个异步方法，如果注解在类级别上，则表明该类所有的方法都是异步方法，这里的方法自动被注入使用ThreadPoolTaskExecutor作为TaskExecutor。 public void executorAsyncTask(Integer i)&#123; System.out.println("执行异步任务： " + i); &#125; @Async //同上 public void executorAsyncTaskPlus(Integer i)&#123; System.out.println("执行异步任务+1： " + (i+1)); &#125;&#125; 运行： 123456789101112131415161718192021222324252627282930313233343536373839package taskexecutor;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(TaskExecutorConfig.class); AsyncTaskService asyncTaskService = context.getBean(AsyncTaskService.class); for(int i = 0; i&lt;10; i++)&#123; asyncTaskService.executorAsyncTask(i); asyncTaskService.executorAsyncTaskPlus(i); &#125; context.close(); &#125;&#125;运行结果如下所示：执行异步任务+1： 1执行异步任务+1： 3执行异步任务： 3执行异步任务+1： 4执行异步任务： 4执行异步任务+1： 5执行异步任务： 5执行异步任务+1： 6执行异步任务： 6执行异步任务+1： 7执行异步任务： 7执行异步任务+1： 8执行异步任务： 8执行异步任务+1： 9执行异步任务： 9执行异步任务+1： 10执行异步任务+1： 2执行异步任务： 2执行异步任务： 0执行异步任务： 1 可以看出运行结果是并发执行而不是顺序执行的。 计划任务​ 从Spring3.1开始，计划任务在Spring中的实现变得非常简单，首先通过在配置类添加注解@EnableScheduling 来开启对计划任务的支持，然后在要执行计划任务的方法上注解@Scheduled，声明这是一个计划任务。通过该注解Spring支持多种类型的计划任务，包含cron、fixDelay、fixRate等。 首先实现计划任务实现类： 12345678910111213141516171819202122package taskscheduler;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Service;import java.text.SimpleDateFormat;import java.util.Date;@Servicepublic class ScheduledTaskService &#123; private static final SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss"); @Scheduled(fixedRate = 5000) //通过@Scheduled声明该方法是计划任务，使用fixedRate设定每隔固定时间5秒执行一次 public void reportCurrentTime()&#123; System.out.println("每隔五秒执行一次 " + dateFormat.format(new Date())); &#125; @Scheduled(cron = "0 50 19 ? * *") //使用cron属性可以按照指定的时间执行。 public void fixTimeExecution()&#123; System.out.println("在指定时间 " + dateFormat.format(new Date()) + "执行"); &#125;&#125; 然后实现配置类，主要是开启对计划任务的支持： 1234567891011package taskscheduler;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.annotation.EnableScheduling;@Configuration@ComponentScan("taskscheduler")@EnableScheduling //使用此注解开启对计划任务的支持。public class TaskSchedulerConfig &#123;&#125; 运行类： 123456789101112131415161718package taskscheduler;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(TaskSchedulerConfig.class); &#125;&#125;运行效果如下图所示：每隔五秒执行一次 19:49:46每隔五秒执行一次 19:49:51每隔五秒执行一次 19:49:56在指定时间 19:50:00执行每隔五秒执行一次 19:50:01每隔五秒执行一次 19:50:06 条件注解@Conditional​ Spring 4提供了一个基于条件的Bean的创建，即使用@Conditional注解，该注解根据满足某一个特定条件创建一个特定的Bean。如当一个jar包在一个类路径下的时候，自动配置一个或多个Bean；或者只有某个Bean被创建才会创建另外一个Bean。 ​ 下面演示一个以不同操作系统为条件，通过实现Condition接口，并重写matches方法来构造判断条件。 首先实现Windows条件的判定： 123456789101112package conditional;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.type.AnnotatedTypeMetadata;public class WindowsCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; return context.getEnvironment().getProperty("os.name").contains("Windows"); &#125;&#125; Linux条件判定： 123456789101112package conditional;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.type.AnnotatedTypeMetadata;public class LinuxCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; return context.getEnvironment().getProperty("os.name").contains("Linux"); &#125;&#125; 定义Service接口： 12345package conditional;public interface ListService &#123; public String showList();&#125; Windows下要创建的Bean： 123456789package conditional;public class WindowsListService implements ListService &#123; @Override public String showList() &#123; return "dir"; &#125;&#125;package conditional; Linux下要创建的Bean： 12345678package conditional;public class LinuxListService implements ListService &#123; @Override public String showList() &#123; return "ls"; &#125;&#125; 配置类： 1234567891011121314151617181920package conditional;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Conditional;import org.springframework.context.annotation.Configuration;@Configurationpublic class ConditionConfig &#123; @Bean @Conditional(WindowsCondition.class) //通过@Conditional注解，符合Windows条件则实例化WindowsListService。 public ListService WindowsListService()&#123; return new WindowsListService(); &#125; @Bean @Conditional(LinuxCondition.class) public ListService LinuxListService()&#123; //同上，实例化LinuxListService。 return LinuxListService(); &#125;&#125; 运行类： 1234567891011121314151617181920package conditional;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConditionConfig.class); ListService listService = context.getBean(ListService.class); System.out.println(context.getEnvironment().getProperty("os.name") + "系统下的列表命令为：" + listService.showList()); &#125;&#125;在Windows下的运行结果：Windows 10系统下的列表命令为：dir打包为jar包，Linux下的运行结果：INFO: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@7cd84586: startup date [Sun Jul 01 21:06:31 CST 2018]; root of context hierarchyLinux系统下的列表命令为：ls 组合注解与元注解​ 从Spring 2开始，为了响应jdk 1.5推出的注解功能，Spring开始大量加入注解来代替xml配置。之前所涉及到的基本上都是元注解，元注解其实就是可以注解到别的注解上的注解，被注解的注解则称为组合注解，组合注解具备注解其上的元注解的功能。下面通过一个自定义的注解实现将@Configuration和@ComponentScan两个注解的组合。 首先实现示例组合注解： 123456789101112131415package annotation;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import java.lang.annotation.*;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configuration //组合@Configuration元注解@ComponentScan //组合@ComponentScan元注解public @interface WiselyConfigration &#123; String[] value() default &#123;&#125;; //覆盖value参数。&#125; 演示服务Bean： 12345678910package annotation;import org.springframework.stereotype.Service;@Servicepublic class DemoService &#123; public void outputResult()&#123; System.out.println("从组合注解获得bean"); &#125;&#125; 加上组合注解的配置类： 1234package annotation;@WiselyConfigration("annotation") //使用自定义的组合注解，代替@Configuration和@ComponentScan。public class DemoConfig &#123;&#125; 运行： 123456789101112131415161718package annotation;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DemoConfig.class); DemoService demoService = context.getBean(DemoService.class); demoService.outputResult(); context.close(); &#125;&#125;运行结果如下：从组合注解获得bean @Enable*注解的工作原理​ 所有的@Enable*注解中都有一个@Import注解，是用来导入配置类的。具体说明可以看这里。 测试​ Spring 通过Spring TestContext Framework对集成测试提供顶级支持，它不依赖特定的测试框架，既可使用Junit、也可使用TestNG。 ​ 基于Maven构建的项目结构默认有关于测试的目录：src/test/java(测试代码)、src/test/resources(测试资源)，区别于src/main/java(项目源码)、src/main/resources(项目资源)。 ​ Spring提供了一个SpringJUnit4ClassRunner类，接下来对该类提供的部分功能进行演示。 首先添加Spring测试的依赖包到Maven： 123456789101112&lt;!-- 单元测试 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 4)Spring test --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 业务代码，在 src/main/java目录下： 1234567891011121314151617package fortest;public class TestBean &#123; private String content; public TestBean(String content)&#123; this.content = content; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 配置类，在 src/main/java目录下： 1234567891011121314151617181920package fortest;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Profile;@Configurationpublic class TestConfig &#123; @Bean @Profile("dev") public TestBean devTestBean()&#123; return new TestBean("from development profile"); &#125; @Bean @Profile("prod") public TestBean prodTestBean()&#123; return new TestBean("from production profile"); &#125;&#125; 测试类，在src/test/java目录下： 123456789101112131415161718192021222324package fortest;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ActiveProfiles;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class) //SpringJUnit4ClassRunner在JUnit环境下提供Spring TestContext Framework的功能。@ContextConfiguration(classes = &#123;TestConfig.class&#125;) //加载配置@ActiveProfiles("prod") //声明活动的profilepublic class DemoBeanIntegrationTests &#123; @Autowired //使用@Autowired注解注入Bean。 private TestBean testBean; @Test //测试代码，使用JUnit的Assert来校验结果是否和预期一样 public void proBeanShouldInject()&#123; String expected = "from production profile"; String actual = testBean.getContent(); Assert.assertEquals(expected, actual); &#125;&#125; 测试效果如下图所示： 接下来将@ActiveProfiles(“prod”)改为@ActiveProfiles(“dev”)，效果如下所示：]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>SpringAware</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring常用配置]]></title>
    <url>%2F2018%2F06%2F26%2FSpring%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[记录Spring中Bean的配置、EL和资源调用、Bean的声明周期、Profile、事件。 Bean的Scope​ Scope描述的是Spring容器如何新建Bean实例的，通过 @Scope 注解来实现，有以下几种： Singleton：一个Spring容器中只有一个Bean的实例，此为Spring的默认配置，全容器共享一个实例。 Prototype：每次调用都新建一个Bean的实例。 Request：Web项目中，给每个http request 新建一个Bean实例。 Session：Web项目中，给每个http session新建一个Bean实例。 GlobalSession：这个只在portal应用中有用，给每个global http session新建一个Bean实例。 singleton 和 prototype 实例： Singleton的Bean： 1234567package scope;import org.springframework.stereotype.Service;@Service //默认为Singleton，相当于Scope("singleton")public class DemoSingletonService &#123;&#125; Prototype的Bean： 123456789package scope;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Service;@Service@Scope("prototype") //声明Scope为Prototypepublic class DemoPrototypeService &#123;&#125; 配置类： 1234567package scope;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan("scope")public class ScopeConfig &#123;&#125; 测试类： 1234567891011121314151617181920212223package scope;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Scope;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ScopeConfig.class); DemoSingletonService s1 = context.getBean(DemoSingletonService.class); DemoSingletonService s2 = context.getBean(DemoSingletonService.class); DemoPrototypeService p1 = context.getBean(DemoPrototypeService.class); DemoPrototypeService p2 = context.getBean(DemoPrototypeService.class); System.out.println("s1与s2是否相等： " + s1.equals(s2)); System.out.println("p1与p2是否相等： " + p1.equals(p2)); &#125;&#125;运行结果为：s1与s2是否相等： truep1与p2是否相等： false Spring EL和资源调用​ Spring EL-Spring 表达式语言支持在xml和注解中使用，类似于JSP的EL表达式，其中涉及调用各种资源包括普通文件、网址、配置文件、系统环境变量等。Spring主要在注解@Value 的参数中使用表达式。本文涉及到的有以下几种情况： 注入普通字符 注入操作系统属性 注入表达式运算结果 注入其他Bean 的属性 注入文件内容 注入网址内容 注入属性文件 示例： 增加commons-io 可简化文件相关操作： 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt;&lt;/dependency&gt; 在包内添加test.txt文件，内容随意~ 在包内添加test.properties资源文件，内容如下： 12book.author=yyyybook.name=xxxx 编辑被注入的Bean： 123456789101112131415161718package el;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;@Servicepublic class DemoService &#123; @Value("其他类的属性") //表示注入普通的字符串 private String another; public String getAnother()&#123; return another; &#125; public void setAnother(String another) &#123; this.another = another; &#125;&#125; 编写演示配置类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package el;import org.apache.commons.io.IOUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;import org.springframework.core.env.Environment;import org.springframework.core.io.Resource;@Configuration@ComponentScan("el")@PropertySource("classpath:el/test.properties") //注入配置文件public class ElConfig &#123; @Value("I Love You!") //注入普通字符串 private String normal; @Value("#&#123;systemProperties.os.name&#125;") //注入操作系统属性 private String osName; @Value("#&#123; T(java.lang.Math).random() * 100.0 &#125;") //注入表达式结果 private String randomNumber; @Value("#&#123;demoService.another&#125;") //注入其他Bean属性 private String fromAnother; @Value("classpath:el/test.txt") //注入文件资源 private Resource testFile; @Value("http://www.baidu.com") //注入网址资源 private Resource testUrl; @Value("$&#123;book.name&#125;") //注入配置文件 private String bookName; @Autowired private Environment environment; @Bean public static PropertySourcesPlaceholderConfigurer propertyConfig()&#123; return new PropertySourcesPlaceholderConfigurer(); &#125; public void outputResource() &#123; try &#123; System.out.println(normal); System.out.println(osName); System.out.println(randomNumber); System.out.println(fromAnother); System.out.println(IOUtils.toString(testFile.getInputStream())); System.out.println(IOUtils.toString(testUrl.getInputStream())); System.out.println(bookName); System.out.println(environment.getProperty("book.author")); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 编写运行类： 1234567891011121314151617181920212223242526272829package el;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ElConfig.class); ElConfig resourceService = context.getBean(ElConfig.class); resourceService.outputResource(); context.close(); &#125;&#125;输出信息：I Love You!Windows 109.515003283753941其他类的属性文本测试&lt;!DOCTYPE html&gt;六月 26, 2018 5:04:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@531d72ca: startup date [Tue Jun 26 17:04:41 CST 2018]; root of context hierarchy&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class="bg s_ipt_wr"&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus&gt;&lt;/span&gt;&lt;span class="bg s_btn_wr"&gt;&lt;input type=submit id=su value=百度一下 class="bg s_btn"&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;新闻&lt;/a&gt; &lt;a href=http://www.hao123.com name=tj_trhao123 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;地图&lt;/a&gt; &lt;a href=http://v.baidu.com name=tj_trvideo class=mnav&gt;视频&lt;/a&gt; &lt;a href=http://tieba.baidu.com name=tj_trtieba class=mnav&gt;贴吧&lt;/a&gt; &lt;noscript&gt; &lt;a href=http://www.baidu.com/bdorz/login.gif?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb&gt;登录&lt;/a&gt; &lt;/noscript&gt; &lt;script&gt;document.write('&lt;a href="http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u='+ encodeURIComponent(window.location.href+ (window.location.search === "" ? "?" : "&amp;")+ "bdorz_come=1")+ '" name="tj_login" class="lb"&gt;登录&lt;/a&gt;');&lt;/script&gt; &lt;a href=//www.baidu.com/more/ name=tj_briicon class=bri style="display: block;"&gt;更多产品&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=ftCon&gt; &lt;div id=ftConw&gt; &lt;p id=lh&gt; &lt;a href=http://home.baidu.com&gt;关于百度&lt;/a&gt; &lt;a href=http://ir.baidu.com&gt;About Baidu&lt;/a&gt; &lt;/p&gt; &lt;p id=cp&gt;&amp;copy;2017&amp;nbsp;Baidu&amp;nbsp;&lt;a href=http://www.baidu.com/duty/&gt;使用百度前必读&lt;/a&gt;&amp;nbsp; &lt;a href=http://jianyi.baidu.com/ class=cp-feedback&gt;意见反馈&lt;/a&gt;&amp;nbsp;京ICP证030173号&amp;nbsp; &lt;img src=//www.baidu.com/img/gs.gif&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;xxxxyyyy Bean 的初始化和销毁​ 在实际开发中，经常会遇到在Bean使用之前和使用之后做些必要的操作，Spring对Bean的生命周期的操作提供了支持，在Java配置和注解配置下提供两种方式： Java配置方式：使用@Bean 的initMethod 和destroyMethod (相当于xml配置的init-method 和 destroy-method)。 注解方式：利用JSR-250的@PostConstruct 和@PreDestroy。 首先在maven配置文件中增加JSR250的支持 12345&lt;dependency&gt; &lt;groupId&gt;javax.annotion&lt;/groupId&gt; &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 使用@Bean 形式的Bean如下： 12345678910111213141516package prepost;public class BeanWayService &#123; //此类不预先声明为Bean，在配置类中手动创建成为Bean public void init()&#123; System.out.println("@Bean-init-method"); &#125; public BeanWayService()&#123; super(); System.out.println("初始化构造函数-BeanWayService"); &#125; public void destroy()&#123; System.out.println("@Bean-destroy-method"); &#125;&#125; 使用JSR250形式的Bean： 123456789101112131415161718192021package prepost;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;public class JSR250WayService &#123; @PostConstruct //在构造函数执行完之后执行 public void init()&#123; System.out.println("jsr250-init-method"); &#125; public JSR250WayService()&#123; super(); System.out.println("初始化构造函数-JSR250WayService"); &#125; @PreDestroy //在Bean销毁之前执行 public void destroy()&#123; System.out.println("jsr250-destroy-method"); &#125;&#125; 配置类： 12345678910111213141516171819package prepost;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan("prepost")public class PrePostConfig &#123; @Bean(initMethod = "init", destroyMethod = "destroy") //initMethod和destroyMethod指定BeanWayService类的init和destroy方法在构造函数之后，Bean销毁之前执行 BeanWayService beanWayService()&#123; return new BeanWayService(); &#125; @Bean //这里因为在JSR250WayService类中的方法已经指定了，所以不用上述那样 JSR250WayService jsr250WayService()&#123; return new JSR250WayService(); &#125;&#125; 测试类： 1234567891011121314151617181920212223package prepost;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(PrePostConfig.class); BeanWayService beanWayService = context.getBean(BeanWayService.class); JSR250WayService jsr250WayService = context.getBean(JSR250WayService.class); context.close(); &#125;&#125;运行结果如下：初始化构造函数-BeanWayService@Bean-init-method初始化构造函数-JSR250WayServicejsr250-init-methodjsr250-destroy-method@Bean-destroy-method Profile使用Profile为在不同的环境下使用不同的配置提供了支持： 通过设定Environment 的ActiveProfiles 来设定当前context 需要使用的环境配置。在开发中使用@Profile 注解类或者方法，达到在不同情况下选择实例化不同的Bean。 通过设定jvm的spring.profile.active参数来设置配置环境。 Web项目设置在Servlet 的context parameter中。（也就是上下文参数） 下面进行简单的代码演示，示例Bean： 1234567891011121314151617package profile;public class DemoBean &#123; private String content; public DemoBean(String content)&#123; super(); this.content = content; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; Profile 配置类： 12345678910111213141516171819package profile;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Profile;@Configurationpublic class ProfileConfig &#123; @Bean @Profile("dev") //Profile为dev时实例化devDemoBean。 public DemoBean devDemoBean()&#123; return new DemoBean("from development profile"); &#125; @Bean @Profile("prod") //Profile为prod时实例化为proDemoBean。 public DemoBean prodDemoBean()&#123; return new DemoBean("from production profile"); &#125;&#125; Main类： 123456789101112131415161718192021222324252627282930313233343536package profile;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.getEnvironment().setActiveProfiles("prod"); //将活动的Profile设置为prod。 context.register(ProfileConfig.class); //后置注册Bean配置类，不然会报Bean未定义的错误。 context.refresh(); DemoBean demoBean = context.getBean(DemoBean.class); System.out.println(demoBean.getContent()); context.close(); &#125;&#125;运行结果为：六月 29, 2018 9:17:42 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@67424e82: startup date [Fri Jun 29 21:17:42 CST 2018]; root of context hierarchyfrom production profile六月 29, 2018 9:17:42 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@67424e82: startup date [Fri Jun 29 21:17:42 CST 2018]; root of context hierarchy如果将 "pro" 改为 "dev" ：六月 29, 2018 9:18:37 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@67424e82: startup date [Fri Jun 29 21:18:37 CST 2018]; root of context hierarchyfrom development profile六月 29, 2018 9:18:37 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@67424e82: startup date [Fri Jun 29 21:18:37 CST 2018]; root of context hierarchy 事件(Application)​ Spring 的事件(Application Event) 为Bean 和 Bean 之间的消息通信提供了支持。当一个Bean 处理完一个任务之后，希望另一个Bean知道并能做出相应的处理，这时我们就能让另一个Bean 监听当前Bean 所发送的事件。(讲到这里，相当了Servlet中也有类似的事件监听，或许是差不多的东西) Spring 实现事件监听流程： 自定义事件，继承ApplicationEvent。 定义事件监听器，实现ApplicationListener。 使用容器发布事件。 首先，自定义事件，为了让消息更加可视化，传入参数msg： 1234567891011121314151617181920package event;import org.springframework.context.ApplicationEvent;public class DemoEvent extends ApplicationEvent &#123; private String msg; public DemoEvent(Object source, String msg)&#123; super(source); this.msg = msg; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; 第二步，实现事件监听器： 12345678910111213package event;import org.springframework.context.ApplicationListener;import org.springframework.stereotype.Component;@Componentpublic class DemoListener implements ApplicationListener&lt;DemoEvent&gt; &#123; //实现ApplicationListener 接口，并且指定监听的事件类型 public void onApplicationEvent(DemoEvent event) &#123; //使用onApplicationEvent 方法对消息进行接受处理。 String msg = event.getMsg(); System.out.println("我(bean-DemoListener)接收到了bean-demoPublisher发布的消息：" + msg); &#125;&#125; 事件发布类： 1234567891011121314package event;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.stereotype.Component;@Componentpublic class DemoPublisher &#123; @Autowired ApplicationContext context; //注入ApplicationContext用来发布事件。 public void publish(String msg)&#123; context.publishEvent(new DemoEvent(this, msg)); //使用publishEvent方法来发布事件。 &#125;&#125; 配置类： 123456789package event;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan("event")public class EventConfig &#123;&#125; 运行函数： 12345678910111213141516171819202122package event;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(EventConfig.class); DemoPublisher demoPublisher = context.getBean(DemoPublisher.class); demoPublisher.publish("hello application event"); context.close(); &#125;&#125;运行结果如下所示：六月 29, 2018 9:56:20 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@67424e82: startup date [Fri Jun 29 21:56:20 CST 2018]; root of context hierarchy我(bean-DemoListener)接收到了bean-demoPublisher发布的消息：hello application event六月 29, 2018 9:56:20 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@67424e82: startup date [Fri Jun 29 21:56:20 CST 2018]; root of context hierarchy 可以看出，DemoListener成功监听到了DemoPublisher发布的事件。]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Bean</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring基础]]></title>
    <url>%2F2018%2F06%2F25%2FSpring%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Spring基础，主要涉及maven的介绍使用，控制反转和依赖注入以及关于(AOP)面向切面编程。 Spring配置方式 xml配置 注解配置 Java配置 Maven简介​ maven是一个软件项目管理工具。基于项目管理对象模型的概念，可用来管理项目的依赖、编译、文档等信息。 ​ 在maven中管理依赖时只需要在配置文件pom.xml中按下面的形式添加就好了。 12345&lt;dependency&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;version&gt;xxx&lt;/version&gt;&lt;/dependency&gt; ​ 添加完成以后maven就会通过互联网在maven中心库下载相关的依赖包到.m2目录下，也是你的本地maven库，如果中心库没有你需要的jar包，需要自己使用maven命令导入到本地maven库。 依赖注入​ 在Spring的概念下，控制翻转和依赖注入是等同的概念，控制翻转是通过依赖注入实现的。依赖注入指容器负责创建对象和维护对象间的依赖关系，而不是通过对象本身负责自己的创建和解决自己的依赖。 ​ 依赖注入的目的是为了解耦，使用“组合”的概念降低类之间的耦合度。Spring IoC容器负责创建Bean，并且通过容器将功能类Bean注入到需要的Bean中。Spring 提供使用xml、注解、Java配置、groovy配置实现Bean的创建和注入。 声明Bean的注解有： @Component 组件，没有明确的角色 @Service 在业务逻辑层(service层)使用 @Respository 在数据访问层(dao层）使用 @Controller 在展现层(MVC - SpringMVC)使用 注入Bean的注解： @Autowired：Spring提供的注解 @Inject：JSR-330提供的注解 @Resource：JSR-250提供的注解 注入Bean的注解可以用在set方法上或者属性上。 配置​ Java配置是现在推荐的方式，主要通过@Configuration 和@Bean 来实现 @Configuration 声明当前类是一个配置类，相当于一个Spring配置的xml文件。 @Bean 注解在方法上，声明当前方法的返回值为一个Bean。 遵循的基本原则是：全局配置使用Java配置(如数据库相关配置、maven相关配置)，业务Bean的配置使用注解配置。 AOP：面向切面编程​ Spring的AOP 存在的目的就是为了解耦。可以让一组类共享相同的行为。Spring 支持AspectJ 的注解式切面编程。 使用@Aspect 声明是一个切面。 使用@After 、@Before 、@Around 定义建言(advice)，可直接将拦截规则(切点)作为参数。 其中@After 、@Before 、@Around 参数的拦截规则作为切点(PointCut)，为了使切点复用，可使用@PointCut专门定义拦截规则，然后在@After 、@Before 、@Around 的参数中调用。 其中符合条件的每一个被拦截处为连接点(JoinPoint)。 下面给出一个AOP的 demo： ​ 首先在pom.xml中添加相关的依赖，相应信息可以在maven仓库中查询。 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.1.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aspectj支持 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjrt --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.5&lt;/version&gt; &lt;/dependency&gt; 编写拦截规则的注解： 12345678910package aop;import java.lang.annotation.*;@Target(ElementType.METHOD) //说明该注解的作用目标是方法@Retention(RetentionPolicy.RUNTIME) //运行时有效@Documented //定义为Beanpublic @interface Action &#123; String name();&#125; 编写使用注解的被拦截器： 12345678package aop;import org.springframework.stereotype.Service;@Service //定义为Beanpublic class DemoAnnotationService &#123; @Action(name="注解式拦截的add操作") public void add()&#123;&#125;&#125; 编写使用方法规则被拦截器： 1234567package aop;import org.springframework.stereotype.Service;@Servicepublic class DemoMethodService &#123; public void add()&#123;&#125;&#125; 编写切面： 1234567891011121314151617181920212223242526272829303132package aop;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.stereotype.Component;import java.lang.reflect.Method;@Aspect //该注解声明一个切面@Component //定义为Beanpublic class LogAspect &#123; @Pointcut("@annotation(aop.Action)") //声明一个切点 public void annotationPointCut()&#123;&#125; @After("annotationPointCut()") //声明一个建言，并使用@Pointcut定义的切点 public void after(JoinPoint joinPoint)&#123; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); Action action = method.getAnnotation(Action.class); System.out.println("注解式拦截 " + action.name()); &#125; @Before("execution(* aop.DemoMethodService.*(..))") public void before(JoinPoint joinPoint)&#123; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); System.out.println("方法式拦截 " + method.getName()); &#125;&#125; 配置类： 12345678910package aop;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@Configuration@ComponentScan("aop")@EnableAspectJAutoProxy //开启Spring对AspectJ的支持public class AopConfig &#123;&#125; 测试： 12345678910111213141516171819package aop;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AopConfig.class); DemoAnnotationService demoAnnotationService = context.getBean(DemoAnnotationService.class); DemoMethodService demoMethodService = context.getBean(DemoMethodService.class); demoAnnotationService.add(); demoMethodService.add(); context.close(); &#125;&#125;输出结果为：注解式拦截 注解式拦截的add操作方法式拦截 add]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows内存]]></title>
    <url>%2F2018%2F06%2F20%2FWindows%E5%86%85%E5%AD%98%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Windows中内存是如何分配的。 分配的是虚拟地址空间，不是虚拟空间；为什么分配这么大？这是windows给出的承诺，向应用程序承诺，在物理内存足够大的情况下，我能够提供给你这么大的地址空间（注意这里的用词是地址空间，意思是有允许其内存寻址最多到8T这个数字）当然，虚拟内存空间地址是一回事，实际空间是另一回事。之前说了，虚拟空间地址只是承诺能够寻址，并非真的分配了空间；当应用程序真的申请了地址空间内能访问的内存时，windows才会开始把被访问的内存页映射到物理内存中。（没错，人家就是打了个空头支票，实际情况是你用一页我分配一页）所以总结如下：所谓的8T（0x200000000）有什么用：允许应用程序访问0x0-0x200000000的任意地址，当然访问0x200000001就会报错，因为超出地址空间了（所以虚拟地址空间越大越好，这样编译器布局内存自由度更大）64位系统为例，物理内存16G，应用程序用了10G，会发生什么：也就是说我允许应用程序用8T内存，但他只用了10G，那没问题，因为可以映射到16G物理内存中；64位系统为例，物理内存16G，应用程序用了17G，会发生什么：唔，物理内存有点不够用，但是可以把一些内存页存到硬盘上（虚拟内存），所以问题也不大，但是进程切换可能引起内存页在硬盘上的读写，所以电脑会有点卡64位系统为例，物理内存16G，应用程序申请了8T，会发生什么：没错，应用程序的确被允许使用8T内存，但是此时系统提供不了这么多，空头支票暴露，你的系统奔溃了]]></content>
      <categories>
        <category>内存</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机类加载机制]]></title>
    <url>%2F2018%2F06%2F20%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[记录下Java中类加载的时机，类在加载过程经历的阶段。&lt;未完待续&gt; 7.2 类加载的时机类从被加载到虚拟机内存开始，到卸载出内存，其整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析部分统称为连接。 ​ 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，什么时候开始加载并没有进行强制约束，可以交给虚拟机的具体实现来自由把握。 ​ 对于初始阶段，虚拟机规范严格规定了有且只有5种情况必须对类立即进行初始化： 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类时，发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 虚拟机启动时，用户需指定一个要执行的主类（包含main()方法的那个类），虚拟机会初始化这个类。 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 ​ 接口加载过程与类加载过程与类加载过程稍微有一些不同，接口也有初始化的过程，接口中不能使用static{}语句块，但编译器仍然会为接口生成“()”类构造器，用于初始化接口中所定义的成员变量。接口与类真正有所求区别的是前面讲述的5种“有且只有”需要初始化场景中的第3种：当初始化一个类时，发现其父类还没有进行过初始化，则需要先触发其父类的初始化。但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。 7.3 类加载的过程7.3.1 加载加载阶段虚拟机需要完成3件事情： 1231. 通过一个类的全限定名来获取定义此类的二进制字节流。2. 将字节流所代表的静态存储结构转化为方法区的运行时数据结构。3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 ​ 这三点要求并不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的，例如：通过全限定名来获取此类的二进制流，没有规定要从Class文件中获取，所以就有多种花样： ​ 从ZIP包中读取，最终成为日后JAR、EAR、WAR格式的基础。 ​ 从网络中获取，这种场景最典型的应用就是Applet。 ​ 运行时计算生成，这种场景使用最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是使用了ProxyGenerator.generateProxyClass来为特定接口生成形式为“*＄Proxy”的代理类的二进制字节流。 ​ 由其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。 ​ 从数据库中读取，这种场景相对少见些。例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库来完成程序代码在集群中的分发。 ​ 对于数组类而言，情况有所不同，数组类本身不通过类加载器创建，由Java虚拟机直接创建。但数组类与类加载器仍由紧密的联系，因为数组类的元素类型最终是要靠类加载器去创建，一个数组（C）创建过程如下： ​ 数组组件类型是引用型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识。 ​ 如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与引导类加载器关联。 ​ 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。 ​ 加载阶段完成后，虚拟机外部的二进制字节流按照虚拟机所需格式存储在方法区中，数据存储格式由虚拟机自行定义。然后在内存实例化一个java.lang.Class类的对象（没有明确在Java堆中，对于HotSpot而言，Class虽然是对象，但是存放在方法区中），这个对象作为程序访问方法区中的这些类型数据的外部接口。加载阶段和连接阶段的部分内容是交叉进行的。 7.3.2 验证​ JVM通过检查输入的字节流是否符合Class文件格式的约束，验证阶段大致上会完成4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。 文件格式验证 ​ 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理： 是否以魔数0xCAFEBABE开头。 主、次版本号是否在当前虚拟机处理范围之内。 常量池的常量中是否有不被支持的常量类型（检查tag标志） 指向常量的索引值是否有指向不存在的常量或不符合类型常量 …………………… ​ 第一阶段的验证远不止如此，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。该验证基于二进制字节流进行，通过该验证后字节流才进入内存的方法区中进行存储，所以后面的验证都是基于方法区的存储结构进行的，不会直接操作字节流。 元数据验证 ​ 第二阶段是对字节码描述的信息进行语义分析以确保描述的信息符合Java语言规范的要求： 这个类是否有父类（除了Object外所有类都要有父类） 这个类的父类是否继承了不允许被继承的类（被final修饰的类） 如果不是抽象类是否实现了父类或接口中要求实现的所有方法 类中字段、方法是否与父类产生矛盾 ……………………………….. ​ 第二阶段目的主要是对类的元数据信息进行语义分析验证，保证不存在不符合Java语言规范的元数据信息。 字节码验证 ​ 第三阶段是最复杂的阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。该阶段对类的方法体进行校验分析，保证被校验类方法在运行时不会做出危害虚拟机安全的事件： 保证任意时刻操作数栈数据类型与指令代码序列能配合工作。 保证跳转指令不会跳转到方法体以外的字节码指令上。 保证方法体中类型转换是有效的 子类可赋值给父类 反之不行。 ……………………………………….. ​ 若一个类方法的字节码未通过字节码验证，肯定是有问题的；但如果一个方法通过字节码验证，也不能说明其一定是安全的。这里涉及著名的“Halting Problem”（停机问题）：通俗讲就是通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。 ​ JDK1.6之后Javac编译器和JVM进行了优化，给方法体Code属性的属性表里增加了一项“StackMapTable“属性，描述了方法体所有基本块（Basic Block，按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，在字节码验证期间就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。 符号引用验证 ​ 最后阶段校验发生在虚拟机将符号引用转化为直接引用，这个转化将在连接的第三阶段——解析阶段中发生。可看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验： 符号引用中通过字符串描述的全限定名是否能找到对应的类。 指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。 符号引用中的类、字段、方法访问性是否可以被当前类访问。 ………………………………………….. 符号验证目的是确保解析动作正常执行。 7.3.3 准备​ 该阶段是正式为类变量分配内存并设置类变量初始值的阶段，类变量所使用的内存都将在方法区中进行分配。该阶段有两个概念：首先，进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象初始化的时候随着对象一起分配在Java堆中。其次这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量定义为：public static int value = 123；那变量在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器()方法中，所以把value赋值为123的动作将在初始化阶段才会执行。 ​ 上述提到的只是“通俗情况”下初始值是零值，还有一些“特殊情况”下：如果类字段的字段属性表中存在ConstantValue属性所指定的值，假设上述变量定义为：public static final int value = 123；编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据这个设置将value赋值为123. 可以看到字节码中多了ConstantValue属性并且有一个初始值为123 7.3.4 解析]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类文件结构]]></title>
    <url>%2F2018%2F06%2F20%2F%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[分析一波Class类文件的结构，此处所使用的二进制文件查看用的classpy。 6.3 Class类文件的结构6.3.1 魔数与Class文件的版本​ Class文件是一组以8位（1个字节）为基础单位的二进制流，中间没有分隔符。每个Class文件的头4个字节成为魔数，它唯一作用就是确定这个文件是否为一个能被虚拟机接受的Class文件（其实好多文件类型都是使用魔数来识别的）。使用魔数而不是扩展名来进行识别主要是考虑安全性，因为文件扩展名是可以随意改动的。 ​ 紧接着魔数的四个字节存储的是Class文件的版本号（如图所示）：第5个和第6个字节是次版本号（Minor Version），第7个和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的（图中0X0034转化为十进制为52，说明这个文件可以被JDK1.8或以上的本地虚拟机执行的Class文件），JDK1.1之后的每个JDK大版本发布主版本号向上加1，高版本JDK向下兼容以前版本的Class文件，但不能运行以后版本的class文件，即使文件格式并未发生任何变化。 6.3.2 常量池​ 理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时还是在Class文件中第一次出现的表类型数据项目。 ​ 常量池中主要存放两大类常量：字面量和符号引用。 ​ 字面量：比较接近Java语言层面的常量概念，如文本串、申明为final的常量值等。 ​ 符号引用：编译原理层面，包含三类，即类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。Java在编译的时候不会像C/C++那样有一个“连接”的过程，而是在虚拟机加载Class文件的时候进行动态连接。Class文件不保存方法字段的最终内存信息，所以这些方法、字段的符号引用不经过运行期转换的话无法得到真正的内存入口地址，无法被虚拟机使用。当虚拟机运行时，需从常量池获得对应的符号引用，再在类创建或运行时解析、翻译到具体的内存地址之中。 ​ 常量池中每一项常量都是一个表，表的开始第一位是一个u1类型的标志位（tag），代表当前这个常量属于哪种常量类型。之所以说常量池是最繁琐的数据，是因为常量类型各自均有自己的结构。 ​ 由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型的常量来描述名称，所以该类型的最大长度就是Java中方法、字段名的最大长度。这里u2类型能表达的最大值是65535。所以Java程序中如果定义了超过64KB英文字符的变量和方法名，将无法编译。javap -verbose可以用于输出Class文件字节码内容。 6.3.3 访问标志​ 常量池结束之后，紧跟着两个字节代表访问标志（access_flags），用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类则是否被声明为final等。一共有16个标记位可以使用。 6.3.4 类索引、父类索引与接口索引集合​ 类索引（this_class）和父类索引（super_class）都是u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系。Java不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，即父类索引都不为0。接口索引集合描述这个类实现了哪些接口，这些被实现的接口按Implement语句（如果类本身是一个接口，则是extends语句）后的顺序从左到右排列在接口索引集合中。 ​ 类索引和父类索引用两个u2类型索引值表示，各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过其中的索引值找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。 ​ 对于接口索引集合，入口第一项——u2类型的数据为接口计数器（interfaces_count），表示索引容量。如果该类没有实现任何接口，则计数器为0，后面索引表不占任何字节。如图所示。 6.3.5 字段表集合​ 用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。可以包括的信息有：字段的作用域（public、private、protected）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。上述信息修饰符都是布尔值，要么有某个修饰符，要么没有。而字段叫什么、字段被定义为什么数据类型，这些都是无法固定的只能引用常量池中的常量来描述。 ​ 表中的两项索引值：name_index和descriptor_index，它们都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符。 ​ 以书中的代码6-1为例，“org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅把类全名中的“.”替换成了“/”而已，为了使多个全限定名之间不产生混淆，在使用时最后一般会加入一个“；”,表示全限定名结束。简单名称指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别是“inc”和“m”。 ​ 相对于全限定名和简单名称来说，方法和字段的描述符复杂一些，描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。 6.3.6 方法表集合​ Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。 ​ 方法的定义可以通过标志、名称索引、描述符索引表达清楚，方法里的java代码经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面。 ​ 与字段表中集合相对应，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。同样有可能出现由编译器自动添加的方法，最典型的就是类构造器”“方法和实例构造器”“方法。 ​ 在Java中，重载（Overload）一个方法除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此Java中无法仅仅依靠返回值的不同来对一个已有方法进行重载的。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调优案例分析与实战]]></title>
    <url>%2F2018%2F06%2F20%2F%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[通过案例来分析Java部署中相关的优化措施。 5.2案例分析5.2.1 高性能硬件上的程序部署策略目前高性能硬件上部署程序主要的两种方式： 通过64位JDK来使用大内存： ​ 对于用户交互性强、对停顿时间敏感的系统给虚拟机分配超大堆的前提是有把握把应用程序的Full GC频率控制得足够低，譬如十几个小时甚至一天才出现一次Full GC。而控制Full GC的频率关键看应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。同时还需要面临的问题： ​ 内存回收导致的长时间停顿。 ​ 现阶段64位JDK的性能测试结果普遍低于32位JDK。 ​ 需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照（因为要产生十几GB乃至更大的Dump文件），哪怕产生了快照也无法分析。 ​ 相同程序在64位JDK消耗的内存一般比32位JDK大，这是由于指针膨胀和数据类型对齐补白等因素导致的。 ​ 使用若干个32位虚拟机建立逻辑集群来利用硬件资源： ​ 现阶段大多采用该方法，具体做法是在一台物理机器上启动多个应用服务器进程，每个服务器进程分配不同的端口，然后在前端搭建一个负载均衡器以反向代理的方式来分配访问请求。这种方案可能会遇到的问题： ​ 尽量避免节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话（尤其式并发写操作容易出现问题），很容易导致IO异常。 ​ 很难高效地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能一些节点池满了而另外一些节点仍有较多空余。尽管可以使用集中式的JNDI（理解为同一资源池），但有一定复杂性并且可能带来额外的性能开销。 ​ 各节点仍然不可避免地受到32位的内存限制，32位windows系统每个进程只能使用2GB的内存，若考虑堆以外的内存开销则堆一般最多只能开到1.5GB。在某些Linux或Unix系统中可以提升至3GB甚至接近4GB的内存，但32位中仍然受最高4GB内存的限制。 ​ 大量使用本地缓存的应用在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点上都有一份缓存，这时候可以考虑把本地缓存改为集中式缓存。 5.2.2 集群间同步导致的内存溢出​ 例：一个基于B/S的MIS系统，硬件为两台2个CPU、8GB内存的HP小型机。服务器为WebLogic9.2，每台机器启动了三个WebLogic实例，构成一个6个节点的亲合式集群（节点之间没有进行Session同步），但有一些需求要实现部分数据在各节点间共享。开始这些数据存放在数据库中，由于读写频繁竞争很激烈，性能影响较大，后来使用JBossCatch构建了一个全局缓存。启用后不久却不定期地出现了多次内存溢出问题。 ​ 查看生成的dump 文件发现里面有大量的org.jgroups.protocols.pbcast.NAKACK对象。JBossCatch基于自家的JGroups进行集群间的数据通信，JGroups使用协议栈的方式来实现收发数据包的各种所需特性自由组合。由于信息有传输失败需要重发的可能性，在确认所有注册在GMS(Group Membership Service)的节点都收到正确的信息前，发送信息必须在内存中保留。MIS服务端有一个负责安全校验的全局Filter，每当收到请求均更新一次最后操作时间并将其同步到所有节点，使一个用户一段时间内不能在多台机器上登录。服务器使用过程中往往一个页面产生数次乃至数十次的请求，因此这个过滤器导致集群节点之间网络交互非常频繁。当网络情况不能蛮子传输要求时，重发数据在内存中不断堆积，很快产生了内存溢出。若使用JBossCatch缓存来同步的话可以允许读操作频繁，但不应当有过于频繁的写操作。 5.2.3 堆外内存导致的溢出错误​ 例子：学校小型项目，基于B/S的电子考试系统，为了实现客户端能实时地从服务器端接收考试数据系统使用了逆向AJAX技术。测试期间发现服务端不定时抛出内存溢出异常，服务器不一定每次都会抛出异常。管理员尝试过把堆卡到最大，32位系统堆最多到1.6G就基本无法再大了，而且开大了基本没什么效果，异常好像还更加频繁了。想通过参数使其产生dump文件，发现什么文件也没有产生。最后在内存溢出后从系统日志中找到异常堆栈。 ​ 服务器使用32位Windows平台的限制是2GB，其中划了1.6GB给Java堆，而Direct Memory内存并不算入1.6GB的堆之内，因此最大也只能在剩余的0.4GB中分出一部分。此应用中导致溢出的原因为：垃圾收集时虚拟机虽然会对Direct Memory进行回收，但是Direct Memory不像新生代、老年代那样发现空间不足了就通知收集器进行垃圾回收，它只能等待老年代满了以后Full GC，然后顺便地帮他清理掉废弃的对象。否则它只能一直等到抛出内存溢出异常时先catch掉，再在catch块中调用System.gc()，要是此使虚拟机还不进行gc，那就不得不抛出内存溢出异常了（虽然有可能堆中还有很多空闲内存）。本案例中使用的CometD 1.1.1框架，正好有大量的NIO操作要使用到Direct Memory内存。 除了Java堆和永久代外，下面区域还会占用较多的内存： ​ Direct Memory：可通过参数-XX:MaxDirectMemorySize进行大小的调整。 ​ 线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError（栈深不足，纵向）和OutOfMemoryError（无法建立新线程，横向）。 ​ Socket缓存区：每个Socket连接都有Receive和Send两个缓存区，分别占37KB和25KB，连接多的话这部分内存也比较可观，如无法分配则可能抛出IOException:Too many open files异常。 ​ JNI代码：使用JNI调用本地库，使用的内存也不在堆中。 ​ 虚拟机和GC：虚拟机、GC的代码执行也要消耗一定的内存。 5.2.4 外部命令导致系统缓慢​ 例子：一个数字校园应用系统运行在Solaris操作系统上，中间件为GlassFish服务器。系统做大并发压力测试发现请求响应时间较慢，使用mpstat发现CPU使用率高并且系统占用绝大多数的CPU资源。后来使用Dtrace发现最消耗CPU资源的是“fork”系统调用。 ​ 原因是：每个用户请求的处理都需要执行一个外部shell脚本来获得系统的信息，执行这个shell脚本是通过Java的Runtime.getRuntime().exec()方法来调用的。这种调用方式在虚拟机中非常消耗资源，频繁调用创建进程开销非常可观，系统消耗会很大，不仅是CPU，内存负荷也很重。 5.2.5 服务器JVM进程崩溃​ 例子：一个基于B/S的MIS系统正常运行一段时间后发现在运行期间频繁出现集群节点的虚拟机进程自动关闭现象。从系统日志文件可看出发生过大量的远端断开连接的异常，通过系统管理员了解到系统最近与一个OA门户做了集成，在MIS系统工作流的代办事项变化时要通过Web服务通知OA门户系统，把代办事项的变化同步到OA门户中。通过SoapUI测试了同步待办事项的Web服务，发现调用以后需要3分钟才能返回，并且返回结果都是连接中断。 ​ 由于MIS系统用户多、待办事项变化快，为了不被OA系统拖累使用了异步方式调用Web服务，由于两边速度不对等，时间久了就积累了越多Web服务没有调用完成，导致等待的线程和Socket来连接越来越多，最终超过虚拟机的承受范围使其崩溃。 ​ 解决方法：通知OA门户方修复无法使用的集成接口，并将以不调用改为生产者/消费者模式的消息队列后，系统恢复正常。 5.2.6 不恰当数据结构导致内存占用过大​ 例子：一个后台RPC服务器，64位虚拟机内存配置-Xms4g -Xmx8g -Xmn1g，使用ParNew+CMS的收集器组合平时Minor GC时间30毫秒以内，能接收。但业务上需每10分钟加载一个约80MB的数据文件到内存，这些数据在内存中形成超过100万个HashMap&lt;Long, long&gt; Entry，在这段时间里Minor GC会造成超过500毫秒停顿。原因在于：分析数据文件期间，800MB的Eden空间很快被填满从而引发GC，但是Minor GC以后新生代绝大多数对象还存活。ParNew收集器使用复制算法，对于这种情况将它们复制到Survivor并维持这些对象的引用成为一个沉重的负担，导致GC暂停时间明显变长。 ​ 如果不修改程序仅从GC调优角度去解决这个问题，可以考虑将Survivor空间去掉（通过参数），让新生代中存活的对象在第一次Minor GC后立即进入老年代，等到Major GC的时候再清理他们。这种措施治标不治本，治本的话需要修改程序，因为产生这种情况的根本原因是HashMap&lt;Long, Long&gt; 结构来存储数据文件空间效率太低。 5.2.7 由Windows虚拟内存导致的长时间停顿​ 例子：带心跳检测功能的GUI桌面程序，每15秒发送一次心跳检测信号，若30秒内没收到返回信息，就认为和对方程序的连接已经断开。程序上线后发现检测有误报的概率，查询日志发现原因是程序偶尔出现间隔一分钟左右的时间完全无日志输出，处于停顿状态。 ​ 从GC日志文件中确认了停顿原因是由GC导致的，偶尔会出现一次接近一分钟的GC。从日志片段中可以看出，真正执行GC动作的时间不是很长，但从准备开始GC，到真正开始GC之间所消耗的时间却占了绝大多数。[Times：user=0.61 sys=0.52，real=31.16 secs]可以看出。 ​ 除GC日志之外，还观察到这个GUI程序内存变化的一个特点，当它最小化的时候资源管理显示的占用内存大幅度减小，但是虚拟内存则没有变化，因此怀疑程序最小化时工作内存被交换到了磁盘的页面文件之中，这样发生GC时就有可能因为恢复页面而导致不正常的GC停顿，可以通过参数来解决（保证程序在最小化时能立即响应）。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机性能监控与故障处理工具]]></title>
    <url>%2F2018%2F06%2F20%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[JDK工具使用：主要记录一些JDK工具使用，包括内存监视和快照生成查看等一系列可视化工具。&lt;未完待续&gt; 4.2 JDK的命令行工具 4.2.1 jps：虚拟机进程状况工具​ 其功能和UNIX中的ps命令相似：列出正在进行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称及进程的本地虚拟机唯一ID(LVMID)。 4.2.2 jstat：虚拟机统计信息监视工具​ 用于监视虚拟机各种运行状态信息的命令行工具，可以显示远程或者本地虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 4.2.3 jinfo：Java配置信息工具​ 该工具可以实时地查看和调整虚拟机各项参数。 4.2.4 jmap：Java内存映像工具​ 该命令用于生成堆转储快照（称为dump文件）。 4.2.5 jhat：虚拟机堆转储快照分析工具​ 该命令与jmap搭配使用，来分析jmap生成的dump文件，不过实际上一般不会直接使用jhat来分析dump文件，两个原因：1. 一般不在部署应用的服务器上直接分析dump，即使这样做也会尽量将dump复制到其他机器上分析；2. jhat分析功能比较简陋，还有其他强大的工具可以选择。 4.2.6 jstack：Java堆栈跟踪工具​ 该命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。其主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 4.2.7 HSDIS：JIT生成代码反汇编​ 将本地代码还原为汇编代码输出（没成功）。 4.3 JDK的可视化工具4.3.1 JConsole：Java监视与管理控制台​]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集和内存分配]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[关于Java虚拟机GC垃圾收集机制，主要介绍了不同区域所使用的垃圾收集算法，以及他们的结合种类、适用场景。 3.4 HotSpot算法实现3.4.2 安全点​ JVM通过GC Roots节点来判断某个对象是否可达，但是如果需要逐个检查的话必然会消耗很多时间，所以需要使用一个名为OopMap的数据结构来记录引用位置的信息（如指令流的起始位置，偏移量等）。 ​ 在OopMap的帮助下，JVM可以很快的完成GC Roots的枚举，但是这里会出现一个问题：并不是所有的指令都会生成对应的OopMap数据结构，假设如此需要大量的额外空间，导致GC的空间成本将会变得非常高。这里的解决办法是只在“特定位置”记录这些信息，这样的位置称之为安全点（safe point），当线程执行到safe point的时候才会停顿下来开始GC。这里的safe point选定不能太少也不能太多，太少GC等太久，太多增大运行负荷；这里的设置特征为“是否让程序长时间执行的特征”，最明显的特征就是指令序列的复用比如方法调用、循环跳转、异常跳转等位置。 ​ 为了让GC发生是所有线程（不包括JNI调用的线程）都能在最近的安全点停下来，有两种方法：抢先式中断和主动式中断。抢先式：GC发生时，中断所有线程，发现不在安全点的就恢复它使之跑到安全点上（目前几乎不用，不详细表）；主动式：GC发生时，不直接操作线程仅设置一个标志，各个线程在执行的时候主动去轮询这个标志，为真时自动挂起（轮询标志和安全点是重合的）。 3.4.3 安全区域​ 安全区域的设定是为了解决程序“不执行”的时候，即未分配CPU时间，因此线程无法响应JVM的中断请求挂起，典型的例子就是Sleep和Block状态。这时需要设置一个安全区域（safe region），安全区域是安全点的一个很大的扩展，设置原则为引用关系不会发生变化的一段代码片段。在线程离开安全区域之前会检查GC是否完成了根节点的枚举，完成的话继续执行，否则等待知道收到可以安全离开安全区域的信号为止。 3.5 垃圾收集器3.5.1 Serial收集器​ Serial是一个最基本、发展最久的收集器，单线程，但不仅仅说明它只会使用一个CPU或者一条线程去完成垃圾收集工作，更重要的是它在收集垃圾时必须暂停其他所有线程直到它结束（Stop The World），虽然不科学但是依然是Client模式下默认新生代收集器，优点：简单高效（没有线程交互的开销，专心收垃圾）。在桌面场景中新生代内存往往不大，所以停顿时间可以控制在几十最多一百多毫秒以内。 3.5.2 ParNew收集器​ 其实是Serial的多线程版本，只有它能与CMS收集器配合使用；目前新生代的垃圾收集只能从Serial和ParNew中选择，在单CPU的情况下ParNew不比Serial好（甚至由于线程交互的开销不能超过Serial）,但是随着CPU数量的增加，它对于GC时的系统资源的有效利用还是很有好处的。默认开启的线程数与CPU数量相同，可用参数进行限制。 3.5.3 Parallel Scavenge收集器​ Parallel Scavenge的关注点和其他收集器不同，CMS等收集器是尽可能地缩短垃圾收集时用户线程的停顿时间，而该收集器目标时达到一个可控制的吞吐量（吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间））。和ParNew相比他们都是使用的复制算法，又是并行的多线程~ 但是不同的是Parallel Scavenge提供了两个参数用于精确控制吞吐量，分别为控制最大垃圾收集停顿时间参数以及直接设置吞吐量大小参数；停顿时间是虚拟机通过设置吞吐量和新生代空间大小来调整的。还有一个自适应调节策略（虚拟机根据系统情况自己调节）也是和ParNew的一个重要区别。 3.5.4 Serial Old收集器​ Serial的老年代版本，垃圾回收算法使用的是标记-整理算法。主要两大用途：jdk1.5以及之前版本中与Parallel Scavenge收集器搭配使用；作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure 时使用。 3.5.5 Parallel Old 收集器​ Parallel Scavenge的老年代版本，使用标记-整理算法。jdk1.6之前Parallel Scavenge较尴尬：因为新生代一旦选择Parallel Scavenge，老年代就只能使用Serial Old，所以无法充分利用多CPU的处理能力。后来有了Parallel Old就可以和它组合使用，真正注重吞吐量了。 3.5.6 CMS收集器​ CMS收集器是一种以获取最短回收停顿时间为目标的收集器。基于“标记-清除”算法实现，运作过程分为四个步骤：初始标记，并发标记，重新标记，并发清除。 ​ 初始标记：仅仅标记一下GC Roots能直接关联到的对象，速度快但是需要“Stop The World”。 ​ 并发标记：进行GC Roots Tracing的过程，能够与用户线程一起工作。 ​ 重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，此阶段停顿时间比初始标记阶段时间稍长但是远比并发标记时间短，需要“Stop The World”。具体如何实现，做了什么还不清楚暂时不表。 ​ 并发清除：清理未被标记的对象（不可达的），与用户线程一起并发执行。 ​ 主要特点：并发收集、低停顿。 缺点： 对CPU资源非常敏感，虽然不会导致用户线程停顿但是会明显占用CPU资源而导致应用程序变慢，总吞吐量降低。CMS默认启动的回收线程数是（CPU数+3）/ 4 。这样导致用户程序执行速度忽然降低难以接受，所以虚拟机提供了“增量式并发收集器”，模拟操作系统使用抢占式来模拟多任务，使GC线程、用户线程交替运行，这样会使整个垃圾收集时间变长。实践证明这种处理效果一般，不提倡使用。 无法处理浮动垃圾，浮动垃圾：由于并发清理阶段用户线程的运行产生新的垃圾，这部分垃圾未被标记导致当前周期无法被处理，需等下一周期。所以CMS不能老年代满了再收集，需要设置一部分空间给应用程序，jdk1.6中将启动阈值提高到了92%。但是用户可以通过参数进行设置，如果预留内存无法满足需要（Concurrent Mode Failure），虚拟机会启动后备预案：临时启动Serial Old来重新进行老年区的垃圾收集，这样停顿时间就会很久。如果启动阈值设置过高，会导致大量的“Concurrent Mode Failure”失败，性能大大降低。 这个缺点就是“标记-清除”算法普遍存在的了，收集结束会有大量空间碎片产生，当有大对象时无法找到足够大的连续空间来分配，因此提前触发了一次Full GC。为此CMS收集器提供-XX:+UseCMSCompactAtFullCollection开关参数（默认开），用于在进行Full GC时开启碎片合并整理过程，这样停顿时间变长。虚拟机设计者还提供-XX:CMSFullGCsBeforeCompaction，设置多少次不压缩的Full GC以后来一次带压缩的（默认0）。 这里有个疑问：既然使用“标记-清除”会导致大量空间碎片产生，那为什么不使用“标记-整理”算法呢？遂一顿搜索发现：原来CMS为了获取最短回收停顿时间而将耗时长的设为并发（并发标记和并发清理），如果在并发时通过整理移动了对象的内存，那么线程就会找不到应用对象在哪里。 3.5.7 G1收集器​ G1（Garbage-First）收集器是新出的，面向服务端应用的收集器，有如下特点：1.并行与并发，能充分利用多CPU、多核环境缩短STW的时间；2.分代收集，能够采用不同方式处理不同类型的旧对象；3.空间整合，从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的（没理解）；4.可预测停顿，G1除了追求低停顿外还建立可预测的停顿时间模型，制定M时间片段内收集垃圾时间不能超过N，其原因在于可以有计划地避免在整个堆中进行全区域的垃圾收集，G1跟踪各个Region中垃圾收集的价值（根据获取空间大小和所需时间）维护一个表，每次优先回收价值高的Region。 ​ Region之间不可能是孤立的，不然检测Region之间的对象引用的时候还得扫描整个Java堆导致效率降低。所以每个Region需维护一个Remembered Set记录该Region被引用对象的相关引用信息，在内存回收时加入Remembered Set的扫描即可。 G1收集器运作步骤： 初始标记：和CMS一样，该阶段仅标记一下GC Roots能直接关联的对象并修改TAMS。 并发标记：从GC Root开始对堆中对象进行可达性分析，找出存活对象，该过程耗时久但是可并发操作。 最终标记：修正并发标记过程中因用户程序运作而导致产生变化的标记记录，虚拟机将其记录在线程Remembered Set Logs中，并在此阶段将其合并到Remembered Set中，可并行。 筛选标记：首先对各个Region回收价值和成本进行排序，根据用户期望的停顿时间来制定回收计划，可并行，但是停顿用户线程将大幅提高收集效率。 3.5.8 GC日志3.6 内存分配与回收策略3.6.1 对象优先在Eden分配​ Eden区和Survivor区都属于新生代，而Eden区存放的对象一般都是生命周期不长的对象（因此使用复制算法进行回收）。 3.6.2大对象直接进入老年代​ 所谓大对象指大量连续内存空间的Java对象，最典型的就是很长的字符串以及数组（更坏的消息是遇到一群“朝生夕灭”的“短命大对象”），经常导致内存还有不少就不得不提前触发垃圾收集来获取足够的连续空间来存放他们。可以通过设置-XX:PretenureSizeThreshold参数来设置这个上限值。 3.6.3 长期存活的对象将进入老年代​ 通过对象年龄计数器来记录对象，当熬过第一次Minor GC进入Survivor区并将年龄设置为1，接着每熬过一次Minor GC就将年龄加1，当年龄加到一定程度就被晋升入老年代中（默认为15），这个年龄阈值可以通过-XX:MaxTenuringThreshold参数设置。 3.6.4 动态对象年龄判断​ 虚拟机并不是永远要求对象年龄达到阈值才晋升老年代的，如果在Survivor中相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就直接进入老年代无需等到要求的阈值年龄了。 3.6.5 空间分配担保​ 在发生Minor GC前，虚拟机会检查老年代最大连续可用空间是否大于新生代所有对象总空间，如成立则此次Minor GC是安全的。如不成立，虚拟机检查是否允许担保失败（HandlePromotionFailure参数），若允许则检查老年代最大可用连续空间是否大于历次晋升到老年代对象平均大小，若大于则进行一次有风险的Minor GC，若小于或者设置为不允许担保失败，则进行一次Full GC。 ​ JDK 6 update 24以后规则发生了更改，即不管HandlePromotionFailure参数如何设置，代码中都不会使用它，规则变为只要老年代连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>gc</tag>
      </tags>
  </entry>
</search>
