<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring高级话题]]></title>
    <url>%2F2018%2F06%2F30%2FSpring%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&lt;未完待续&gt; Spring Aware​ Spring的依赖注入最大亮点就是所有的Bean 对Spring 容器的存在是没有意识的。即可以将现在的容器换成别的容器，比如 Goole Guice，这时Bean之间的耦合度很低。 ​ 但是实际项目中不可避免的用到Spring 容器本身的功能资源，这时Bean必须意识到Spring 容器的存在，才能调用Spring所提供的资源，这就是Spring Aware。使用了Spring Aware 的话Bean将会和Spring 架构之间耦合。 Spring 提供的Aware接口如图所示： 接口 功能 BeanNameAware 获得容器中Bean的名称 BeanFactoryAware 获得当前 bean factory，这样可以调用容器服务。 ApplicationContextAware* 当前 application context，这样可以调用容器服务。 MessageSourceAware 获得message source，这样可以获得文本信息。 ApplicationEventPublisherAware 应用事件发布器，可以发布事件。 ResourceLoaderAware 获得资源加载器，可以获得外部资源文件 ​ Spring Aware 的目的是为了让Bean获得Spring 容器的服务。因为ApplicationContext接口集成了MessageSource接口、ApplicationEventPublisher接口和ResourceLoader接口，所以Bean 只要继承ApplicationContext就可以获得Spring容器的所有服务，但原则上还是用到什么接口就实现什么接口。 示例，Spring Aware演示的Bean 12345678910111213141516171819202122232425262728293031323334353637package aware;import org.apache.commons.io.IOUtils;import org.springframework.beans.factory.BeanNameAware;import org.springframework.context.ResourceLoaderAware;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;import org.springframework.stereotype.Service;import java.io.IOException;@Servicepublic class AwareService implements BeanNameAware, ResourceLoaderAware &#123; //实现BeanNameAware和ResourceLoaderAware两个接口，获得Bean名称和资源加载的服务。 private String beanName; private ResourceLoader loader; @Override //这里还有下面的注解刚开始出了点小问题，实现接口方法用@Override出现 "@Override is not allowed when implementing interface method" ,[解决办法及原因](https://stackoverflow.com/questions/15402615/override-is-not-allowed-when-implementing-interface-method) public void setResourceLoader(ResourceLoader resourceLoader)&#123; //重写setResource方法。 this.loader = resourceLoader; &#125; @Override public void setBeanName(String name)&#123; //重写setBeanName方法。 this.beanName = name; &#125; public void outputResult()&#123; System.out.println("Bean的名称为：" + beanName); Resource resource = loader.getResource("classpath:aware/test.txt"); try &#123; System.out.println("ResourceLoader加载的文件内容为：" + IOUtils.toString(resource.getInputStream())); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 配置类： 123456789package aware;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan("aware")public class AwareConfig &#123;&#125; 运行： 12345678910111213141516171819package aware;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AwareConfig.class); AwareService awareService = context.getBean(AwareService.class); awareService.outputResult(); context.close(); &#125;&#125;运行结果：Bean的名称为：awareServiceResourceLoader加载的文件内容为：this is a test file 多线程]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>SpringAware</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring常用配置]]></title>
    <url>%2F2018%2F06%2F26%2FSpring%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[记录Spring中Bean的配置、EL和资源调用、Bean的声明周期、Profile、事件。 Bean的Scope​ Scope描述的是Spring容器如何新建Bean实例的，通过 @Scope 注解来实现，有以下几种： Singleton：一个Spring容器中只有一个Bean的实例，此为Spring的默认配置，全容器共享一个实例。 Prototype：每次调用都新建一个Bean的实例。 Request：Web项目中，给每个http request 新建一个Bean实例。 Session：Web项目中，给每个http session新建一个Bean实例。 GlobalSession：这个只在portal应用中有用，给每个global http session新建一个Bean实例。 singleton 和 prototype 实例： Singleton的Bean： 1234567package scope;import org.springframework.stereotype.Service;@Service //默认为Singleton，相当于Scope("singleton")public class DemoSingletonService &#123;&#125; Prototype的Bean： 123456789package scope;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Service;@Service@Scope("prototype") //声明Scope为Prototypepublic class DemoPrototypeService &#123;&#125; 配置类： 1234567package scope;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan("scope")public class ScopeConfig &#123;&#125; 测试类： 1234567891011121314151617181920212223package scope;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Scope;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ScopeConfig.class); DemoSingletonService s1 = context.getBean(DemoSingletonService.class); DemoSingletonService s2 = context.getBean(DemoSingletonService.class); DemoPrototypeService p1 = context.getBean(DemoPrototypeService.class); DemoPrototypeService p2 = context.getBean(DemoPrototypeService.class); System.out.println("s1与s2是否相等： " + s1.equals(s2)); System.out.println("p1与p2是否相等： " + p1.equals(p2)); &#125;&#125;运行结果为：s1与s2是否相等： truep1与p2是否相等： false Spring EL和资源调用​ Spring EL-Spring 表达式语言支持在xml和注解中使用，类似于JSP的EL表达式，其中涉及调用各种资源包括普通文件、网址、配置文件、系统环境变量等。Spring主要在注解@Value 的参数中使用表达式。本文涉及到的有以下几种情况： 注入普通字符 注入操作系统属性 注入表达式运算结果 注入其他Bean 的属性 注入文件内容 注入网址内容 注入属性文件 示例： 增加commons-io 可简化文件相关操作： 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt;&lt;/dependency&gt; 在包内添加test.txt文件，内容随意~ 在包内添加test.properties资源文件，内容如下： 12book.author=yyyybook.name=xxxx 编辑被注入的Bean： 123456789101112131415161718package el;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;@Servicepublic class DemoService &#123; @Value("其他类的属性") //表示注入普通的字符串 private String another; public String getAnother()&#123; return another; &#125; public void setAnother(String another) &#123; this.another = another; &#125;&#125; 编写演示配置类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package el;import org.apache.commons.io.IOUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;import org.springframework.core.env.Environment;import org.springframework.core.io.Resource;@Configuration@ComponentScan("el")@PropertySource("classpath:el/test.properties") //注入配置文件public class ElConfig &#123; @Value("I Love You!") //注入普通字符串 private String normal; @Value("#&#123;systemProperties.os.name&#125;") //注入操作系统属性 private String osName; @Value("#&#123; T(java.lang.Math).random() * 100.0 &#125;") //注入表达式结果 private String randomNumber; @Value("#&#123;demoService.another&#125;") //注入其他Bean属性 private String fromAnother; @Value("classpath:el/test.txt") //注入文件资源 private Resource testFile; @Value("http://www.baidu.com") //注入网址资源 private Resource testUrl; @Value("$&#123;book.name&#125;") //注入配置文件 private String bookName; @Autowired private Environment environment; @Bean public static PropertySourcesPlaceholderConfigurer propertyConfig()&#123; return new PropertySourcesPlaceholderConfigurer(); &#125; public void outputResource() &#123; try &#123; System.out.println(normal); System.out.println(osName); System.out.println(randomNumber); System.out.println(fromAnother); System.out.println(IOUtils.toString(testFile.getInputStream())); System.out.println(IOUtils.toString(testUrl.getInputStream())); System.out.println(bookName); System.out.println(environment.getProperty("book.author")); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 编写运行类： 1234567891011121314151617181920212223242526272829package el;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ElConfig.class); ElConfig resourceService = context.getBean(ElConfig.class); resourceService.outputResource(); context.close(); &#125;&#125;输出信息：I Love You!Windows 109.515003283753941其他类的属性文本测试&lt;!DOCTYPE html&gt;六月 26, 2018 5:04:41 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@531d72ca: startup date [Tue Jun 26 17:04:41 CST 2018]; root of context hierarchy&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class="bg s_ipt_wr"&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus&gt;&lt;/span&gt;&lt;span class="bg s_btn_wr"&gt;&lt;input type=submit id=su value=百度一下 class="bg s_btn"&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;新闻&lt;/a&gt; &lt;a href=http://www.hao123.com name=tj_trhao123 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;地图&lt;/a&gt; &lt;a href=http://v.baidu.com name=tj_trvideo class=mnav&gt;视频&lt;/a&gt; &lt;a href=http://tieba.baidu.com name=tj_trtieba class=mnav&gt;贴吧&lt;/a&gt; &lt;noscript&gt; &lt;a href=http://www.baidu.com/bdorz/login.gif?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb&gt;登录&lt;/a&gt; &lt;/noscript&gt; &lt;script&gt;document.write('&lt;a href="http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u='+ encodeURIComponent(window.location.href+ (window.location.search === "" ? "?" : "&amp;")+ "bdorz_come=1")+ '" name="tj_login" class="lb"&gt;登录&lt;/a&gt;');&lt;/script&gt; &lt;a href=//www.baidu.com/more/ name=tj_briicon class=bri style="display: block;"&gt;更多产品&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=ftCon&gt; &lt;div id=ftConw&gt; &lt;p id=lh&gt; &lt;a href=http://home.baidu.com&gt;关于百度&lt;/a&gt; &lt;a href=http://ir.baidu.com&gt;About Baidu&lt;/a&gt; &lt;/p&gt; &lt;p id=cp&gt;&amp;copy;2017&amp;nbsp;Baidu&amp;nbsp;&lt;a href=http://www.baidu.com/duty/&gt;使用百度前必读&lt;/a&gt;&amp;nbsp; &lt;a href=http://jianyi.baidu.com/ class=cp-feedback&gt;意见反馈&lt;/a&gt;&amp;nbsp;京ICP证030173号&amp;nbsp; &lt;img src=//www.baidu.com/img/gs.gif&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;xxxxyyyy Bean 的初始化和销毁​ 在实际开发中，经常会遇到在Bean使用之前和使用之后做些必要的操作，Spring对Bean的生命周期的操作提供了支持，在Java配置和注解配置下提供两种方式： Java配置方式：使用@Bean 的initMethod 和destroyMethod (相当于xml配置的init-method 和 destroy-method)。 注解方式：利用JSR-250的@PostConstruct 和@PreDestroy。 首先在maven配置文件中增加JSR250的支持 12345&lt;dependency&gt; &lt;groupId&gt;javax.annotion&lt;/groupId&gt; &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 使用@Bean 形式的Bean如下： 12345678910111213141516package prepost;public class BeanWayService &#123; //此类不预先声明为Bean，在配置类中手动创建成为Bean public void init()&#123; System.out.println("@Bean-init-method"); &#125; public BeanWayService()&#123; super(); System.out.println("初始化构造函数-BeanWayService"); &#125; public void destroy()&#123; System.out.println("@Bean-destroy-method"); &#125;&#125; 使用JSR250形式的Bean： 123456789101112131415161718192021package prepost;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;public class JSR250WayService &#123; @PostConstruct //在构造函数执行完之后执行 public void init()&#123; System.out.println("jsr250-init-method"); &#125; public JSR250WayService()&#123; super(); System.out.println("初始化构造函数-JSR250WayService"); &#125; @PreDestroy //在Bean销毁之前执行 public void destroy()&#123; System.out.println("jsr250-destroy-method"); &#125;&#125; 配置类： 12345678910111213141516171819package prepost;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan("prepost")public class PrePostConfig &#123; @Bean(initMethod = "init", destroyMethod = "destroy") //initMethod和destroyMethod指定BeanWayService类的init和destroy方法在构造函数之后，Bean销毁之前执行 BeanWayService beanWayService()&#123; return new BeanWayService(); &#125; @Bean //这里因为在JSR250WayService类中的方法已经指定了，所以不用上述那样 JSR250WayService jsr250WayService()&#123; return new JSR250WayService(); &#125;&#125; 测试类： 1234567891011121314151617181920212223package prepost;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(PrePostConfig.class); BeanWayService beanWayService = context.getBean(BeanWayService.class); JSR250WayService jsr250WayService = context.getBean(JSR250WayService.class); context.close(); &#125;&#125;运行结果如下：初始化构造函数-BeanWayService@Bean-init-method初始化构造函数-JSR250WayServicejsr250-init-methodjsr250-destroy-method@Bean-destroy-method Profile使用Profile为在不同的环境下使用不同的配置提供了支持： 通过设定Environment 的ActiveProfiles 来设定当前context 需要使用的环境配置。在开发中使用@Profile 注解类或者方法，达到在不同情况下选择实例化不同的Bean。 通过设定jvm的spring.profile.active参数来设置配置环境。 Web项目设置在Servlet 的context parameter中。（也就是上下文参数） 下面进行简单的代码演示，示例Bean： 1234567891011121314151617package profile;public class DemoBean &#123; private String content; public DemoBean(String content)&#123; super(); this.content = content; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; Profile 配置类： 12345678910111213141516171819package profile;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Profile;@Configurationpublic class ProfileConfig &#123; @Bean @Profile("dev") //Profile为dev时实例化devDemoBean。 public DemoBean devDemoBean()&#123; return new DemoBean("from development profile"); &#125; @Bean @Profile("prod") //Profile为prod时实例化为proDemoBean。 public DemoBean prodDemoBean()&#123; return new DemoBean("from production profile"); &#125;&#125; Main类： 123456789101112131415161718192021222324252627282930313233343536package profile;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.getEnvironment().setActiveProfiles("prod"); //将活动的Profile设置为prod。 context.register(ProfileConfig.class); //后置注册Bean配置类，不然会报Bean未定义的错误。 context.refresh(); DemoBean demoBean = context.getBean(DemoBean.class); System.out.println(demoBean.getContent()); context.close(); &#125;&#125;运行结果为：六月 29, 2018 9:17:42 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@67424e82: startup date [Fri Jun 29 21:17:42 CST 2018]; root of context hierarchyfrom production profile六月 29, 2018 9:17:42 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@67424e82: startup date [Fri Jun 29 21:17:42 CST 2018]; root of context hierarchy如果将 "pro" 改为 "dev" ：六月 29, 2018 9:18:37 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@67424e82: startup date [Fri Jun 29 21:18:37 CST 2018]; root of context hierarchyfrom development profile六月 29, 2018 9:18:37 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@67424e82: startup date [Fri Jun 29 21:18:37 CST 2018]; root of context hierarchy 事件(Application)​ Spring 的事件(Application Event) 为Bean 和 Bean 之间的消息通信提供了支持。当一个Bean 处理完一个任务之后，希望另一个Bean知道并能做出相应的处理，这时我们就能让另一个Bean 监听当前Bean 所发送的事件。(讲到这里，相当了Servlet中也有类似的事件监听，或许是差不多的东西) Spring 实现事件监听流程： 自定义事件，继承ApplicationEvent。 定义事件监听器，实现ApplicationListener。 使用容器发布事件。 首先，自定义事件，为了让消息更加可视化，传入参数msg： 1234567891011121314151617181920package event;import org.springframework.context.ApplicationEvent;public class DemoEvent extends ApplicationEvent &#123; private String msg; public DemoEvent(Object source, String msg)&#123; super(source); this.msg = msg; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; 第二步，实现事件监听器： 12345678910111213package event;import org.springframework.context.ApplicationListener;import org.springframework.stereotype.Component;@Componentpublic class DemoListener implements ApplicationListener&lt;DemoEvent&gt; &#123; //实现ApplicationListener 接口，并且指定监听的事件类型 public void onApplicationEvent(DemoEvent event) &#123; //使用onApplicationEvent 方法对消息进行接受处理。 String msg = event.getMsg(); System.out.println("我(bean-DemoListener)接收到了bean-demoPublisher发布的消息：" + msg); &#125;&#125; 事件发布类： 1234567891011121314package event;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.stereotype.Component;@Componentpublic class DemoPublisher &#123; @Autowired ApplicationContext context; //注入ApplicationContext用来发布事件。 public void publish(String msg)&#123; context.publishEvent(new DemoEvent(this, msg)); //使用publishEvent方法来发布事件。 &#125;&#125; 配置类： 123456789package event;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan("event")public class EventConfig &#123;&#125; 运行函数： 12345678910111213141516171819202122package event;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(EventConfig.class); DemoPublisher demoPublisher = context.getBean(DemoPublisher.class); demoPublisher.publish("hello application event"); context.close(); &#125;&#125;运行结果如下所示：六月 29, 2018 9:56:20 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@67424e82: startup date [Fri Jun 29 21:56:20 CST 2018]; root of context hierarchy我(bean-DemoListener)接收到了bean-demoPublisher发布的消息：hello application event六月 29, 2018 9:56:20 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@67424e82: startup date [Fri Jun 29 21:56:20 CST 2018]; root of context hierarchy 可以看出，DemoListener成功监听到了DemoPublisher发布的事件。]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Bean</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring基础]]></title>
    <url>%2F2018%2F06%2F25%2FSpring%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Spring基础 Spring配置方式 xml配置 注解配置 Java配置 Maven简介​ maven是一个软件项目管理工具。基于项目管理对象模型的概念，可用来管理项目的依赖、编译、文档等信息。 ​ 在maven中管理依赖时只需要在配置文件pom.xml中按下面的形式添加就好了。 12345&lt;dependency&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;version&gt;xxx&lt;/version&gt;&lt;/dependency&gt; ​ 添加完成以后maven就会通过互联网在maven中心库下载相关的依赖包到.m2目录下，也是你的本地maven库，如果中心库没有你需要的jar包，需要自己使用maven命令导入到本地maven库。 依赖注入​ 在Spring的概念下，控制翻转和依赖注入是等同的概念，控制翻转是通过依赖注入实现的。依赖注入指容器负责创建对象和维护对象间的依赖关系，而不是通过对象本身负责自己的创建和解决自己的依赖。 ​ 依赖注入的目的是为了解耦，使用“组合”的概念降低类之间的耦合度。Spring IoC容器负责创建Bean，并且通过容器将功能类Bean注入到需要的Bean中。Spring 提供使用xml、注解、Java配置、groovy配置实现Bean的创建和注入。 声明Bean的注解有： @Component 组件，没有明确的角色 @Service 在业务逻辑层(service层)使用 @Respository 在数据访问层(dao层）使用 @Controller 在展现层(MVC - SpringMVC)使用 注入Bean的注解： @Autowired：Spring提供的注解 @Inject：JSR-330提供的注解 @Resource：JSR-250提供的注解 注入Bean的注解可以用在set方法上或者属性上。 配置​ Java配置是现在推荐的方式，主要通过@Configuration 和@Bean 来实现 @Configuration 声明当前类是一个配置类，相当于一个Spring配置的xml文件。 @Bean 注解在方法上，声明当前方法的返回值为一个Bean。 遵循的基本原则是：全局配置使用Java配置(如数据库相关配置、maven相关配置)，业务Bean的配置使用注解配置。 AOP：面向切面编程​ Spring的AOP 存在的目的就是为了解耦。可以让一组类共享相同的行为。Spring 支持AspectJ 的注解式切面编程。 使用@Aspect 声明是一个切面。 使用@After 、@Before 、@Around 定义建言(advice)，可直接将拦截规则(切点)作为参数。 其中@After 、@Before 、@Around 参数的拦截规则作为切点(PointCut)，为了使切点复用，可使用@PointCut专门定义拦截规则，然后在@After 、@Before 、@Around 的参数中调用。 其中符合条件的每一个被拦截处为连接点(JoinPoint)。 下面给出一个AOP的 demo： ​ 首先在pom.xml中添加相关的依赖，相应信息可以在maven仓库中查询。 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.1.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aspectj支持 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjrt --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.5&lt;/version&gt; &lt;/dependency&gt; 编写拦截规则的注解： 12345678910package aop;import java.lang.annotation.*;@Target(ElementType.METHOD) //说明该注解的作用目标是方法@Retention(RetentionPolicy.RUNTIME) //运行时有效@Documented //定义为Beanpublic @interface Action &#123; String name();&#125; 编写使用注解的被拦截器： 12345678package aop;import org.springframework.stereotype.Service;@Service //定义为Beanpublic class DemoAnnotationService &#123; @Action(name="注解式拦截的add操作") public void add()&#123;&#125;&#125; 编写使用方法规则被拦截器： 1234567package aop;import org.springframework.stereotype.Service;@Servicepublic class DemoMethodService &#123; public void add()&#123;&#125;&#125; 编写切面： 1234567891011121314151617181920212223242526272829303132package aop;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.stereotype.Component;import java.lang.reflect.Method;@Aspect //该注解声明一个切面@Component //定义为Beanpublic class LogAspect &#123; @Pointcut("@annotation(aop.Action)") //声明一个切点 public void annotationPointCut()&#123;&#125; @After("annotationPointCut()") //声明一个建言，并使用@Pointcut定义的切点 public void after(JoinPoint joinPoint)&#123; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); Action action = method.getAnnotation(Action.class); System.out.println("注解式拦截 " + action.name()); &#125; @Before("execution(* aop.DemoMethodService.*(..))") public void before(JoinPoint joinPoint)&#123; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); System.out.println("方法式拦截 " + method.getName()); &#125;&#125; 配置类： 12345678910package aop;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@Configuration@ComponentScan("aop")@EnableAspectJAutoProxy //开启Spring对AspectJ的支持public class AopConfig &#123;&#125; 测试： 12345678910111213141516171819package aop;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AopConfig.class); DemoAnnotationService demoAnnotationService = context.getBean(DemoAnnotationService.class); DemoMethodService demoMethodService = context.getBean(DemoMethodService.class); demoAnnotationService.add(); demoMethodService.add(); context.close(); &#125;&#125;输出结果为：注解式拦截 注解式拦截的add操作方法式拦截 add]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows内存]]></title>
    <url>%2F2018%2F06%2F20%2FWindows%E5%86%85%E5%AD%98%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Windows中内存是如何分配的。 分配的是虚拟地址空间，不是虚拟空间；为什么分配这么大？这是windows给出的承诺，向应用程序承诺，在物理内存足够大的情况下，我能够提供给你这么大的地址空间（注意这里的用词是地址空间，意思是有允许其内存寻址最多到8T这个数字）当然，虚拟内存空间地址是一回事，实际空间是另一回事。之前说了，虚拟空间地址只是承诺能够寻址，并非真的分配了空间；当应用程序真的申请了地址空间内能访问的内存时，windows才会开始把被访问的内存页映射到物理内存中。（没错，人家就是打了个空头支票，实际情况是你用一页我分配一页）所以总结如下：所谓的8T（0x200000000）有什么用：允许应用程序访问0x0-0x200000000的任意地址，当然访问0x200000001就会报错，因为超出地址空间了（所以虚拟地址空间越大越好，这样编译器布局内存自由度更大）64位系统为例，物理内存16G，应用程序用了10G，会发生什么：也就是说我允许应用程序用8T内存，但他只用了10G，那没问题，因为可以映射到16G物理内存中；64位系统为例，物理内存16G，应用程序用了17G，会发生什么：唔，物理内存有点不够用，但是可以把一些内存页存到硬盘上（虚拟内存），所以问题也不大，但是进程切换可能引起内存页在硬盘上的读写，所以电脑会有点卡64位系统为例，物理内存16G，应用程序申请了8T，会发生什么：没错，应用程序的确被允许使用8T内存，但是此时系统提供不了这么多，空头支票暴露，你的系统奔溃了]]></content>
      <categories>
        <category>内存</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机类加载机制]]></title>
    <url>%2F2018%2F06%2F20%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[记录下Java中类加载的时机，类在加载过程经历的阶段。&lt;未完待续&gt; 7.2 类加载的时机类从被加载到虚拟机内存开始，到卸载出内存，其整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析部分统称为连接。 ​ 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，什么时候开始加载并没有进行强制约束，可以交给虚拟机的具体实现来自由把握。 ​ 对于初始阶段，虚拟机规范严格规定了有且只有5种情况必须对类立即进行初始化： 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类时，发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 虚拟机启动时，用户需指定一个要执行的主类（包含main()方法的那个类），虚拟机会初始化这个类。 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 ​ 接口加载过程与类加载过程与类加载过程稍微有一些不同，接口也有初始化的过程，接口中不能使用static{}语句块，但编译器仍然会为接口生成“()”类构造器，用于初始化接口中所定义的成员变量。接口与类真正有所求区别的是前面讲述的5种“有且只有”需要初始化场景中的第3种：当初始化一个类时，发现其父类还没有进行过初始化，则需要先触发其父类的初始化。但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。 7.3 类加载的过程7.3.1 加载加载阶段虚拟机需要完成3件事情： 1231. 通过一个类的全限定名来获取定义此类的二进制字节流。2. 将字节流所代表的静态存储结构转化为方法区的运行时数据结构。3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 ​ 这三点要求并不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的，例如：通过全限定名来获取此类的二进制流，没有规定要从Class文件中获取，所以就有多种花样： ​ 从ZIP包中读取，最终成为日后JAR、EAR、WAR格式的基础。 ​ 从网络中获取，这种场景最典型的应用就是Applet。 ​ 运行时计算生成，这种场景使用最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是使用了ProxyGenerator.generateProxyClass来为特定接口生成形式为“*＄Proxy”的代理类的二进制字节流。 ​ 由其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。 ​ 从数据库中读取，这种场景相对少见些。例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库来完成程序代码在集群中的分发。 ​ 对于数组类而言，情况有所不同，数组类本身不通过类加载器创建，由Java虚拟机直接创建。但数组类与类加载器仍由紧密的联系，因为数组类的元素类型最终是要靠类加载器去创建，一个数组（C）创建过程如下： ​ 数组组件类型是引用型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识。 ​ 如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与引导类加载器关联。 ​ 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。 ​ 加载阶段完成后，虚拟机外部的二进制字节流按照虚拟机所需格式存储在方法区中，数据存储格式由虚拟机自行定义。然后在内存实例化一个java.lang.Class类的对象（没有明确在Java堆中，对于HotSpot而言，Class虽然是对象，但是存放在方法区中），这个对象作为程序访问方法区中的这些类型数据的外部接口。加载阶段和连接阶段的部分内容是交叉进行的。 7.3.2 验证​ JVM通过检查输入的字节流是否符合Class文件格式的约束，验证阶段大致上会完成4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。 文件格式验证 ​ 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理： 是否以魔数0xCAFEBABE开头。 主、次版本号是否在当前虚拟机处理范围之内。 常量池的常量中是否有不被支持的常量类型（检查tag标志） 指向常量的索引值是否有指向不存在的常量或不符合类型常量 …………………… ​ 第一阶段的验证远不止如此，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。该验证基于二进制字节流进行，通过该验证后字节流才进入内存的方法区中进行存储，所以后面的验证都是基于方法区的存储结构进行的，不会直接操作字节流。 元数据验证 ​ 第二阶段是对字节码描述的信息进行语义分析以确保描述的信息符合Java语言规范的要求： 这个类是否有父类（除了Object外所有类都要有父类） 这个类的父类是否继承了不允许被继承的类（被final修饰的类） 如果不是抽象类是否实现了父类或接口中要求实现的所有方法 类中字段、方法是否与父类产生矛盾 ……………………………….. ​ 第二阶段目的主要是对类的元数据信息进行语义分析验证，保证不存在不符合Java语言规范的元数据信息。 字节码验证 ​ 第三阶段是最复杂的阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。该阶段对类的方法体进行校验分析，保证被校验类方法在运行时不会做出危害虚拟机安全的事件： 保证任意时刻操作数栈数据类型与指令代码序列能配合工作。 保证跳转指令不会跳转到方法体以外的字节码指令上。 保证方法体中类型转换是有效的 子类可赋值给父类 反之不行。 ……………………………………….. ​ 若一个类方法的字节码未通过字节码验证，肯定是有问题的；但如果一个方法通过字节码验证，也不能说明其一定是安全的。这里涉及著名的“Halting Problem”（停机问题）：通俗讲就是通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。 ​ JDK1.6之后Javac编译器和JVM进行了优化，给方法体Code属性的属性表里增加了一项“StackMapTable“属性，描述了方法体所有基本块（Basic Block，按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，在字节码验证期间就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。 符号引用验证 ​ 最后阶段校验发生在虚拟机将符号引用转化为直接引用，这个转化将在连接的第三阶段——解析阶段中发生。可看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验： 符号引用中通过字符串描述的全限定名是否能找到对应的类。 指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。 符号引用中的类、字段、方法访问性是否可以被当前类访问。 ………………………………………….. 符号验证目的是确保解析动作正常执行。 7.3.3 准备​ 该阶段是正式为类变量分配内存并设置类变量初始值的阶段，类变量所使用的内存都将在方法区中进行分配。该阶段有两个概念：首先，进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象初始化的时候随着对象一起分配在Java堆中。其次这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量定义为：public static int value = 123；那变量在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器()方法中，所以把value赋值为123的动作将在初始化阶段才会执行。 ​ 上述提到的只是“通俗情况”下初始值是零值，还有一些“特殊情况”下：如果类字段的字段属性表中存在ConstantValue属性所指定的值，假设上述变量定义为：public static final int value = 123；编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据这个设置将value赋值为123. 可以看到字节码中多了ConstantValue属性并且有一个初始值为123 7.3.4 解析]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类文件结构]]></title>
    <url>%2F2018%2F06%2F20%2F%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[分析一波Class类文件的结构，此处所使用的二进制文件查看用的classpy。 6.3 Class类文件的结构6.3.1 魔数与Class文件的版本​ Class文件是一组以8位（1个字节）为基础单位的二进制流，中间没有分隔符。每个Class文件的头4个字节成为魔数，它唯一作用就是确定这个文件是否为一个能被虚拟机接受的Class文件（其实好多文件类型都是使用魔数来识别的）。使用魔数而不是扩展名来进行识别主要是考虑安全性，因为文件扩展名是可以随意改动的。 ​ 紧接着魔数的四个字节存储的是Class文件的版本号（如图所示）：第5个和第6个字节是次版本号（Minor Version），第7个和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的（图中0X0034转化为十进制为52，说明这个文件可以被JDK1.8或以上的本地虚拟机执行的Class文件），JDK1.1之后的每个JDK大版本发布主版本号向上加1，高版本JDK向下兼容以前版本的Class文件，但不能运行以后版本的class文件，即使文件格式并未发生任何变化。 6.3.2 常量池​ 理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时还是在Class文件中第一次出现的表类型数据项目。 ​ 常量池中主要存放两大类常量：字面量和符号引用。 ​ 字面量：比较接近Java语言层面的常量概念，如文本串、申明为final的常量值等。 ​ 符号引用：编译原理层面，包含三类，即类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。Java在编译的时候不会像C/C++那样有一个“连接”的过程，而是在虚拟机加载Class文件的时候进行动态连接。Class文件不保存方法字段的最终内存信息，所以这些方法、字段的符号引用不经过运行期转换的话无法得到真正的内存入口地址，无法被虚拟机使用。当虚拟机运行时，需从常量池获得对应的符号引用，再在类创建或运行时解析、翻译到具体的内存地址之中。 ​ 常量池中每一项常量都是一个表，表的开始第一位是一个u1类型的标志位（tag），代表当前这个常量属于哪种常量类型。之所以说常量池是最繁琐的数据，是因为常量类型各自均有自己的结构。 ​ 由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型的常量来描述名称，所以该类型的最大长度就是Java中方法、字段名的最大长度。这里u2类型能表达的最大值是65535。所以Java程序中如果定义了超过64KB英文字符的变量和方法名，将无法编译。javap -verbose可以用于输出Class文件字节码内容。 6.3.3 访问标志​ 常量池结束之后，紧跟着两个字节代表访问标志（access_flags），用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类则是否被声明为final等。一共有16个标记位可以使用。 6.3.4 类索引、父类索引与接口索引集合​ 类索引（this_class）和父类索引（super_class）都是u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系。Java不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，即父类索引都不为0。接口索引集合描述这个类实现了哪些接口，这些被实现的接口按Implement语句（如果类本身是一个接口，则是extends语句）后的顺序从左到右排列在接口索引集合中。 ​ 类索引和父类索引用两个u2类型索引值表示，各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过其中的索引值找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。 ​ 对于接口索引集合，入口第一项——u2类型的数据为接口计数器（interfaces_count），表示索引容量。如果该类没有实现任何接口，则计数器为0，后面索引表不占任何字节。如图所示。 6.3.5 字段表集合​ 用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。可以包括的信息有：字段的作用域（public、private、protected）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。上述信息修饰符都是布尔值，要么有某个修饰符，要么没有。而字段叫什么、字段被定义为什么数据类型，这些都是无法固定的只能引用常量池中的常量来描述。 ​ 表中的两项索引值：name_index和descriptor_index，它们都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符。 ​ 以书中的代码6-1为例，“org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅把类全名中的“.”替换成了“/”而已，为了使多个全限定名之间不产生混淆，在使用时最后一般会加入一个“；”,表示全限定名结束。简单名称指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别是“inc”和“m”。 ​ 相对于全限定名和简单名称来说，方法和字段的描述符复杂一些，描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。 6.3.6 方法表集合​ Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。 ​ 方法的定义可以通过标志、名称索引、描述符索引表达清楚，方法里的java代码经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面。 ​ 与字段表中集合相对应，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。同样有可能出现由编译器自动添加的方法，最典型的就是类构造器”“方法和实例构造器”“方法。 ​ 在Java中，重载（Overload）一个方法除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此Java中无法仅仅依靠返回值的不同来对一个已有方法进行重载的。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调优案例分析与实战]]></title>
    <url>%2F2018%2F06%2F20%2F%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[通过案例来分析Java部署中相关的优化措施。 5.2案例分析5.2.1 高性能硬件上的程序部署策略目前高性能硬件上部署程序主要的两种方式： 通过64位JDK来使用大内存： ​ 对于用户交互性强、对停顿时间敏感的系统给虚拟机分配超大堆的前提是有把握把应用程序的Full GC频率控制得足够低，譬如十几个小时甚至一天才出现一次Full GC。而控制Full GC的频率关键看应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。同时还需要面临的问题： ​ 内存回收导致的长时间停顿。 ​ 现阶段64位JDK的性能测试结果普遍低于32位JDK。 ​ 需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照（因为要产生十几GB乃至更大的Dump文件），哪怕产生了快照也无法分析。 ​ 相同程序在64位JDK消耗的内存一般比32位JDK大，这是由于指针膨胀和数据类型对齐补白等因素导致的。 ​ 使用若干个32位虚拟机建立逻辑集群来利用硬件资源： ​ 现阶段大多采用该方法，具体做法是在一台物理机器上启动多个应用服务器进程，每个服务器进程分配不同的端口，然后在前端搭建一个负载均衡器以反向代理的方式来分配访问请求。这种方案可能会遇到的问题： ​ 尽量避免节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话（尤其式并发写操作容易出现问题），很容易导致IO异常。 ​ 很难高效地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能一些节点池满了而另外一些节点仍有较多空余。尽管可以使用集中式的JNDI（理解为同一资源池），但有一定复杂性并且可能带来额外的性能开销。 ​ 各节点仍然不可避免地受到32位的内存限制，32位windows系统每个进程只能使用2GB的内存，若考虑堆以外的内存开销则堆一般最多只能开到1.5GB。在某些Linux或Unix系统中可以提升至3GB甚至接近4GB的内存，但32位中仍然受最高4GB内存的限制。 ​ 大量使用本地缓存的应用在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点上都有一份缓存，这时候可以考虑把本地缓存改为集中式缓存。 5.2.2 集群间同步导致的内存溢出​ 例：一个基于B/S的MIS系统，硬件为两台2个CPU、8GB内存的HP小型机。服务器为WebLogic9.2，每台机器启动了三个WebLogic实例，构成一个6个节点的亲合式集群（节点之间没有进行Session同步），但有一些需求要实现部分数据在各节点间共享。开始这些数据存放在数据库中，由于读写频繁竞争很激烈，性能影响较大，后来使用JBossCatch构建了一个全局缓存。启用后不久却不定期地出现了多次内存溢出问题。 ​ 查看生成的dump 文件发现里面有大量的org.jgroups.protocols.pbcast.NAKACK对象。JBossCatch基于自家的JGroups进行集群间的数据通信，JGroups使用协议栈的方式来实现收发数据包的各种所需特性自由组合。由于信息有传输失败需要重发的可能性，在确认所有注册在GMS(Group Membership Service)的节点都收到正确的信息前，发送信息必须在内存中保留。MIS服务端有一个负责安全校验的全局Filter，每当收到请求均更新一次最后操作时间并将其同步到所有节点，使一个用户一段时间内不能在多台机器上登录。服务器使用过程中往往一个页面产生数次乃至数十次的请求，因此这个过滤器导致集群节点之间网络交互非常频繁。当网络情况不能蛮子传输要求时，重发数据在内存中不断堆积，很快产生了内存溢出。若使用JBossCatch缓存来同步的话可以允许读操作频繁，但不应当有过于频繁的写操作。 5.2.3 堆外内存导致的溢出错误​ 例子：学校小型项目，基于B/S的电子考试系统，为了实现客户端能实时地从服务器端接收考试数据系统使用了逆向AJAX技术。测试期间发现服务端不定时抛出内存溢出异常，服务器不一定每次都会抛出异常。管理员尝试过把堆卡到最大，32位系统堆最多到1.6G就基本无法再大了，而且开大了基本没什么效果，异常好像还更加频繁了。想通过参数使其产生dump文件，发现什么文件也没有产生。最后在内存溢出后从系统日志中找到异常堆栈。 ​ 服务器使用32位Windows平台的限制是2GB，其中划了1.6GB给Java堆，而Direct Memory内存并不算入1.6GB的堆之内，因此最大也只能在剩余的0.4GB中分出一部分。此应用中导致溢出的原因为：垃圾收集时虚拟机虽然会对Direct Memory进行回收，但是Direct Memory不像新生代、老年代那样发现空间不足了就通知收集器进行垃圾回收，它只能等待老年代满了以后Full GC，然后顺便地帮他清理掉废弃的对象。否则它只能一直等到抛出内存溢出异常时先catch掉，再在catch块中调用System.gc()，要是此使虚拟机还不进行gc，那就不得不抛出内存溢出异常了（虽然有可能堆中还有很多空闲内存）。本案例中使用的CometD 1.1.1框架，正好有大量的NIO操作要使用到Direct Memory内存。 除了Java堆和永久代外，下面区域还会占用较多的内存： ​ Direct Memory：可通过参数-XX:MaxDirectMemorySize进行大小的调整。 ​ 线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError（栈深不足，纵向）和OutOfMemoryError（无法建立新线程，横向）。 ​ Socket缓存区：每个Socket连接都有Receive和Send两个缓存区，分别占37KB和25KB，连接多的话这部分内存也比较可观，如无法分配则可能抛出IOException:Too many open files异常。 ​ JNI代码：使用JNI调用本地库，使用的内存也不在堆中。 ​ 虚拟机和GC：虚拟机、GC的代码执行也要消耗一定的内存。 5.2.4 外部命令导致系统缓慢​ 例子：一个数字校园应用系统运行在Solaris操作系统上，中间件为GlassFish服务器。系统做大并发压力测试发现请求响应时间较慢，使用mpstat发现CPU使用率高并且系统占用绝大多数的CPU资源。后来使用Dtrace发现最消耗CPU资源的是“fork”系统调用。 ​ 原因是：每个用户请求的处理都需要执行一个外部shell脚本来获得系统的信息，执行这个shell脚本是通过Java的Runtime.getRuntime().exec()方法来调用的。这种调用方式在虚拟机中非常消耗资源，频繁调用创建进程开销非常可观，系统消耗会很大，不仅是CPU，内存负荷也很重。 5.2.5 服务器JVM进程崩溃​ 例子：一个基于B/S的MIS系统正常运行一段时间后发现在运行期间频繁出现集群节点的虚拟机进程自动关闭现象。从系统日志文件可看出发生过大量的远端断开连接的异常，通过系统管理员了解到系统最近与一个OA门户做了集成，在MIS系统工作流的代办事项变化时要通过Web服务通知OA门户系统，把代办事项的变化同步到OA门户中。通过SoapUI测试了同步待办事项的Web服务，发现调用以后需要3分钟才能返回，并且返回结果都是连接中断。 ​ 由于MIS系统用户多、待办事项变化快，为了不被OA系统拖累使用了异步方式调用Web服务，由于两边速度不对等，时间久了就积累了越多Web服务没有调用完成，导致等待的线程和Socket来连接越来越多，最终超过虚拟机的承受范围使其崩溃。 ​ 解决方法：通知OA门户方修复无法使用的集成接口，并将以不调用改为生产者/消费者模式的消息队列后，系统恢复正常。 5.2.6 不恰当数据结构导致内存占用过大​ 例子：一个后台RPC服务器，64位虚拟机内存配置-Xms4g -Xmx8g -Xmn1g，使用ParNew+CMS的收集器组合平时Minor GC时间30毫秒以内，能接收。但业务上需每10分钟加载一个约80MB的数据文件到内存，这些数据在内存中形成超过100万个HashMap&lt;Long, long&gt; Entry，在这段时间里Minor GC会造成超过500毫秒停顿。原因在于：分析数据文件期间，800MB的Eden空间很快被填满从而引发GC，但是Minor GC以后新生代绝大多数对象还存活。ParNew收集器使用复制算法，对于这种情况将它们复制到Survivor并维持这些对象的引用成为一个沉重的负担，导致GC暂停时间明显变长。 ​ 如果不修改程序仅从GC调优角度去解决这个问题，可以考虑将Survivor空间去掉（通过参数），让新生代中存活的对象在第一次Minor GC后立即进入老年代，等到Major GC的时候再清理他们。这种措施治标不治本，治本的话需要修改程序，因为产生这种情况的根本原因是HashMap&lt;Long, Long&gt; 结构来存储数据文件空间效率太低。 5.2.7 由Windows虚拟内存导致的长时间停顿​ 例子：带心跳检测功能的GUI桌面程序，每15秒发送一次心跳检测信号，若30秒内没收到返回信息，就认为和对方程序的连接已经断开。程序上线后发现检测有误报的概率，查询日志发现原因是程序偶尔出现间隔一分钟左右的时间完全无日志输出，处于停顿状态。 ​ 从GC日志文件中确认了停顿原因是由GC导致的，偶尔会出现一次接近一分钟的GC。从日志片段中可以看出，真正执行GC动作的时间不是很长，但从准备开始GC，到真正开始GC之间所消耗的时间却占了绝大多数。[Times：user=0.61 sys=0.52，real=31.16 secs]可以看出。 ​ 除GC日志之外，还观察到这个GUI程序内存变化的一个特点，当它最小化的时候资源管理显示的占用内存大幅度减小，但是虚拟内存则没有变化，因此怀疑程序最小化时工作内存被交换到了磁盘的页面文件之中，这样发生GC时就有可能因为恢复页面而导致不正常的GC停顿，可以通过参数来解决（保证程序在最小化时能立即响应）。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机性能监控与故障处理工具]]></title>
    <url>%2F2018%2F06%2F20%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[JDK工具使用 主要记录一些JDK工具使用，包括内存监视和快照生成查看等一系列可视化工具。&lt;未完待续&gt; 4.2 JDK的命令行工具 4.2.1 jps：虚拟机进程状况工具​ 其功能和UNIX中的ps命令相似：列出正在进行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称及进程的本地虚拟机唯一ID(LVMID)。 4.2.2 jstat：虚拟机统计信息监视工具​ 用于监视虚拟机各种运行状态信息的命令行工具，可以显示远程或者本地虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 4.2.3 jinfo：Java配置信息工具​ 该工具可以实时地查看和调整虚拟机各项参数。 4.2.4 jmap：Java内存映像工具​ 该命令用于生成堆转储快照（称为dump文件）。 4.2.5 jhat：虚拟机堆转储快照分析工具​ 该命令与jmap搭配使用，来分析jmap生成的dump文件，不过实际上一般不会直接使用jhat来分析dump文件，两个原因：1. 一般不在部署应用的服务器上直接分析dump，即使这样做也会尽量将dump复制到其他机器上分析；2. jhat分析功能比较简陋，还有其他强大的工具可以选择。 4.2.6 jstack：Java堆栈跟踪工具​ 该命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。其主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 4.2.7 HSDIS：JIT生成代码反汇编​ 将本地代码还原为汇编代码输出（没成功）。 4.3 JDK的可视化工具4.3.1 JConsole：Java监视与管理控制台​]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集和内存分配]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[关于Java虚拟机GC垃圾收集机制，主要介绍了不同区域所使用的垃圾收集算法，以及他们的结合种类、适用场景。 3.4 HotSpot算法实现3.4.2 安全点​ JVM通过GC Roots节点来判断某个对象是否可达，但是如果需要逐个检查的话必然会消耗很多时间，所以需要使用一个名为OopMap的数据结构来记录引用位置的信息（如指令流的起始位置，偏移量等）。 ​ 在OopMap的帮助下，JVM可以很快的完成GC Roots的枚举，但是这里会出现一个问题：并不是所有的指令都会生成对应的OopMap数据结构，假设如此需要大量的额外空间，导致GC的空间成本将会变得非常高。这里的解决办法是只在“特定位置”记录这些信息，这样的位置称之为安全点（safe point），当线程执行到safe point的时候才会停顿下来开始GC。这里的safe point选定不能太少也不能太多，太少GC等太久，太多增大运行负荷；这里的设置特征为“是否让程序长时间执行的特征”，最明显的特征就是指令序列的复用比如方法调用、循环跳转、异常跳转等位置。 ​ 为了让GC发生是所有线程（不包括JNI调用的线程）都能在最近的安全点停下来，有两种方法：抢先式中断和主动式中断。抢先式：GC发生时，中断所有线程，发现不在安全点的就恢复它使之跑到安全点上（目前几乎不用，不详细表）；主动式：GC发生时，不直接操作线程仅设置一个标志，各个线程在执行的时候主动去轮询这个标志，为真时自动挂起（轮询标志和安全点是重合的）。 3.4.3 安全区域​ 安全区域的设定是为了解决程序“不执行”的时候，即未分配CPU时间，因此线程无法响应JVM的中断请求挂起，典型的例子就是Sleep和Block状态。这时需要设置一个安全区域（safe region），安全区域是安全点的一个很大的扩展，设置原则为引用关系不会发生变化的一段代码片段。在线程离开安全区域之前会检查GC是否完成了根节点的枚举，完成的话继续执行，否则等待知道收到可以安全离开安全区域的信号为止。 3.5 垃圾收集器3.5.1 Serial收集器​ Serial是一个最基本、发展最久的收集器，单线程，但不仅仅说明它只会使用一个CPU或者一条线程去完成垃圾收集工作，更重要的是它在收集垃圾时必须暂停其他所有线程直到它结束（Stop The World），虽然不科学但是依然是Client模式下默认新生代收集器，优点：简单高效（没有线程交互的开销，专心收垃圾）。在桌面场景中新生代内存往往不大，所以停顿时间可以控制在几十最多一百多毫秒以内。 3.5.2 ParNew收集器​ 其实是Serial的多线程版本，只有它能与CMS收集器配合使用；目前新生代的垃圾收集只能从Serial和ParNew中选择，在单CPU的情况下ParNew不比Serial好（甚至由于线程交互的开销不能超过Serial）,但是随着CPU数量的增加，它对于GC时的系统资源的有效利用还是很有好处的。默认开启的线程数与CPU数量相同，可用参数进行限制。 3.5.3 Parallel Scavenge收集器​ Parallel Scavenge的关注点和其他收集器不同，CMS等收集器是尽可能地缩短垃圾收集时用户线程的停顿时间，而该收集器目标时达到一个可控制的吞吐量（吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间））。和ParNew相比他们都是使用的复制算法，又是并行的多线程~ 但是不同的是Parallel Scavenge提供了两个参数用于精确控制吞吐量，分别为控制最大垃圾收集停顿时间参数以及直接设置吞吐量大小参数；停顿时间是虚拟机通过设置吞吐量和新生代空间大小来调整的。还有一个自适应调节策略（虚拟机根据系统情况自己调节）也是和ParNew的一个重要区别。 3.5.4 Serial Old收集器​ Serial的老年代版本，垃圾回收算法使用的是标记-整理算法。主要两大用途：jdk1.5以及之前版本中与Parallel Scavenge收集器搭配使用；作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure 时使用。 3.5.5 Parallel Old 收集器​ Parallel Scavenge的老年代版本，使用标记-整理算法。jdk1.6之前Parallel Scavenge较尴尬：因为新生代一旦选择Parallel Scavenge，老年代就只能使用Serial Old，所以无法充分利用多CPU的处理能力。后来有了Parallel Old就可以和它组合使用，真正注重吞吐量了。 3.5.6 CMS收集器​ CMS收集器是一种以获取最短回收停顿时间为目标的收集器。基于“标记-清除”算法实现，运作过程分为四个步骤：初始标记，并发标记，重新标记，并发清除。 ​ 初始标记：仅仅标记一下GC Roots能直接关联到的对象，速度快但是需要“Stop The World”。 ​ 并发标记：进行GC Roots Tracing的过程，能够与用户线程一起工作。 ​ 重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，此阶段停顿时间比初始标记阶段时间稍长但是远比并发标记时间短，需要“Stop The World”。具体如何实现，做了什么还不清楚暂时不表。 ​ 并发清除：清理未被标记的对象（不可达的），与用户线程一起并发执行。 ​ 主要特点：并发收集、低停顿。 缺点： 对CPU资源非常敏感，虽然不会导致用户线程停顿但是会明显占用CPU资源而导致应用程序变慢，总吞吐量降低。CMS默认启动的回收线程数是（CPU数+3）/ 4 。这样导致用户程序执行速度忽然降低难以接受，所以虚拟机提供了“增量式并发收集器”，模拟操作系统使用抢占式来模拟多任务，使GC线程、用户线程交替运行，这样会使整个垃圾收集时间变长。实践证明这种处理效果一般，不提倡使用。 无法处理浮动垃圾，浮动垃圾：由于并发清理阶段用户线程的运行产生新的垃圾，这部分垃圾未被标记导致当前周期无法被处理，需等下一周期。所以CMS不能老年代满了再收集，需要设置一部分空间给应用程序，jdk1.6中将启动阈值提高到了92%。但是用户可以通过参数进行设置，如果预留内存无法满足需要（Concurrent Mode Failure），虚拟机会启动后备预案：临时启动Serial Old来重新进行老年区的垃圾收集，这样停顿时间就会很久。如果启动阈值设置过高，会导致大量的“Concurrent Mode Failure”失败，性能大大降低。 这个缺点就是“标记-清除”算法普遍存在的了，收集结束会有大量空间碎片产生，当有大对象时无法找到足够大的连续空间来分配，因此提前触发了一次Full GC。为此CMS收集器提供-XX:+UseCMSCompactAtFullCollection开关参数（默认开），用于在进行Full GC时开启碎片合并整理过程，这样停顿时间变长。虚拟机设计者还提供-XX:CMSFullGCsBeforeCompaction，设置多少次不压缩的Full GC以后来一次带压缩的（默认0）。 这里有个疑问：既然使用“标记-清除”会导致大量空间碎片产生，那为什么不使用“标记-整理”算法呢？遂一顿搜索发现：原来CMS为了获取最短回收停顿时间而将耗时长的设为并发（并发标记和并发清理），如果在并发时通过整理移动了对象的内存，那么线程就会找不到应用对象在哪里。 3.5.7 G1收集器​ G1（Garbage-First）收集器是新出的，面向服务端应用的收集器，有如下特点：1.并行与并发，能充分利用多CPU、多核环境缩短STW的时间；2.分代收集，能够采用不同方式处理不同类型的旧对象；3.空间整合，从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的（没理解）；4.可预测停顿，G1除了追求低停顿外还建立可预测的停顿时间模型，制定M时间片段内收集垃圾时间不能超过N，其原因在于可以有计划地避免在整个堆中进行全区域的垃圾收集，G1跟踪各个Region中垃圾收集的价值（根据获取空间大小和所需时间）维护一个表，每次优先回收价值高的Region。 ​ Region之间不可能是孤立的，不然检测Region之间的对象引用的时候还得扫描整个Java堆导致效率降低。所以每个Region需维护一个Remembered Set记录该Region被引用对象的相关引用信息，在内存回收时加入Remembered Set的扫描即可。 G1收集器运作步骤： 初始标记：和CMS一样，该阶段仅标记一下GC Roots能直接关联的对象并修改TAMS。 并发标记：从GC Root开始对堆中对象进行可达性分析，找出存活对象，该过程耗时久但是可并发操作。 最终标记：修正并发标记过程中因用户程序运作而导致产生变化的标记记录，虚拟机将其记录在线程Remembered Set Logs中，并在此阶段将其合并到Remembered Set中，可并行。 筛选标记：首先对各个Region回收价值和成本进行排序，根据用户期望的停顿时间来制定回收计划，可并行，但是停顿用户线程将大幅提高收集效率。 3.5.8 GC日志3.6 内存分配与回收策略3.6.1 对象优先在Eden分配​ Eden区和Survivor区都属于新生代，而Eden区存放的对象一般都是生命周期不长的对象（因此使用复制算法进行回收）。 3.6.2大对象直接进入老年代​ 所谓大对象指大量连续内存空间的Java对象，最典型的就是很长的字符串以及数组（更坏的消息是遇到一群“朝生夕灭”的“短命大对象”），经常导致内存还有不少就不得不提前触发垃圾收集来获取足够的连续空间来存放他们。可以通过设置-XX:PretenureSizeThreshold参数来设置这个上限值。 3.6.3 长期存活的对象将进入老年代​ 通过对象年龄计数器来记录对象，当熬过第一次Minor GC进入Survivor区并将年龄设置为1，接着每熬过一次Minor GC就将年龄加1，当年龄加到一定程度就被晋升入老年代中（默认为15），这个年龄阈值可以通过-XX:MaxTenuringThreshold参数设置。 3.6.4 动态对象年龄判断​ 虚拟机并不是永远要求对象年龄达到阈值才晋升老年代的，如果在Survivor中相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就直接进入老年代无需等到要求的阈值年龄了。 3.6.5 空间分配担保​ 在发生Minor GC前，虚拟机会检查老年代最大连续可用空间是否大于新生代所有对象总空间，如成立则此次Minor GC是安全的。如不成立，虚拟机检查是否允许担保失败（HandlePromotionFailure参数），若允许则检查老年代最大可用连续空间是否大于历次晋升到老年代对象平均大小，若大于则进行一次有风险的Minor GC，若小于或者设置为不允许担保失败，则进行一次Full GC。 ​ JDK 6 update 24以后规则发生了更改，即不管HandlePromotionFailure参数如何设置，代码中都不会使用它，规则变为只要老年代连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>gc</tag>
      </tags>
  </entry>
</search>
